[
  {
    "qid": {
      "en-US": "1-1"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. クラス名の衝突を避けるための名前空間を提供する。",
        "B. パッケージ名は、必ずインターネットドメイン名を逆順にした形式でなければならない。",
        "C. クラスやインターフェース、メンバーへのアクセスレベルを制御するメカニズムを提供する。",
        "D. 関連性の高いクラス群を論理的にグループ化し、整理するために使用される。",
        "E. `package`宣言を記述しないソースファイル内のクラスは、いかなるパッケージにも属さない。"
      ]
    },
    "answer": {
      "en-US": [
        0,
        2,
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaのパッケージ機能に関する記述として、適切なものを3つ選択しなさい。"
    },
    "explanation": {
      "en-US": "パッケージは、クラス名などの名前衝突を防ぐ名前空間を提供します(A)。また、アクセス修飾子と組み合わせてアクセス制御を実現します(C)。関連するクラスをまとめることで、コードの整理や管理が容易になります(D)。ドメイン名を逆順にするのは広く推奨される命名規則ですが、必須ではありません(B)。`package`宣言がない場合、クラスは「無名パッケージ（unnamed package）」に属します(E)。"
    },
    "questionCategory": {
      "en-US": "パッケージの役割"
    }
  },
  {
    "qid": {
      "en-US": "1-2"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. Aのコード",
        "B. Bのコード",
        "C. Cのコード",
        "D. Dのコード"
      ]
    },
    "answer": {
      "en-US": [
        1,
        2
      ]
    },
    "code": {
      "en-US": "A.\nimport java.util.*;\npackage com.example;\npublic class MyUtility {}\n\nB.\npackage com.example;\nimport java.util.*;\npublic class MyUtility {}\n\nC.\n// This is a comment\npackage com.example;\nimport java.util.*;\npublic class MyUtility {}\n\nD.\npackage com.example {\n import java.util.*;\n public class MyUtility {}\n}"
    },
    "questionText": {
      "en-US": "以下のコードのうち、`package`宣言が正しく記述されているものをすべて選択しなさい。"
    },
    "explanation": {
      "en-US": "Javaのソースファイルでは、`package`宣言はコメントを除き、ファイルの先頭に記述する必要があります。`import`宣言よりも前に置かなければなりません。選択肢Aは`import`の後に`package`があるため誤りです。選択肢Dは`package`宣言の構文が間違っています。選択肢Cはコメントが`package`宣言より前にありますが、コメントは無視されるため、`package`が実質的な先頭となり正しいです。選択肢Bも`package`が先頭にあり正しいです。"
    },
    "questionCategory": {
      "en-US": "package宣言の記述ルール"
    }
  },
  {
    "qid": {
      "en-US": "1-3"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `java.lang`パッケージに所属している全てのクラス。",
        "B. `java.util`パッケージに所属している`List`インターフェース。",
        "C. 現在コンパイル中のソースファイルと同じパッケージに属する他のクラス。",
        "D. 現在のパッケージの直下にあるサブパッケージ内のクラス。"
      ]
    },
    "answer": {
      "en-US": [
        0,
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "`import`宣言を記述しなくても、Javaコンパイラによって自動的に利用可能となるクラスはどれですか。適切なものを2つ選択しなさい。"
    },
    "explanation": {
      "en-US": "Javaコンパイラは、`java.lang`パッケージ内のすべてのクラス（例: `String`, `System`, `Integer`など）を自動的にインポートします(A)。また、現在処理しているソースファイルと同じパッケージに存在する他のクラスも、`import`宣言なしで利用できます(C)。`java.util`パッケージのクラス(B)や、サブパッケージ内のクラス(D)は、明示的に`import`するか、完全修飾クラス名で指定する必要があります。"
    },
    "questionCategory": {
      "en-US": "import宣言の省略可能性"
    }
  },
  {
    "qid": {
      "en-US": "1-4"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 0が表示される",
        "B. コンパイルエラーが発生する",
        "C. 100が表示される",
        "D. 実行時にエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// StudentInfo.java\npackage com.school.data;\nimport com.school.base.Person;\n\npublic class StudentInfo extends Person {\n  public static void main(String[] inputs) {\n    // ※ 注: 本来staticメソッドから\n    //   インスタンスメンバーへの直接\n    //   アクセスはコンパイルエラー。\n    //   アクセス制御の理解を問う問題\n    //   として解釈。\n    System.out.println(id);\n  }\n}\n\n// Person.java (別ファイル)\n// package com.school.base;\n// public class Person {\n//  protected int id = 100;\n// }"
    },
    "questionText": {
      "en-US": "以下の`StudentInfo`クラスをコンパイルし、実行したときの結果として適切なものを選びなさい。`Person`クラスは別ファイルで、異なるパッケージ`com.school.base`に定義されているものとします。(1つ選択)"
    },
    "explanation": {
      "en-US": "`StudentInfo`クラスは、異なるパッケージ`com.school.base`に属する`Person`クラスを継承しています。`Person`クラスの`id`フィールドは`protected`で宣言されています。`protected`メンバーは、それが定義されたクラスと同じパッケージ内のクラス、またはそのクラスを継承したサブクラス（パッケージが異なっていても）からアクセス可能です。`StudentInfo`は`Person`のサブクラスなので、`id`にアクセスできます。したがって、100が表示されます(C)。 (注意: `static`な`main`メソッドからインスタンスフィールド`id`へ直接アクセスするコードは、実際にはコンパイルエラーとなります。この問題はアクセス制御のルールのみを問うていると解釈してください。)"
    },
    "questionCategory": {
      "en-US": "継承とアクセス制御(protected)"
    }
  },
  {
    "qid": {
      "en-US": "1-5"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public`アクセス修飾子を持つ必要がある。",
        "B. `static`キーワードが付与されている必要がある。",
        "C. 1つの `.java` ファイル内には、`main`メソッドは1つしか記述できない。",
        "D. 戻り値の型は `int` でなければならない。",
        "E. 引数として `String`の配列 (`String[]`) または `String`の可変長引数 (`String...`) を受け取る必要がある。",
        "F. 実行が成功した場合、必ず `0` を返さなければならない。"
      ]
    },
    "answer": {
      "en-US": [
        0,
        1,
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaアプリケーションの実行開始点となる`main`メソッドを定義するための要件として、正しいものを3つ選択しなさい。"
    },
    "explanation": {
      "en-US": "Javaの`main`メソッドは、プログラムの実行を開始するためにJVM（Java仮想マシン）から呼び出されます。そのシグネチャ（メソッド名、引数、修飾子など）は厳密に定められています。`public` (A) であり、`static` (B) でなければなりません。引数は `String`型の配列 `String[] args` または可変長引数 `String... args` (E) である必要があります。戻り値の型は `void` でなければならず、値を返しません(D, Fは誤り)。1つのソースファイルに複数の`main`メソッドを持つクラスを定義すること自体は可能ですが、エントリーポイントとして指定できるのは通常1つです(Cは不適切)。"
    },
    "questionCategory": {
      "en-US": "mainメソッドの定義要件"
    }
  },
  {
    "qid": {
      "en-US": "1-6"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. Apple:Orange",
        "B. Orange:Banana",
        "C. CommandLineApp:Apple",
        "D. Need 2 args",
        "E. ArrayIndexOutOfBoundsExceptionが発生する"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// CommandLineApp.java\npublic class CommandLineApp {\n  public static void main(String[] params\n  ) {\n    // 引数が2つ以上あることを前提とする\n    if (params.length >= 2) {\n      System.out.println(params[0] + \":\" \n        + params[1]);\n    } else {\n      System.out.println(\"Need 2 args\")\n        ;\n    }\n  }\n}\n\n// 実行コマンド:\n// > java CommandLineApp Apple Orange Banana"
    },
    "questionText": {
      "en-US": "このの`CommandLineApp.java`をコンパイルした後、指定されたコマンドで実行したとき、コンソールに出力される結果として正しいものを選びなさい。(1つ選択)"
    },
    "explanation": {
      "en-US": "`java`コマンドでクラスを実行する際、クラス名の後に続くスペース区切りの文字列がコマンドライン引数として`main`メソッドの引数配列（ここでは`params`）に渡されます。実行コマンド `java CommandLineApp Apple Orange Banana` では、`params[0]` に \"Apple\"、`params[1]` に \"Orange\"、`params[2]` に \"Banana\" が格納されます。プログラムは `params[0]` と `params[1]` をコロン `:` で連結して出力するため、結果は \"Apple:Orange\" となります(A)。"
    },
    "questionCategory": {
      "en-US": "コマンドライン引数の処理"
    }
  },
  {
    "qid": {
      "en-US": "1-7"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `javac MyProgram.java`",
        "B. `java MyProgram`",
        "C. `java MyProgram.java`",
        "D. `jar MyProgram.jar`",
        "E. `javadoc MyProgram.java`",
        "F. `jlink --module-path mods --add-modules myapp --output myruntime`"
      ]
    },
    "answer": {
      "en-US": [
        1,
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "コマンドライン環境でJavaプログラム（クラスファイルまたはソースファイル）を実行するために使用されるコマンドとして、適切なものを2つ選択しなさい。"
    },
    "explanation": {
      "en-US": "Javaプログラムを実行するための主要なコマンドは `java` です。2つの主な方法があります。1つ目は、まず `javac MyProgram.java` コマンドでソースファイルをコンパイルし、生成された `MyProgram.class` ファイルを `java MyProgram` コマンドで実行する方法です(B)。2つ目は、Java 11以降で導入されたソースファイル・ローンチャ機能を使用し、`java MyProgram.java` コマンドでコンパイルと実行を一度に行う方法です(C)。`javac` はコンパイル用コマンドです(A)。`jar` はJARファイル作成・操作用(D)、`javadoc` はドキュメント生成用(E)、`jlink` はカスタムランタイムイメージ作成用(F)であり、直接的なプログラム実行コマンドではありません。"
    },
    "questionCategory": {
      "en-US": "Javaプログラム実行コマンド"
    }
  },
  {
    "qid": {
      "en-US": "1-8"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 1",
        "B. 2",
        "C. 3",
        "D. 4"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// ArgsCounter.java\npublic class ArgsCounter {\n  public static void main(String... input\n  s) {\n    System.out.println(inputs.length);\n  }\n}\n\n// 実行コマンド:\n// > java ArgsCounter one \"two three\" four"
    },
    "questionText": {
      "en-US": "このの`ArgsCounter.java`をコンパイルした後、指定されたコマンドで実行した場合、コンソールに出力される結果として正しいものを選びなさい。(1つ選択)"
    },
    "explanation": {
      "en-US": "コマンドライン引数は、通常スペースによって区切られます。ただし、ダブルクォーテーション (`\"`) で囲まれた部分は、内部にスペースが含まれていても1つの引数として扱われます。実行コマンド `java ArgsCounter one \"two three\" four` では、引数は \"one\"、\"two three\"、\"four\" の3つになります。プログラムは引数配列 `inputs` の要素数 (`inputs.length`) を出力するため、結果は `3` となります(C)。"
    },
    "questionCategory": {
      "en-US": "コマンドライン引数の個数"
    }
  },
  {
    "qid": {
      "en-US": "1-9"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `java PrintMessage.class`",
        "B. `javac PrintMessage`",
        "C. `java PrintMessage.java`",
        "D. `javac PrintMessage.java` の後に `java PrintMessage` を実行",
        "E. `java PrintMessage Message`"
      ]
    },
    "answer": {
      "en-US": [
        2,
        3
      ]
    },
    "code": {
      "en-US": "// PrintMessage.java\npublic class PrintMessage {\n  public static void main(String[] args) \n  {\n    System.out.println(\"Message\");\n  }\n}"
    },
    "questionText": {
      "en-US": "このの`PrintMessage.java`を実行し、コンソールに \"Message\" と表示させたいと考えています。これを実現するためのコマンドライン操作として適切なものを2つ選択しなさい。"
    },
    "explanation": {
      "en-US": "Javaプログラムを実行するには `java` コマンドを使用します。2つの主な方法があります。1つ目は、まず `javac PrintMessage.java` コマンドでソースファイルをコンパイルし、生成された `PrintMessage.class` ファイルを `java PrintMessage` コマンドで実行する方法です(D)。2つ目は、Java 11以降で導入されたソースファイル・ローンチャ機能を使用し、`java PrintMessage.java` コマンドでコンパイルと実行を一度に行う方法です(C)。`java`コマンドではクラス名のみを指定し、`.class`拡張子は付けません(Aは誤り)。`javac` はコンパイルコマンドであり、`.java`拡張子が必要です(Bは誤り)。`Message` はコマンドライン引数であり、このプログラムでは使用されません(Eは実行自体は可能だが、表示内容を変えるものではない)。"
    },
    "questionCategory": {
      "en-US": "プログラムのコンパイルと実行コマンド"
    }
  },
  {
    "qid": {
      "en-US": "1-10"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public static void main(String args)`",
        "B. `static public void main(String[] arguments)`",
        "C. `public void main(String[] params)`",
        "D. `public static int main(String... options)`",
        "E. `private static void main(String[] data)`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaアプリケーションのエントリーポイントとして機能する`main`メソッドの正しい定義はどれですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "エントリーポイントとなる`main`メソッドは `public` かつ `static` で、戻り値の型が `void` であり、引数として `String` の配列 (`String[]`) または `String` の可変長引数 (`String...`) を受け取る必要があります。修飾子 `public` と `static` の順序はどちらでも構いません。引数名は任意です。選択肢Bはこれらの条件を満たしています。Aは引数が配列でない、Cは`static`でない、Dは戻り値が`int`、Eは`private`であるため、それぞれエントリーポイントとして機能しません。"
    },
    "questionCategory": {
      "en-US": "mainメソッドのシグネチャ定義"
    }
  },
  {
    "qid": {
      "en-US": "1-11"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. Javaソースコード（`.java`ファイル）をJVMが実行可能なバイトコード（`.class`ファイル）に変換する。",
        "B. Javaバイトコード（`.class`ファイル）を実行する。",
        "C. JavaソースコードからAPIドキュメント（HTML形式）を生成する。",
        "D. 複数のクラスファイルやリソースファイルを一つのアーカイブファイル（`.jar`ファイル）にまとめる。",
        "E. Javaプログラムのデバッグを行う。"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java開発において、`javac` コマンドの主な役割は何ですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "`javac` コマンドはJavaコンパイラです。その主な役割は、人間が読み書きするJavaソースコード (`.java`ファイル) を、Java仮想マシン (JVM) が理解し実行できるバイトコード (`.class`ファイル) にコンパイル（変換）することです(A)。バイトコードの実行は`java`コマンド(B)、APIドキュメント生成は`javadoc`コマンド(C)、JARファイルの作成は`jar`コマンド(D)、デバッグは`jdb`などのデバッガツール(E)が担当します。"
    },
    "questionCategory": {
      "en-US": "javacコマンドの役割"
    }
  },
  {
    "qid": {
      "en-US": "1-12"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. Javaソースコードをバイトコードにコンパイルする。",
        "B. Java仮想マシン (JVM) を起動し、指定されたクラスのバイトコードを実行する。",
        "C. クラスファイルからソースコードを逆コンパイルする。",
        "D. Javaアプリケーションのパフォーマンスを監視する。",
        "E. Javaのライブラリモジュールを管理する。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java開発において、`java` コマンドの主な役割は何ですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "`java` コマンドはJavaアプリケーションランチャーです。その主な役割は、Java仮想マシン (JVM) を起動し、引数で指定されたクラスの `main` メソッドを探して実行を開始することです(B)。コンパイルは`javac`コマンド(A)、逆コンパイルは`javap`コマンド(C)、パフォーマンス監視は`jstat`やVisualVMなど(D)、モジュール管理は`jmod`やビルドツール(E)が関連します。"
    },
    "questionCategory": {
      "en-US": "javaコマンドの役割"
    }
  },
  {
    "qid": {
      "en-US": "1-13"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `java.lang` パッケージ",
        "B. `default` パッケージ",
        "C. 無名パッケージ (unnamed package)",
        "D. コンパイルエラーとなるため、どのパッケージにも属さない",
        "E. `java.default` パッケージ"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// NoPackageDemo.java\n// (package宣言なし)\npublic class NoPackageDemo {\n  public static void main(String[] args) {\n    System.out.println(\"Hello\");\n  }\n}"
    },
    "questionText": {
      "en-US": "ソースファイルの先頭に`package`宣言を記述しなかった場合、そのファイルで定義されるクラスはどのパッケージに属しますか。(1つ選択)"
    },
    "explanation": {
      "en-US": "Javaソースファイルで `package` 宣言が省略された場合、そのファイル内で定義されるクラスやインターフェースは「無名パッケージ（unnamed package）」と呼ばれる特別なパッケージに属します(C)。これは、簡単なプログラムや学習目的で使われることがありますが、大規模開発では名前衝突のリスクがあるため推奨されません。`default` パッケージという名前のパッケージはありません(B, E)。`java.lang` は自動インポートされますが、属するわけではありません(A)。コンパイルエラーにもなりません(D)。"
    },
    "questionCategory": {
      "en-US": "無名パッケージ"
    }
  },
  {
    "qid": {
      "en-US": "1-14"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 単純名 (Simple Name) 指定",
        "B. 完全修飾クラス名 (Fully Qualified Class Name) 指定",
        "C. オンデマンドインポート (Import on Demand)",
        "D. 自動インポート (Automatic Import)",
        "E. 相対パス指定 (Relative Path Specification)"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "package com.myapp.ui;\n\npublic class MainScreen {\n  public static void main(String[] args) {\n    // java.awt.Button を import せずに利用\n    java.awt.Button okButton =\n      new java.awt.Button(\"OK\");\n    System.out.println(okButton.getLabel());\n  }\n}"
    },
    "questionText": {
      "en-US": "こののコードのように、`import`宣言を使用せずに、クラスが属するパッケージ名からクラス名まで全てを指定してクラスを利用する方法を何と呼びますか。(1つ選択)"
    },
    "explanation": {
      "en-US": "他のパッケージに属するクラスを利用する際に、`import`文を使わず、`パッケージ名.クラス名` の形式でクラスを指定する方法を「完全修飾クラス名 (Fully Qualified Class Name, FQCN)」指定と呼びます(B)。これにより、どのパッケージのどのクラスを使用しているかが明確になりますが、コード記述が長くなる傾向があります。"
    },
    "questionCategory": {
      "en-US": "完全修飾クラス名 (FQCN)"
    }
  },
  {
    "qid": {
      "en-US": "1-15"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. Aはシングルタイプインポート、Bはオンデマンドインポート（ワイルドカードインポート）と呼ばれる。",
        "B. Bの形式を使用すると、`java.util`パッケージのすべてのサブパッケージ内のクラスもインポートされる。",
        "C. Aの形式の方が、Bの形式よりもコンパイル後のクラスファイルのサイズが小さくなる。",
        "D. 実行時のパフォーマンスは、一般的にAの形式の方がBの形式よりも優れている。",
        "E. Bの形式は非推奨であり、Java 17では使用できない。"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "import java.util.ArrayList; // A\nimport java.util.*;       // B"
    },
    "questionText": {
      "en-US": "こののJavaコードに示される2種類の`import`宣言に関する説明として、正しいものを選択せよ。(1つ選択)"
    },
    "explanation": {
      "en-US": "A (`import java.util.ArrayList;`) のように特定のクラス名を指定するものをシングルタイプインポート、B (`import java.util.*;`) のようにアスタリスク(`*`)を使ってパッケージ内の全クラスを対象とするものをオンデマンドインポート（またはワイルドカードインポート）と呼びます(A)。オンデマンドインポートは指定されたパッケージ内のクラスのみを対象とし、サブパッケージは含みません(B)。どちらの形式を使っても、実際に使用されるクラスの情報のみがクラスファイルに含まれるため、クラスファイルのサイズや実行時パフォーマンスに大きな違いは通常ありません(C, D)。どちらの形式もJava 17で使用可能です(E)。"
    },
    "questionCategory": {
      "en-US": "import宣言の種類"
    }
  },
  {
    "qid": {
      "en-US": "1-16"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"inputs\" と表示される",
        "B. 何も表示されない",
        "C. \"No args\" と表示される",
        "D. `ArrayIndexOutOfBoundsException` が発生する",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// EchoArgs.java\npublic class EchoArgs {\n  public static void main(String[] input\n  s) {\n    if (inputs.length > 0) {\n      System.out.println(inputs[0]);\n    } else {\n      System.out.println(\"No args\");\n    }\n  }\n}\n\n// 実行コマンド:\n// > java EchoArgs"
    },
    "questionText": {
      "en-US": "このの`EchoArgs.java`をコンパイルし、指定されたコマンドで実行した場合、コンソールに出力される結果として正しいものを選びなさい。(1つ選択)"
    },
    "explanation": {
      "en-US": "実行コマンド `java EchoArgs` では、クラス名の後にコマンドライン引数が指定されていません。そのため、`main`メソッドの引数 `inputs` は要素数0の配列 (`inputs.length` が 0) となります。プログラムは `inputs.length > 0` の条件を評価し、これが `false` となるため `else` ブロックが実行され、\"No args\" が出力されます(C)。"
    },
    "questionCategory": {
      "en-US": "コマンドライン引数なしの場合"
    }
  },
  {
    "qid": {
      "en-US": "1-17"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `/project/src/com/example/App.class`",
        "B. `/project/classes/App.class`",
        "C. `/project/classes/com/example/App.class`",
        "D. `/project/App.class`",
        "E. `/project/com/example/classes/App.class`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// src/com/example/App.java\npackage com.example;\n\npublic class App {\n  public static void main(String[] args) {\n    System.out.println(\"Hello\");\n  }\n}\n\n// 実行ディレクトリ: /project\n// コマンド:\n// > javac -d classes src/com/example/App.java"
    },
    "questionText": {
      "en-US": "こののファイル構成とコマンドで`App.java`をコンパイルした場合、生成されるクラスファイル (`App.class`) はどのディレクトリに配置されますか。(1つ選択)"
    },
    "explanation": {
      "en-US": "`javac` コマンドの `-d` オプションは、生成されるクラスファイルのルートディレクトリを指定します。ソースファイルに `package com.example;` のようにパッケージ宣言がある場合、コンパイラはそのパッケージ構造に対応するディレクトリ構造を `-d` で指定されたディレクトリ以下に作成します。したがって、`classes` ディレクトリの下に `com/example` ディレクトリが作成され、その中に `App.class` が配置されます(C)。"
    },
    "questionCategory": {
      "en-US": "javacコマンドのオプション (-d)"
    }
  },
  {
    "qid": {
      "en-US": "1-18"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `java com.start.MainApp`",
        "B. `java -cp classes com.start.MainApp`",
        "C. `java -classpath src com.start.MainApp`",
        "D. `java classes/com/start/MainApp`",
        "E. `java -cp classes/com/util:classes/com/start MainApp`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// /app/libs/Utility.java\npackage com.util;\npublic class Utility {\n  public static void message() {\n    System.out.println(\"Helper msg\");\n  }\n}\n\n// /app/src/MainApp.java\npackage com.start;\nimport com.util.Utility;\npublic class MainApp {\n  public static void main(String[] args) {\n    Utility.message();\n  }\n}\n\n// コンパイル後、クラスファイルが以下にあるとする\n// /app/classes/com/util/Utility.class\n// /app/classes/com/start/MainApp.class\n\n// 実行ディレクトリ: /app"
    },
    "questionText": {
      "en-US": "こののファイル構成で、`/app` ディレクトリから `MainApp` クラスを実行するための正しい `java` コマンドはどれですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "実行するクラス (`MainApp`) と、それが依存するクラス (`Utility`) が異なるパッケージにあり、クラスファイルが `classes` ディレクトリ以下にパッケージ構造を反映して配置されています。この場合、`java` コマンドに `-cp` (または `-classpath`) オプションを使って、クラスファイルの検索を開始するルートディレクトリ (`classes`) を指定する必要があります。そして、実行するクラスは完全修飾名 (`com.start.MainApp`) で指定します。したがって、Bが正しいコマンドです。Aはクラスパスが指定されていないため `Utility` クラスを見つけられません。Cはクラスパスの指定がソースディレクトリになっています。Dはクラスファイルを直接指定する形式ではありません。Eはクラスパスの指定方法が冗長で、実行クラス名も単純名になっています。"
    },
    "questionCategory": {
      "en-US": "javaコマンドのクラスパス指定"
    }
  },
  {
    "qid": {
      "en-US": "1-19"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. コンパイルエラーが発生する。",
        "B. 実行時に `IllegalAccessException` がスローされる。",
        "C. \"Executed!\" と表示される。",
        "D. 実行時に `NoSuchMethodError` がスローされる。",
        "E. `java` コマンドがクラスを見つけられずエラーとなる。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// NonPublicEntry.java\nclass NonPublicEntry {\n  public static void main(String[] args) {\n    System.out.println(\"Executed!\");\n  }\n}"
    },
    "questionText": {
      "en-US": "このの `NonPublicEntry.java` (クラスに `public` 修飾子なし) をコンパイルし、`java NonPublicEntry` コマンドで実行した場合の結果として正しいものを選びなさい。(1つ選択)"
    },
    "explanation": {
      "en-US": "Javaでは、エントリーポイントとなる `main` メソッドを持つクラス自体は `public` である必要はありません。クラスが `public` でなくても、`main` メソッドが `public static void` で正しく定義されていれば、`java` コマンドで実行できます。したがって、このコードは正常にコンパイル・実行され、\"Executed!\" と表示されます(C)。"
    },
    "questionCategory": {
      "en-US": "mainメソッドを持つクラスのアクセス修飾子"
    }
  },
  {
    "qid": {
      "en-US": "1-20"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされ、`AppLauncher.class` が生成される。",
        "B. 正常にコンパイルされ、`MyLauncher.class` が生成される。",
        "C. コンパイルエラーが発生する。理由は、ファイル名と `public` クラス名が一致しないため。",
        "D. コンパイルは成功するが、実行時にエラーが発生する。",
        "E. コンパイル時に警告が表示されるが、`AppLauncher.class` が生成される。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// MyLauncher.java\npublic class AppLauncher {\n  public static void main(String[] args) {\n    System.out.println(\"Start\");\n  }\n}"
    },
    "questionText": {
      "en-US": "こののコードを `MyLauncher.java` という名前で保存してコンパイルしようとした場合、どうなりますか。(1つ選択)"
    },
    "explanation": {
      "en-US": "Javaのルールとして、1つのソースファイルに `public` なクラス（またはインターフェースなど）は1つしか定義できず、その `public` なクラスの名前はソースファイル名（拡張子を除く）と一致しなければなりません。このコードでは、`public` なクラス名は `AppLauncher` ですが、ファイル名は `MyLauncher.java` です。この不一致のため、コンパイル時にエラーが発生します(C)。"
    },
    "questionCategory": {
      "en-US": "ソースファイル名とpublicクラス名"
    }
  },
  {
    "qid": {
      "en-US": "1-21"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. クラスパスのルートディレクトリ直下 (`/Processor.java`)",
        "B. クラスパスのルート/`com` ディレクトリ直下 (`/com/Processor.java`)",
        "C. クラスパスのルート/`com/data` ディレクトリ直下 (`/com/data/Processor.java`)",
        "D. クラスパスのルート/`data` ディレクトリ直下 (`/data/Processor.java`)",
        "E. ディレクトリ構造は任意である。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// 想定: /project/src/com/data/Processor.java\npackage com.data;\n\npublic class Processor {\n  // ...\n}"
    },
    "questionText": {
      "en-US": "Javaソースファイル内で `package com.data;` と宣言されている場合、このソースファイル (`Processor.java`) は、コンパイル時や実行時に、一般的にどのようなディレクトリ構造の中に配置されている必要がありますか。(1つ選択)"
    },
    "explanation": {
      "en-US": "Javaのパッケージ名は、ファイルシステムのディレクトリ構造に対応している必要があります。`package com.data;` と宣言されたクラスを含むソースファイルは、クラスパスの起点となるディレクトリ（ソースパスのルートや、`-d` で指定した出力先ディレクトリのルート）から見て `com` というサブディレクトリの中の `data` というサブディレクトリに配置する必要があります(C)。コンパイラやJVMは、この規約に基づいてクラスファイルを検索します。"
    },
    "questionCategory": {
      "en-US": "パッケージ宣言とディレクトリ構造"
    }
  },
  {
    "qid": {
      "en-US": "1-22"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "パッケージの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. インスタンスメンバー（非staticなフィールドやメソッド）をクラス名なしで利用できるようにする。",
        "B. `public static` なメンバー（フィールドやメソッド）をクラス名を省略してアクセスできるようにする。",
        "C. 指定されたパッケージのすべてのクラスをインポートする。",
        "D. `private static` なメンバーへのアクセスを許可する。",
        "E. 外部ライブラリのクラスをインポートする唯一の方法である。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import static java.lang.Math.PI;\nimport static java.lang.System.out;\n\npublic class CircleCalculator {\n  public static void main(String[] args) {\n    double radius = 5.0;\n    // staticインポートによりクラス名省略\n    double area = PI * radius * radius;\n    // staticインポートによりオブジェクト名省略\n    out.println(\"Area: \" + area);\n  }\n}"
    },
    "questionText": {
      "en-US": "`import static` 文（スタティックインポート）に関する説明として、最も適切なものを選択せよ。(1つ選択)"
    },
    "explanation": {
      "en-US": "`import static` は、指定されたクラスの `public static` なメンバー（定数やstaticメソッド）を、クラス名を省略して直接利用できるようにするための構文です(B)。これにより、コード内で `Math.PI` の代わりに `PI`、`System.out` の代わりに `out` と記述できます。インスタンスメンバー(A)やprivateメンバー(D)は対象外です。パッケージ全体のクラスをインポートするのは通常のオンデマンドインポート `import package.*;` です(C)。staticインポートはインポート方法の一つであり、唯一の方法ではありません(E)。"
    },
    "questionCategory": {
      "en-US": "staticインポート"
    }
  },
  {
    "qid": {
      "en-US": "2-23"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"   Line 1\\n Line 2\\n   Line 3\\n\"",
        "B. \"      Line 1\\n    Line 2\\n      Line 3\\n\"",
        "C. \"Line 1\\nLine 2\\nLine 3\\n\"",
        "D. \" Line 1\\nLine 2\\n Line 3\\n\""
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "1. public class TextBlockIndent {\n2.  public static void main(String[] args) {\n3.   String block = \"\"\"\n4.      Line 1\n5.    Line 2\n6.      Line 3\n7.   \"\"\"; // 終了符のインデントは空白3つ\n8.   System.out.print(block);\n9.  }\n10.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを選択してください。インデントはスペースで表現されているものとします。改行は `\\n` で示します。(1つ選択)"
    },
    "explanation": {
      "en-US": "テキストブロックでは、「偶発的なインデント」（すべての内容行と終了符の行に共通する先頭の空白）が除去されます。この例では、Line 1 (6スペース), Line 2 (4スペース), Line 3 (6スペース), 終了符 (3スペース) の中で最も少ないインデントは終了符の3スペースです。したがって、各内容行の先頭から3スペースが除去されます。Line 1: 6-3=3スペース、Line 2: 4-3=1スペース、Line 3: 6-3=3スペース。結果は `\"   Line 1\\n Line 2\\n   Line 3\\n\"` となります。"
    },
    "questionCategory": {
      "en-US": "テキストブロックのインデント処理"
    }
  },
  {
    "qid": {
      "en-US": "1-24"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 必ず `args` という名前にしなければならない。",
        "B. `params` または `arguments` のいずれかでなければならない。",
        "C. 任意の有効なJava識別子を使用できる（慣習として `args` が多い）。",
        "D. 引数名は省略可能である。",
        "E. 配列ではなく `List<String>` 型を使用し、名前は `stringList` とする必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class ArgumentNameDemo {\n  public static void main(String[] cmdLine\n  Params) {\n    System.out.println(\"Length: \" +\n      cmdLineParams.length);\n  }\n}"
    },
    "questionText": {
      "en-US": "`main` メソッドの引数である `String` 配列の名前について、正しい説明はどれですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "`main` メソッドのシグネチャで要求されるのは、引数の型が `String[]` または `String...` であることです。引数名はプログラマーが自由に決めることができ、有効なJavaの識別子であれば何でも構いません。慣習的に `args` という名前が広く使われていますが、必須ではありません(A, B 誤り)。コード例のように `cmdLineParams` など、他の名前を使用しても問題なく動作します(C 正しい)。引数名自体は省略できません(D 誤り)。型は `String` 配列または可変長引数である必要があり、`List<String>` は使えません(E 誤り)。"
    },
    "questionCategory": {
      "en-US": "mainメソッドの引数名"
    }
  },
  {
    "qid": {
      "en-US": "1-25"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `java MultiMain`",
        "B. `java MultiMain.ToolB`",
        "C. `java ToolB`",
        "D. `java MultiMain ToolB`",
        "E. `java -entry ToolB MultiMain`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// MultiMain.java\nclass ToolA {\n  public static void main(String[] args) {\n    System.out.println(\"Running Tool A\")\n      ;\n  }\n}\n\nclass ToolB {\n  public static void main(String[] args) {\n    System.out.println(\"Running Tool B\")\n      ;\n  }\n}\n\npublic class MultiMain {\n  // このクラスには main メソッドはない\n}"
    },
    "questionText": {
      "en-US": "このの `MultiMain.java` ファイルをコンパイルした後、`ToolB` クラスの `main` メソッドを実行したい場合、使用すべき正しい `java` コマンドはどれですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "1つの `.java` ファイル内に複数のクラスを定義でき、それぞれが `main` メソッドを持つことも可能です（ただし `public` クラスはファイル名と一致するもの1つのみ）。`javac MultiMain.java` でコンパイルすると、`ToolA.class`, `ToolB.class`, `MultiMain.class` が生成されます。特定のクラスの `main` メソッドを実行するには、`java` コマンドの引数として、そのクラス名を指定します。`ToolB` の `main` を実行したい場合は `java ToolB` とします(C)。ファイル名や他のクラス名を指定しても、意図した `main` メソッドは実行されません(A, B, D, E 誤り)。"
    },
    "questionCategory": {
      "en-US": "複数のmainメソッドと実行指定"
    }
  },
  {
    "qid": {
      "en-US": "1-26"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. コマンドラインからユーザー入力を読み取る。",
        "B. ファイルにデータを書き込む。",
        "C. 指定された文字列や値を標準出力（通常はコンソール）に表示し、改行する。",
        "D. プログラムの実行を一時停止する。",
        "E. 指定された文字列をエラー出力ストリームに表示する。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class Greeter {\n  public static void main(String[] args) {\n    String message = \"Welcome!\";\n    System.out.println(message);\n  }\n}"
    },
    "questionText": {
      "en-US": "Javaプログラムにおいて、`System.out.println()` メソッドの主な役割は何ですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "`System.out` は標準出力ストリームを表すオブジェクトです。その `println()` メソッドは、引数として渡されたデータ（文字列、数値など）を標準出力（通常はコマンドプロンプトやターミナルなどのコンソール画面）に表示し、その後でカーソルを次の行の先頭に移動させる（改行する）機能を持っています(C)。入力の読み取り(A)は `System.in` や `Scanner`、ファイル書き込み(B)は `FileWriter` など、エラー出力(E)は `System.err` が関連します。"
    },
    "questionCategory": {
      "en-US": "標準出力への表示"
    }
  },
  {
    "qid": {
      "en-US": "1-27"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. すべてのコードは、少なくとも1つのクラス定義 (`class {...}`) の中に記述する必要がある。",
        "B. プログラムのエントリーポイントは `start()` という名前のメソッドである。",
        "C. 変数宣言は、必ずクラスの直下で行わなければならない。",
        "D. Javaプログラムは、トップレベルに関数を直接定義できる。",
        "E. `package`宣言と`import`宣言は、クラス定義の後に記述する。"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "最も基本的なJavaアプリケーションプログラムの構造に関する説明として、正しいものを選択せよ。(1つ選択)"
    },
    "explanation": {
      "en-US": "Javaはオブジェクト指向言語であり、すべての実行コードはクラス（またはインターフェースなど）のコンテキスト内に存在する必要があります。したがって、どんなに単純なプログラムでも、少なくとも1つのクラス定義が必要です(A)。エントリーポイントは`main`メソッドです(B)。変数はメソッド内（ローカル変数）やクラス直下（フィールド）などで宣言できます(C)。Javaはトップレベルに関数を直接定義できません（クラスメソッドとして定義）(D)。`package`宣言（存在する場合）はファイルの先頭、`import`宣言はその次に記述され、クラス定義はその後です(E)。"
    },
    "questionCategory": {
      "en-US": "Javaプログラムの基本構造"
    }
  },
  {
    "qid": {
      "en-US": "1-28"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `java com/sample/HelloWorld.java`",
        "B. `java HelloWorld.java`",
        "C. `java -cp . com.sample.HelloWorld`",
        "D. `java com.sample.HelloWorld.java`",
        "E. `java --source 11 com/sample/HelloWorld.java`"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// com/sample/HelloWorld.java\npackage com.sample;\n\npublic class HelloWorld {\n  public static void main(String[] args) {\n    System.out.println(\"Pkg Hello\");\n  }\n}\n\n// 実行ディレクトリ: /project\n// ファイル配置: /project/com/sample/HelloWorld.java"
    },
    "questionText": {
      "en-US": "Java 11以降の単一ソースファイル実行機能を使って、このの `HelloWorld.java` を `/project` ディレクトリから実行する場合、適切なコマンドはどれですか。(1つ選択)"
    },
    "explanation": {
      "en-US": "Java 11以降では、`java` コマンドで `.java` ファイルを直接指定してコンパイルと実行を一度に行えます。ソースファイルに `package` 宣言が含まれている場合、そのファイルはパッケージ構造に対応するディレクトリに配置されている必要があります。実行時には、ソースファイルのパスをクラスパスルートからの相対パスで指定します。この例では、`/project` ディレクトリから見て `com/sample/HelloWorld.java` が正しいパス指定になります(A)。単純なファイル名(B)やパッケージ名を含む形式(D)では、ソースファイルを見つけられません。`--source`オプションはこの文脈では通常不要です(E)。Cはコンパイル済みのクラスを実行する際のコマンド形式です。"
    },
    "questionCategory": {
      "en-US": "単一ソースファイル実行とパッケージ"
    }
  },
  {
    "qid": {
      "en-US": "1-29"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "コマンドラインでのJavaプログラムのコンパイルと実行"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `FileNotFoundException` がスローされる。",
        "B. `Compilation failed` というメッセージが表示される。",
        "C. `Error: Could not find or load main class <クラス名>` のようなエラーメッセージが表示される。",
        "D. `NullPointerException` がスローされる。",
        "E. 何も起こらず、コマンドプロンプトがすぐに戻る。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "コンパイル済みのクラスファイルが存在しないクラス名、またはクラスパスから見つけられないクラス名を `java` コマンドで実行しようとした場合、一般的にどのような結果になりますか。(1つ選択)"
    },
    "explanation": {
      "en-US": "`java` コマンドは、指定されたクラスをクラスパスから探し、その `main` メソッドを実行しようとします。指定されたクラスが見つからない場合、JVMはクラスをロードできないため、プログラムを実行できません。この結果、一般的に「クラスが見つからない」または「メインクラスをロードできない」旨を示すエラーメッセージ（例: `Error: Could not find or load main class ...`）が表示されて終了します(C)。これは実行時エラーであり、コンパイルエラー(B)や特定の例外(A, D)とは異なります。"
    },
    "questionCategory": {
      "en-US": "存在しないクラスの実行"
    }
  },
  {
    "qid": {
      "en-US": "1-30"
    },
    "chapter": {
      "en-US": "1章"
    },
    "category": {
      "en-US": "mainメソッドを持つ実行可能なJavaプログラムの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる。",
        "B. コンパイルエラーが発生する（例: ';' expected）。",
        "C. コンパイルは成功するが、実行時に `RuntimeException` がスローされる。",
        "D. コンパイル時に警告 (Warning) が表示されるが、クラスファイルは生成される。",
        "E. `System` クラスが見つからないというエラーが発生する。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class SyntaxErrorDemo {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\") // <- セミコロン欠落\n  }\n}"
    },
    "questionText": {
      "en-US": "こののコードを `javac` コマンドでコンパイルしようとした場合、どのような結果が予想されますか。(1つ選択)"
    },
    "explanation": {
      "en-US": "Javaのステートメント（文）の多くは、セミコロン (`;`) で終了する必要があります。コード例の `System.out.println(\"Hello World\")` の行末にはセミコロンが欠落しています。これはJavaの構文規則違反であるため、`javac` コンパイラはこの問題を検出し、コンパイルエラー（典型的には「';' expected」のようなメッセージ）を報告します(B)。エラーがあるため、クラスファイルは正常には生成されません。"
    },
    "questionCategory": {
      "en-US": "単純なコンパイルエラー"
    }
  },
  {
    "qid": {
      "en-US": "2-1"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "変数の宣言および初期化と変数のスコープ"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 何も表示されない",
        "B. コンパイルエラーが発生する",
        "C. 7が1回表示される",
        "D. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class ConditionCheck {\n public static void main(String[] args) {\n  int score = 7;\n  boolean isActive = true;\n  if (isActive = false) {\n   do {\n    System.out.println(score);\n   } while (score > 10);\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合の出力結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "if文の条件式 `isActive = false` は、比較演算子(`==`)ではなく代入演算子(`=`)です。変数`isActive`に`false`が代入され、この代入式全体の結果も`false`となります。そのため、ifブロック内のコードは実行されません。結果として、何もコンソールに出力されません。"
    },
    "questionCategory": {
      "en-US": "if文と代入演算子"
    }
  },
  {
    "qid": {
      "en-US": "2-2"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "Javaの基本データ型と文字列の操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. int numA = 267;",
        "B. int numB = 0x10B;",
        "C. int numC = 0b100001011;",
        "D. int numD = 0413;",
        "E. int numE = 0827;"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "次のJavaの変数宣言のうち、コンパイル時にエラーとなるものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaにおいて、整数リテラルが`0`で始まる場合、それは8進数として解釈されます。8進数で使用できる数字は `0` から `7` までです。選択肢Eの `0827` では、8進数リテラル内に許可されていない数字 `8` が含まれているため、コンパイルエラーとなります。Aは10進数、Bは16進数(`0x`接頭辞)、Cは2進数(`0b`接頭辞)、Dは正しい8進数です。"
    },
    "questionCategory": {
      "en-US": "整数リテラルの基数表現"
    }
  },
  {
    "qid": {
      "en-US": "2-3"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "Javaの基本データ型と文字列の操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. int val1 = 123_456_789;",
        "B. int val2 = 5____2;",
        "C. int val3 = _123_456;",
        "D. int val4 = 123_456_;",
        "E. float val5 = 3_.14F;",
        "F. long val6 = 999_88_7777_L;",
        "G. byte val7 = 0b0_1;",
        "H. int val8 = 0_77;",
        "I. int val9 = 0x_AB;"
      ]
    },
    "answer": {
      "en-US": [
        2,
        3,
        4,
        7,
        8
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下の数値リテラルを使用した変数宣言のうち、コンパイルエラーとなるものを5つ選択してください。"
    },
    "explanation": {
      "en-US": "Java 7から、数値リテラルの桁区切りとしてアンダースコア `_` を使用できますが、いくつかのルールがあります。アンダースコアは数字と数字の間にのみ配置できます。リテラルの先頭(C)、末尾(D)、小数点の直前または直後(E)、基数を示す接頭辞(`0`, `0b`, `0x`)の直後(H, I)にアンダースコアを置くことはできません。これらに該当するC, D, E, H, Iがコンパイルエラーとなります。"
    },
    "questionCategory": {
      "en-US": "数値リテラル内のアンダースコア"
    }
  },
  {
    "qid": {
      "en-US": "2-4"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "変数の宣言および初期化と変数のスコープ"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. int $count = 10;",
        "B. int _value = 20;",
        "C. int 1stPrize = 30;",
        "D. int total# = 40;",
        "E. int student.id = 50;"
      ]
    },
    "answer": {
      "en-US": [
        2,
        3,
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "次の変数宣言のうち、Javaの識別子の命名規則に違反し、コンパイルエラーとなるものを3つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaの識別子（変数名、クラス名など）に使用できる文字は、英字、数字、アンダースコア(`_`)、ドル記号(`$`)です。ただし、識別子の先頭に数字は使用できません。また、予約語は使用できず、特殊記号も限定されます。Cは数字から始まっているため無効です。Dはハッシュ記号(`#`)が使用できないため無効です。Eはドット(`.`)が識別子内に使用できないため無効です。AとBは有効な識別子です。したがって、C, D, Eがコンパイルエラーとなります。"
    },
    "questionCategory": {
      "en-US": "識別子の命名規則違反"
    }
  },
  {
    "qid": {
      "en-US": "2-5"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "Javaの基本データ型と文字列の操作"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. int[][] matrix = {{10, 20}, {30, 40}};",
        "B. short code = (short)'X';",
        "C. byte status = 100;",
        "D. char symbol = status;",
        "E. boolean isValid = (5 > 3);",
        "F. float ratio = 1.23;",
        "G. int quantity = 5_000;",
        "H. String label = 'Z';"
      ]
    },
    "answer": {
      "en-US": [
        0,
        1,
        2,
        4,
        6
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下のJavaのステートメントのうち、構文的に正しく、コンパイルが成功するものを5つ選択してください。"
    },
    "explanation": {
      "en-US": "A: 2次元配列の正しい初期化です。B: `char`型を`short`型へ明示的にキャストするのは有効です。C: `byte`型の範囲内(-128から127)の`int`リテラルは暗黙的に`byte`へ代入可能です。D: `byte`型から`char`型への暗黙的な変換はできません（範囲が異なるためエラー）。E: 比較結果の`boolean`値を代入するのは正しいです。F: `1.23`は`double`リテラルであり、`float`型変数に代入するには明示的なキャスト`(float)`または接尾辞`F`が必要です（エラー）。G: 数値リテラル内のアンダースコアは有効です。H: `String`リテラルはダブルクォート(`\"`)で囲む必要があり、シングルクォート(`'`)は`char`リテラル用です（エラー）。 正しいのはA, B, C, E, Gです。"
    },
    "questionCategory": {
      "en-US": "データ型とリテラル、型変換"
    }
  },
  {
    "qid": {
      "en-US": "2-6"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ローカル変数型推論 (var)"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. var count;",
        "B. var name = null;",
        "C. var processor = () -> System.out.println();",
        "D. var list = {10, 20, 30};",
        "E. var map = new HashMap<String, Integer>();"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "ローカル変数型推論 `var` を使用した以下の変数宣言のうち、コンパイルエラーが発生しないものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`var` を使用するには、宣言と同時に初期化を行い、その初期化式からコンパイラが明確に変数の型を推論できる必要があります。Aは初期化がないため型推論できません。Bは `null` リテラルだけでは型が特定できません。Cはラムダ式単体では型が特定できません（代入先の関数型インターフェースが必要）。Dは配列初期化子 `{}` を `var` と直接組み合わせることはできません。Eは `new HashMap<String, Integer>()` から型 `HashMap<String, Integer>` が明確に推論できるため、コンパイル可能です。"
    },
    "questionCategory": {
      "en-US": "var型推論の制約"
    }
  },
  {
    "qid": {
      "en-US": "2-7"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ローカル変数型推論 (var)"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「Default」と表示される",
        "B. 「null」と表示される",
        "C. コンパイルエラーが発生する",
        "D. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Config.java\npublic class Config {\n  private var setting; // ① フィールド\n\n  public Config(var initialValue) { // ② コンストラクタ引数\n    this.setting = initialValue;\n  }\n  public void display() {\n    System.out.println(setting);\n  }\n}\n\n// App.java\npublic class App {\n  public static void main(String[] args) {\n    Config cfg = new Config(\"Default\");\n    cfg.display();\n  }\n}"
    },
    "questionText": {
      "en-US": "このの `Config.java` と `App.java` をコンパイル、実行しようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "ローカル変数型推論 `var` は、ローカル変数（メソッド内、forループ、try-with-resourcesなど）の宣言にのみ使用できます。クラスのフィールド（インスタンス変数やクラス変数）の宣言（①）や、メソッド・コンストラクタのパラメータ宣言（②）には使用できません。そのため、`Config.java` の①と②で `var` を使用している箇所でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "varの使用箇所の制限"
    }
  },
  {
    "qid": {
      "en-US": "2-8"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ローカル変数型推論 (var)"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. コンパイルエラーが発生する",
        "B. 「Car moves」が表示される",
        "C. 「Bike moves」が表示される",
        "D. 「Vehicle moves」が表示される",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// Vehicle.java\npublic class Vehicle {\n  public void move() { System.out.println(\"Vehicle moves\"); }\n}\n// Car.java\npublic class Car extends Vehicle {\n  @Override public void move() { System.out.println(\"Car moves\"); }\n}\n// Bike.java\npublic class Bike extends Vehicle {\n  @Override public void move() { System.out.println(\"Bike moves\"); }\n}\n\n// TransportTest.java\npublic class TransportTest {\n  public static void main(String[] args) {\n    var transport = new Car(); // ① 型推論\n    transport = new Bike();    // ② 再代入\n    transport.move();          // ③ メソッド呼び出し\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラム群（Vehicle, Car, Bike, TransportTest）をコンパイル、実行しようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "①の `var transport = new Car();` によって、変数 `transport` の型は `Car` として推論されます。`var` で推論された型は固定され、後から変更することはできません。②の `transport = new Bike();` では、`Car` 型の変数に、`Car` とは（直接の継承関係がない）`Bike` 型のインスタンスを代入しようとしています。`Car` と `Bike` は共通の親クラス `Vehicle` を持ちますが、`Car` 変数に `Bike` インスタンスは代入できないため、②の行でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "varで推論された型と再代入"
    }
  },
  {
    "qid": {
      "en-US": "2-9"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. String str1 = new String(\"data\");",
        "B. String str2 = \"data\";",
        "C. String str3 = String.create(\"data\");",
        "D. String str4 = String.parse('d', 'a', 't', 'a');"
      ]
    },
    "answer": {
      "en-US": [
        0,
        1
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaで `String` オブジェクトを生成するコードとして、正しいものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaで `String` オブジェクトを生成する主な方法は2つあります。1つは `new` 演算子と `String` コンストラクタを使用する方法(A)。もう1つは文字列リテラル（ダブルクォートで囲まれた文字列）を直接代入する方法(B)。これは内部的に文字列プールを利用することがあります。選択肢Cの `create` メソッドやDの `parse` メソッドは `String` クラスには存在しません。"
    },
    "questionCategory": {
      "en-US": "Stringオブジェクトのインスタンス化"
    }
  },
  {
    "qid": {
      "en-US": "2-10"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「Original text」と表示される",
        "B. 「Modified text」と表示される",
        "C. 「Modified」と表示される",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class StringUpdateTest {\n public static void main(String[] args) {\n  String message = \"Original text\";\n  modifyString(message);\n  System.out.println(message);\n }\n private static void modifyString(String text) {\n  text.replaceAll(\"Original\", \"Modified\"); // ① 戻り値は未使用\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String` オブジェクトは不変 (immutable) です。これは、一度作成された `String` オブジェクトの内容（文字列）は変更できないことを意味します。`replaceAll` のような `String` クラスのメソッドは、元のオブジェクトを変更するのではなく、変更結果を持つ *新しい* `String` オブジェクトを返します。①の行では、新しい文字列が生成されますが、その結果は変数 `text` に再代入されていないため、`modifyString` メソッド内の `text` (および呼び出し元の `message`) が参照するオブジェクトは元の \"Original text\" のままです。したがって、`main` メソッドの `System.out.println` では元の文字列が表示されます。"
    },
    "questionCategory": {
      "en-US": "Stringの不変性（Immutability）"
    }
  },
  {
    "qid": {
      "en-US": "2-11"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 'l' が表示される",
        "B. 'e' が表示される",
        "C. 何も表示されない",
        "D. 実行時に `StringIndexOutOfBoundsException` がスローされる",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class CharAccess {\n public static void main(String[] args) {\n  String word = \"apple\";\n  System.out.println(word.charAt(5)); // インデックス5の文字を取得\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行した場合の結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String.charAt(int index)` メソッドは、指定されたインデックスにある文字を返します。Javaの文字列インデックスは0から始まります。文字列 `word` (\"apple\") の長さは5です。したがって、有効なインデックスの範囲は 0 から 4 まで (`'a'`が0, `'p'`が1, `'p'`が2, `'l'`が3, `'e'`が4) です。4行目で `word.charAt(5)` を呼び出していますが、インデックス 5 は有効範囲外です。そのため、プログラムは実行時に `StringIndexOutOfBoundsException` をスローします。"
    },
    "questionCategory": {
      "en-US": "String.charAt() とインデックス範囲"
    }
  },
  {
    "qid": {
      "en-US": "2-12"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 2 が表示される",
        "B. 3 が表示される",
        "C. 4 が表示される",
        "D. -1 が表示される",
        "E. コンパイルエラーが発生する",
        "F. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class FindSubstring {\n public static void main(String[] args) {\n  String text = \"programming\";\n  System.out.println(text.indexOf(\"gram\"));\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String.indexOf(String str)` メソッドは、呼び出し元の文字列内で、引数として指定された部分文字列 `str` が最初に出現する位置のインデックスを返します。インデックスは0から数えます。文字列 `text` (\"programming\") の中で、部分文字列 \"gram\" はインデックス 4 (`'g'`) から始まります。したがって、`text.indexOf(\"gram\")` は `4` を返します。"
    },
    "questionCategory": {
      "en-US": "String.indexOf() の動作"
    }
  },
  {
    "qid": {
      "en-US": "2-13"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「CDE」と表示される",
        "B. 「BCDE」と表示される",
        "C. 「CD」と表示される",
        "D. 「DEF」と表示される",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class ExtractPart {\n public static void main(String[] args) {\n  String code = \"ABCDEFG\";\n  System.out.println(code.substring(2, 5));\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String.substring(int beginIndex, int endIndex)` メソッドは、`beginIndex` から始まり `endIndex - 1` までの部分文字列を抽出した新しい文字列を返します。元の文字列 `code` は \"ABCDEFG\" です。インデックスは0から始まります (`A`が0, `B`が1, `C`が2, ...)。`code.substring(2, 5)` は、インデックス 2 (`'C'`) からインデックス 5 (`'F'`) の *手前* まで、つまりインデックス 2, 3, 4 の文字 (`'C'`, `'D'`, `'E'`) を抽出します。したがって、\"CDE\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "String.substring() の動作"
    }
  },
  {
    "qid": {
      "en-US": "2-14"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「zyyyz」と表示される",
        "B. 「zxyyyzx」と表示される",
        "C. 「zxyyyz」と表示される",
        "D. 「zyyyzx」と表示される",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class ReplaceChars {\n public static void main(String[] args) {\n  String pattern = \"xxxyyyxxx\";\n  System.out.println(pattern.replace(\"xx\", \"z\"));\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String.replace(CharSequence target, CharSequence replacement)` メソッドは、文字列内で `target` に一致するすべての部分を `replacement` で置き換えた *新しい* 文字列を返します。元の文字列 `pattern` は \"xxxyyyxxx\" です。`replace(\"xx\", \"z\")` を実行すると、まず先頭の \"xx\" が \"z\" に置き換えられ、中間結果は \"zxyyyxxx\" となります。次に、残りの部分で \"xx\" を探し、末尾の \"xx\" が \"z\" に置き換えられ、最終結果 \"zxyyyzx\" が得られます。この結果が表示されます。"
    },
    "questionCategory": {
      "en-US": "String.replace() の動作"
    }
  },
  {
    "qid": {
      "en-US": "2-15"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 'a' が表示される",
        "B. 'j' が表示される",
        "C. コンパイルエラーが発生する",
        "D. 何も表示されない",
        "E. 実行時に `StringIndexOutOfBoundsException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": "public class LastCharTest {\n public static void main(String[] args) {\n  String data = \"java\";\n  System.out.println(data.charAt(data.length()));\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`data.length()` は文字列 `data` (\"java\") の長さ、つまり `4` を返します。`data.charAt(index)` は指定された `index` の文字を返しますが、有効なインデックスは 0 から `length() - 1` までです。この場合、有効なインデックスは 0, 1, 2, 3 です。`data.charAt(data.length())` は `data.charAt(4)` と評価されますが、インデックス 4 は有効範囲外です。そのため、実行時に `StringIndexOutOfBoundsException` がスローされます。"
    },
    "questionCategory": {
      "en-US": "String.length() と charAt() の組み合わせ"
    }
  },
  {
    "qid": {
      "en-US": "2-16"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「true」と表示される",
        "B. 「false」と表示される",
        "C. 「cde」と表示される",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class ChainCheck {\n public static void main(String[] args) {\n  String value = \"abcdefg\";\n  System.out.println(value.substring(2, 5).startsWith(\"c\"));\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッド呼び出しは左から右へ順に評価されます。まず `value.substring(2, 5)` が実行されます。これは文字列 `value` (\"abcdefg\") のインデックス 2 から 5 の手前まで、つまり \"cde\" を抽出します。次に、その結果である \"cde\" に対して `.startsWith(\"c\")` メソッドが呼び出されます。文字列 \"cde\" は \"c\" で始まるため、このメソッドは `true` を返します。最終的に `true` がコンソールに出力されます。"
    },
    "questionCategory": {
      "en-US": "メソッドチェーン (substring, startsWith)"
    }
  },
  {
    "qid": {
      "en-US": "2-17"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. greeting.append(\"World!\");",
        "B. greeting = greeting.concat(\"World!\");",
        "C. greeting.concat(\"World!\");",
        "D. greeting += \"World!\";",
        "E. greeting.add(\"World!\");"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "1. public class StringConcatDemo {\n2.  public static void main(String[] arg\n      s) {\n3.   String greeting = \"Hi, \";\n4.   ___________ // ← ここにコードが入る\n5.   System.out.println(greeting);\n6.  }\n7. }"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、コンソールに「Hi, World!」と表示させたいです。4行目の空欄に入れるべきコードとして、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String` オブジェクトは不変であるため、`concat()` や `+` 演算子で文字列を連結した場合、新しい `String` オブジェクトが生成されます。元の変数 `greeting` の内容を変更するには、連結結果を `greeting` に再代入する必要があります。選択肢Bの `greeting = greeting.concat(\"World!\");` は `concat` メソッドで連結した結果を再代入しているため正しいです。選択肢Dの `greeting += \"World!\";` も同様に正しい文字列連結と再代入の糖衣構文です。選択肢Cは `concat` を呼び出していますが結果を再代入していないため、`greeting` の内容は変わりません。選択肢AとEのメソッドは `String` クラスには存在しません（`append` は `StringBuilder` など）。ここでは `concat` を使ったBがより直接的な答えとなります。"
    },
    "questionCategory": {
      "en-US": "文字列連結と String.concat()"
    }
  },
  {
    "qid": {
      "en-US": "2-18"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 5 が表示される",
        "B. 16 が表示される",
        "C. 21 が表示される",
        "D. 0 が表示される"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class BuilderCapacity {\n public static void main(String[] args) {\n  StringBuilder buffer = new StringBuilder(\"hello\");\n  System.out.println(buffer.capacity());\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`StringBuilder(String str)` コンストラクタを使用した場合、`StringBuilder` の初期容量 (capacity) は、引数として渡された文字列の長さ (`str.length()`) にデフォルトの予備容量 (通常は16) を加えた値になります。文字列 \"hello\" の長さは 5 です。したがって、初期容量は `5 + 16 = 21` となります。`capacity()` メソッドはこの内部バッファのサイズを返します。"
    },
    "questionCategory": {
      "en-US": "StringBuilder の capacity()"
    }
  },
  {
    "qid": {
      "en-US": "2-19"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 「jscripta」と表示される",
        "B. 「ascriptj」と表示される",
        "C. 「aj」と表示される",
        "D. 「javascr」と表示される",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class BuilderManipulation {\n public static void main(String[] args) {\n  StringBuilder work = new StringBuilder();\n  work.append(\"java\"); // \"java\"\n  work.reverse();       // \"avaj\"\n  work.replace(1, 3, \"script\"); // インデックス1から3の手前(\"va\")を置換\n  System.out.println(work);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`StringBuilder` は可変な文字列です。各メソッドは `StringBuilder` オブジェクト自体を変更します。\n1. `work.append(\"java\")`: `work` は \"java\" になります。\n2. `work.reverse()`: `work` は \"avaj\" になります。\n3. `work.replace(1, 3, \"script\")`: インデックス 1 (`'v'`) から 3 (`'j'`) の手前まで、つまり \"va\" の部分を \"script\" で置き換えます。結果として `work` は \"ascriptj\" になります。\n最終的に \"ascriptj\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "StringBuilder の操作 (append, reverse, replace)"
    }
  },
  {
    "qid": {
      "en-US": "2-20"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 4 が表示される",
        "B. 5 が表示される",
        "C. -1 が表示される",
        "D. 0 が表示される"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class BuilderSearch {\n public static void main(String[] args) {\n  StringBuilder data = new StringBuilder(\"filesystem\");\n  System.out.println(data.indexOf(\"system\"));\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`StringBuilder` クラスにも `indexOf(String str)` メソッドがあります。これは `String` クラスの同名メソッドと同様に、引数で指定された部分文字列 `str` が `StringBuilder` 内で最初に出現する位置のインデックスを返します。見つからない場合は -1 を返します。`data` (\"filesystem\") の中で、\"system\" はインデックス 4 から始まります。したがって、4 が表示されます。"
    },
    "questionCategory": {
      "en-US": "StringBuilder の indexOf()"
    }
  },
  {
    "qid": {
      "en-US": "2-21"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 三重のダブルクォーテーション (`\"\"\"`) を使用してリテラルを開始し、終了する。",
        "B. 複数行にわたる文字列を、文字列連結演算子 (`+`) を使わずに記述できる。",
        "C. 文字列内にダブルクォーテーション (`\"`) を含める場合、エスケープシーケンス (`\\\"`) が不要になることが多い。",
        "D. ソースコード上の改行は無視され、改行を含めるには常に `\\n` を使用する必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java 15 で導入されたテキストブロックに関する説明として、 *誤っている* ものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "テキストブロックは、複数行の文字列リテラルを記述しやすくするための機能です。A, B, C はテキストブロックの正しい特徴です。特にCは、テキストブロック内では `\\\"` をそのまま記述できる場合が多い利点を示しています。Dは誤りです。テキストブロック内の改行は、基本的にソースコード上の見たままの改行が文字列内の改行 (`\\n`) として扱われます。明示的に `\\n` を使う必要は通常ありません（ただし、行末に `\\` を置くことで改行を抑制することは可能です）。"
    },
    "questionCategory": {
      "en-US": "テキストブロック (Text Blocks) の特徴"
    }
  },
  {
    "qid": {
      "en-US": "2-22"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. Aのコード",
        "B. Bのコード",
        "C. Cのコード",
        "D. Dのコード"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "A.\nString html = \"\"\"\n <html>\n  <body>Text</body>\n </html>\"\"\";\n\nB.\nString json = \"\"\"{ \"key\": \"value\" }\"\"\"\n  ;\n\nC.\nString query = \"\"\"SELECT * FROM users;\"\"\";\n\nD.\nString poem = \"\"\"\n Roses are red,\n Violets are blue.\"\"\"\n;"
    },
    "questionText": {
      "en-US": "以下のJavaコードのうち、テキストブロックの構文として正しく、コンパイルできるものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "テキストブロックは、開始の三重引用符 `\"\"\"` の直後に改行が必要です。また、終了の三重引用符 `\"\"\"` は自身の行にあるか、内容の最後の行の末尾に置くことができます。Aは開始符の後に改行があり、正しい形式です。BとCは開始符 `\"\"\"` の直後に改行がないため構文エラーです。Dは終了符が内容と同じ行にありますが、その前にスペースがないためインデント処理で問題が生じる可能性があります（仕様上は可能だが一般的でない）。最も明確に正しいのはAです。"
    },
    "questionCategory": {
      "en-US": "テキストブロックの基本構文"
    }
  },
  {
    "qid": {
      "en-US": "2-24"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"true, true\" と表示される",
        "B. \"false, false\" と表示される",
        "C. \"true, false\" と表示される",
        "D. \"false, true\" と表示される"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "1. public class EqualityTest {\n2.  public static void main(String[] arg\n      s) {\n3.   String s1 = \"test\"; // プール\n4.   String s2 = new String(s1); // ヒ\n         ープ\n5.   boolean check1 = (s1 == s2);\n6.   boolean check2 = s1.equals(s2);\n7.   System.out.println(check1 + \", \" \n      + check2);\n8.  }\n9. }"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "文字列リテラルで生成された `s1` は通常、文字列プールに格納されます。`new String(s1)` で生成された `s2` は、`s1` と同じ内容を持ちますが、ヒープメモリ上に新しいオブジェクトとして作成されます。`==` 演算子は、二つの参照が同じオブジェクトを指しているか（メモリ上のアドレスが同じか）を比較します。`s1` と `s2` は異なるオブジェクトなので `s1 == s2` は `false` です。`equals()` メソッドは、文字列の内容が等しいかを比較します。`s1` と `s2` はどちらも \"test\" という内容なので `s1.equals(s2)` は `true` です。したがって、\"false, true\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "Stringの比較 (== と equals)"
    }
  },
  {
    "qid": {
      "en-US": "2-25"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"true and true\" と表示される",
        "B. \"false and false\" と表示される",
        "C. \"true and false\" と表示される",
        "D. \"false and true\" と表示される"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "1. public class EqualityTest2 {\n2.  public static void main(String[] arg\n      s) {\n3.   String strA = new String(\"data\"); \n      // ヒープ\n4.   String strB = \"data\"; // プール\n5.   boolean resultA = (strA == strB);\n6.   boolean resultB = strA.equals(strB\n      );\n7.   System.out.println(resultA + \" and\n       \" + resultB);\n8.  }\n9. }"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`strA` は `new` を使ってヒープ上に生成されたオブジェクトです。`strB` は文字列リテラルであり、文字列プール内のオブジェクトを参照します。これらは異なるオブジェクトなので、`==` で比較する `resultA` は `false` になります。`equals()` メソッドは内容を比較し、どちらも \"data\" なので `resultB` は `true` になります。したがって、\"false and true\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "Stringの比較 (== と equals, 逆順)"
    }
  },
  {
    "qid": {
      "en-US": "2-26"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 0 が表示される",
        "B. 1 が表示される",
        "C. 2 が表示される",
        "D. 3 が表示される"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "1. public class StringPoolDemo {\n2.  public static void main(String[] arg\n      s) {\n3.   String val1 = \"xyz\"; // プール\n4.   String val2 = new String(\"xyz\"); \n      // ヒープ\n5.   String val3 = val2.intern(); // プ\n         ールの \"xyz\" を参照\n6.\n7.   int matchCount = 0;\n8.   if (val1 == val2) { matchCount++; \n      }\n9.   if (val2 == val3) { matchCount++; \n      }\n10.  if (val1 == val3) { matchCount++; \n      }\n11.  System.out.println(matchCount);\n12. }\n13.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`val1` は文字列プールの \"xyz\" を参照します。`val2` はヒープ上に新しく作られた \"xyz\" オブジェクトを参照します。`val2.intern()` は、`val2` と同じ内容の文字列がプールにあればその参照を返し、なければ `val2` をプールに追加してその参照を返します。この場合、プールには既に `val1` が参照する \"xyz\" があるため、`val3` は `val1` と同じプール内のオブジェクトを参照します。\n- `val1 == val2`: `false` (プール vs ヒープ)\n- `val2 == val3`: `false` (ヒープ vs プール)\n- `val1 == val3`: `true` (どちらもプールの同じオブジェクト)\nしたがって、`matchCount` は1回だけインクリメントされ、最終的に `1` が表示されます。"
    },
    "questionCategory": {
      "en-US": "String.intern() と参照比較"
    }
  },
  {
    "qid": {
      "en-US": "2-27"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 0.0",
        "B. null",
        "C. [D@ followed by a hexadecimal number (例: [D@1a2b3c4d)",
        "D. [0.0, 0.0, 0.0, 0.0, 0.0]",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "1. public class ArrayToString {\n2.  public static void main(String[] arg\n      s) {\n3.   double[] dataPoints = new double[5\n      ];\n4.   System.out.println(dataPoints);\n5.  }\n6. }"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したとき、コンソールに表示される可能性のある出力形式として最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaで配列オブジェクトを直接 `System.out.println()` などで表示しようとすると、その配列の内容ではなく、配列オブジェクト自体の `toString()` メソッドが呼び出されます。配列のデフォルトの `toString()` 実装は、配列の型を示す内部的な文字（`[D` は `double` 配列を表す）と `@` 記号、そしてオブジェクトのハッシュコードを16進数で表現したものを組み合わせた文字列を返します。例えば `[D@1a2b3c4d` のような形式になります。配列の内容を表示したい場合は `Arrays.toString()` メソッドなどを使う必要があります。"
    },
    "questionCategory": {
      "en-US": "配列オブジェクトの文字列表現"
    }
  },
  {
    "qid": {
      "en-US": "2-28"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 3行目と5行目の宣言スタイルは非推奨である。",
        "B. 6行目の宣言 `int[] points[];` はコンパイルエラーとなる。",
        "C. 4行目、7行目のスタイルのみが有効である。",
        "D. 3行目から7行目までのすべての配列宣言は構文的に正しい。",
        "E. 5行目、6行目、7行目はすべて異なる次元数の配列を宣言している。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "1. public class SyntaxCheck {\n2.  public static void main(String[] arg\n      s) {\n3.   String names[]; // スタイル1\n4.   String[] codes; // スタイル2\n5.   int values[][]; // 2D スタイル1\n6.   int[] points[]; // 2D スタイル2\n7.   int[][] coords; // 2D スタイル3\n8.  }\n9. }"
    },
    "questionText": {
      "en-US": "こののJavaプログラムにおける配列宣言の構文に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaでは配列を宣言する際に、角括弧 `[]` を型名の後（例: `String[] codes`）に置く方法と、変数名の後（例: `String names[]`）に置く方法の両方が許可されています。多次元配列の場合も同様に、角括弧を組み合わせる複数の有効な書き方があります（例: `int[][] coords`, `int[] points[]`, `int values[][]`）。コード中の3行目から7行目までのすべての宣言は、Javaの構文規則に従っており、コンパイルエラーにはなりません。ただし、一般的には型名の後に角括弧を置くスタイル（4行目、7行目）が推奨されます。5, 6, 7行目はすべて2次元配列を宣言しています。"
    },
    "questionCategory": {
      "en-US": "配列宣言の構文バリエーション"
    }
  },
  {
    "qid": {
      "en-US": "2-29"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `int scores[];`",
        "B. `String[] names;`",
        "C. `double[10] data;`",
        "D. `char[][] board;`",
        "E. `boolean flags[];`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下のJavaの配列変数の宣言のうち、構文的に *誤っており* コンパイルエラーとなるものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaで配列変数を宣言する際には、型と変数名、そして角括弧 `[]` を記述しますが、この宣言の段階で角括弧の中に配列のサイズ（要素数）を指定することはできません。配列のサイズは、`new` 演算子を使って実際に配列オブジェクトを生成（インスタンス化）する際に指定します。選択肢Cの `double[10] data;` は、宣言時にサイズ `10` を指定しているため、構文エラーとなりコンパイルできません。他の選択肢 A, B, D, E は有効な配列宣言です。"
    },
    "questionCategory": {
      "en-US": "配列宣言時のサイズ指定不可"
    }
  },
  {
    "qid": {
      "en-US": "2-30"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `int[][] matrixA = new int[3][4];`",
        "B. `int matrixB[][] = new int[5][];`",
        "C. `int[][] matrixC = new int[][6];`",
        "D. `int x=3; int[][] matrixD = new int[x][]; matrixD[0] = new int[x];`",
        "E. `int[][] matrixE = new int[][]{{1},{2,3}};`",
        "F. `int[][] matrixF = new int[2]{{0,0},{0,0}};`"
      ]
    },
    "answer": {
      "en-US": [
        2,
        5
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下の多次元配列のインスタンス化（生成）を行うコードのうち、コンパイルエラーとなるものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "A: 正しい2次元配列の生成。B: 正しいジャグ配列（不ぞろいな配列）の生成（第1次元のサイズのみ指定）。C: 多次元配列を生成する際、最初の次元（左端）のサイズは必ず指定する必要があります。第1次元のサイズを指定せずに後続の次元のサイズを指定することはできないため、エラーです。D: 正しいジャグ配列の生成と、その要素（1次元配列）の生成。E: 配列初期化子を使った正しい2次元配列の生成。F: `new int[2]` の後に初期化子 `{...}` を続けることはできません。`new int[2][] {{0,0},{0,0}}` または `new int[][]{{0,0},{0,0}}` のようにする必要があります。したがって、エラーとなるのは C と F です。"
    },
    "questionCategory": {
      "en-US": "多次元配列のインスタンス化ルール"
    }
  },
  {
    "qid": {
      "en-US": "2-31"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 0.0 が表示される",
        "B. 200.0 が表示される",
        "C. コンパイルエラーが発生する",
        "D. 実行時に `NullPointerException` がスローされる",
        "E. 実行時に `ArrayIndexOutOfBoundsException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "// Product.java (仮定)\n// class Product {\n//  String name;\n//  double price = 50.0;\n// }\n\npublic class InventoryCheck {\n public static void main(String[] args) {\n  Product[] stock = new Product[4];\n  double totalValue = 0.0;\n  for (int i = 0; i < stock.length; i++\n  ) {\n   totalValue += stock[i].price; // ① ぬるぽ注意\n  }\n  System.out.println(totalValue);\n }\n}"
    },
    "questionText": {
      "en-US": "このの `InventoryCheck` プログラムを（`Product` クラスが別途定義されていると仮定して）コンパイルし、実行した場合の結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`new Product[4]` によって `Product` 型の配列が生成されますが、これは要素数4の配列オブジェクトが作られるだけで、各要素（`stock[0]` から `stock[3]`）にはまだ `Product` オブジェクトは格納されていません。オブジェクト型の配列要素のデフォルト初期値は `null` です。forループの最初の反復で `i` が 0 のとき、`stock[0]` は `null` です。①の行で `stock[i].price`（つまり `null.price`）を実行しようとすると、`null` 参照に対してフィールドやメソッドにアクセスしようとしたことになり、実行時に `NullPointerException` がスローされます。"
    },
    "questionCategory": {
      "en-US": "オブジェクト配列の初期値とNullPointerException"
    }
  },
  {
    "qid": {
      "en-US": "2-32"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"10 20 40 \" と表示される",
        "B. \"10 20 null 40 \" と表示される",
        "C. \"10 20 0 40 \" と表示される",
        "D. 実行時に `NullPointerException` がスローされる",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "1. public class ForEachNull {\n2.  public static void main(String[] arg\n      s) {\n3.   Integer[] numbers = {10, 20, 30, 4\n      0};\n4.   numbers[2] = null; // インデックス2\n         の要素をnullに\n5.   for (Integer num : numbers) {\n6.    System.out.print(num + \" \");\n7.   }\n8.  }\n9. }"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "まず、`Integer` 配列 `numbers` が `{10, 20, 30, 40}` で初期化されます。次に、`numbers[2] = null;` によって、配列の内容は `{10, 20, null, 40}` に変更されます。拡張forループは配列の各要素を順番に取り出します。`System.out.print(num + \" \");` では、`num` が `null` の場合でも `print` メソッドはエラーを起こさず、文字列 \"null\" を出力します。したがって、出力は \"10 20 null 40 \" となります。"
    },
    "questionCategory": {
      "en-US": "拡張for文と配列要素の変更 (null)"
    }
  },
  {
    "qid": {
      "en-US": "2-33"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `char[][] gridA = new char[5][5];`",
        "B. `char gridB[][] = {{'X'},{'O','X'}};",
        "C. `char[][] gridC = new char[3][]; gridC[0] = new char[1];`",
        "D. `char[] gridD[] = new char[][];`",
        "E. `char[][] gridE; gridE = {{'*'},{'*','*'}};`",
        "F. `char[] row = {'a','b'}; char[][] gridF = {row, row};`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        1,
        2,
        5
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下の多次元配列に関するコードのうち、コンパイルエラーに *ならない* ものを4つ選択してください。"
    },
    "explanation": {
      "en-US": "A: 正しい2次元配列の生成。B: 宣言と初期化子による正しい生成。C: ジャグ配列の生成と要素配列の生成として正しい。D: `new char[][]` のように、初期化子なしでインスタンス化する場合、少なくとも第1次元のサイズ指定が必要です（エラー）。E: 宣言後に配列初期化子 `{...}` だけで代入することはできません。`new char[][]{{'*'},{'*','*'}}` のようにする必要があります（エラー）。F: 既存の1次元配列を使って2次元配列を初期化するのは正しいです。したがって、コンパイルエラーにならないのは A, B, C, F です。"
    },
    "questionCategory": {
      "en-US": "多次元配列の宣言・初期化の正誤"
    }
  },
  {
    "qid": {
      "en-US": "2-34"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 0 が表示される",
        "B. 5 が表示される",
        "C. コンパイルエラーが発生する",
        "D. 実行時に `NullPointerException` がスローされる",
        "E. 実行時に `ArrayIndexOutOfBoundsException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "1. public class NullArrayElement {\n2.  public static void main(String[] arg\n      s) {\n3.   int[][] data = {{1, 2}, null, {3,\n       4, 5}};\n4.   int sum = 0;\n5.   for (int[] row : data) {\n6.    sum += row.length; // ① 要素がnull\n         の場合に注意\n7.   }\n8.   System.out.println(sum);\n9.  }\n10.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行した場合の結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "配列 `data` はジャグ配列（不ぞろいな配列）で、2番目の要素 (`data[1]`) が `null` です。拡張forループが実行され、変数 `row` が配列 `data` の要素を順に参照します。ループの2回目の反復で、`row` は `null` を参照します。①の行で `row.length`（つまり `null.length`）にアクセスしようとすると、`null` 参照に対する操作となるため、実行時に `NullPointerException` がスローされます。"
    },
    "questionCategory": {
      "en-US": "ジャグ配列とNullPointerException"
    }
  },
  {
    "qid": {
      "en-US": "2-35"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "難"
    },
    "choices": {
      "en-US": [
        "A. `Animal[]`",
        "B. `Mammal[]`",
        "C. `Dog[]`",
        "D. `Poodle[]`",
        "E. `Object[]`"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "// 関係: interface Animal <- class Mammal <- class Dog <- class Poodle\ninterface Animal {}\nclass Mammal implements Animal {}\nclass Dog extends Mammal {}\nclass Poodle extends Dog {}\n\npublic class TypeCompatibility {\n  public static void main(String[] args) {\n    _________ animals = {new Dog(), null, new Poodle()}; // ← 空欄\n    Object[] objects = animals;\n  }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムの空欄に以下のいずれかを記述した場合、コンパイルエラーが *発生するもの* を1つ選択してください。"
    },
    "explanation": {
      "en-US": "配列初期化子 `{new Dog(), null, new Poodle()}` の要素の型は `Dog`, `null`, `Poodle` です。配列の型は、これらの要素すべてを代入可能でなければなりません。\n- `Animal[]`: `Dog`も`Poodle`も`Animal`なのでOK。\n- `Mammal[]`: `Dog`も`Poodle`も`Mammal`なのでOK。\n- `Dog[]`: `Dog`はOK、`Poodle`は`Dog`のサブクラスなのでOK。\n- `Poodle[]`: `Dog`は`Poodle`のスーパータイプなので、`Poodle[]` に `Dog` インスタンスは代入できず、コンパイルエラー。\n- `Object[]`: すべてのクラスは`Object`のサブクラスなのでOK。\n空欄に `Poodle[]` を入れると、`new Dog()` の代入でコンパイルエラーが発生します。4行目の `Object[] objects = animals;` は配列の共変性により、空欄がどの配列型であってもコンパイルは通ります。"
    },
    "questionCategory": {
      "en-US": "配列の共変性と型適合性"
    }
  },
  {
    "qid": {
      "en-US": "2-36"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 10 が表示される",
        "B. 99 が表示される",
        "C. コンパイルエラーが発生する",
        "D. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "1. public class CloneTest {\n2.  public static void main(String[] arg\n      s) {\n3.   int[][] matrix1 = {{10, 20}, {30, \n      40, 50}};\n4.   int[][] matrix2 = matrix1.clone();\n       // シャローコピー\n5.   matrix1[0][0] = 99; // 元の配列の要\n         素を変更\n6.\n7.   int element = matrix2[0][0]; // コ\n         ピー後の配列から要素取得\n8.   System.out.println(element);\n9.  }\n10.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "配列の `clone()` メソッドはシャローコピー（浅いコピー）を行います。多次元配列の場合、最も外側の配列オブジェクトは新しく作成されますが、その要素（内側の配列オブジェクト）は元の配列と同じものを参照します。つまり、`matrix1` と `matrix2` は異なる2次元配列オブジェクトですが、`matrix1[0]` と `matrix2[0]` は同じ1次元配列 `{10, 20}` を参照し、`matrix1[1]` と `matrix2[1]` は同じ1次元配列 `{30, 40, 50}` を参照します。そのため、`matrix1[0][0] = 99;` によって参照先の1次元配列の内容が変更されると、`matrix2[0][0]` もその変更の影響を受けます。したがって、`matrix2[0][0]` の値は `99` となり、それが表示されます。"
    },
    "questionCategory": {
      "en-US": "配列の clone() とシャローコピー"
    }
  },
  {
    "qid": {
      "en-US": "2-37"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 格納できる要素の型はプリミティブ型のみである。",
        "B. 要素の追加や削除によって、リストのサイズが動的に変化する。",
        "C. 同じ要素を複数格納することができない（重複を許さない）。",
        "D. デフォルトではスレッドセーフ（複数スレッドから同時に安全にアクセス可能）である。",
        "E. インデックスを指定して要素を取得、追加、削除、置換することができる。",
        "F. 要素として `null` 値を格納することは許可されていない。"
      ]
    },
    "answer": {
      "en-US": [
        1,
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java の `java.util.ArrayList` クラスに関する説明として、正しいものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "A: `ArrayList` はオブジェクト型を格納します（プリミティブ型はラッパークラス経由で格納）。誤り。B: `ArrayList` は内部的に配列を使用しますが、必要に応じてサイズが自動的に拡張・縮小される可変長のリストです。正しい。C: `ArrayList` は要素の重複を許容します（Setとは異なります）。誤り。D: `ArrayList` はスレッドセーフではありません。複数スレッドからの同時アクセスには外部での同期が必要です。誤り。E: `get(index)`, `add(index, element)`, `remove(index)`, `set(index, element)` など、インデックスに基づいた操作が可能です。正しい。F: `ArrayList` は `null` 値を要素として格納できます。誤り。 正しいのはBとEです。"
    },
    "questionCategory": {
      "en-US": "ArrayList の基本的な特徴"
    }
  },
  {
    "qid": {
      "en-US": "2-38"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 7行目でコンパイルエラーが発生する",
        "B. 8行目でコンパイルエラーが発生する",
        "C. 9行目でコンパイルエラーが発生する",
        "D. 「Pen 120 true 」と表示される",
        "E. 実行時に `ClassCastException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "1. import java.util.ArrayList;\n2. import java.util.List;\n3.\n4. public class RawTypeDemo {\n5.  public static void main(String[] args) {\n6.   List items = new ArrayList(); // Raw type 使用\n7.   items.add(\"Pen\");      // String\n8.   items.add(120);        // Integer (オートボクシング)\n9.   items.add(true);       // Boolean (オートボクシング)\n10.  for (Object item : items) {\n11.   System.out.print(item + \" \");\n12.  }\n13. }\n14.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。（コンパイル時にRaw Typeに関する警告が出る可能性がありますが、エラーとは扱いません）"
    },
    "explanation": {
      "en-US": "ジェネリクスを使わずに `ArrayList` を使用する（Raw Type）と、任意の型のオブジェクトをリストに追加できます。`String` 型の \"Pen\"、`int` リテラル `120`（`Integer` にオートボクシングされる）、`boolean` リテラル `true`（`Boolean` にオートボクシングされる）はすべて `Object` のサブクラスなので問題なく追加できます。拡張forループでは、各要素が `Object` 型として取り出され、`System.out.print` でそれぞれの `toString()` 表現が出力されます。したがって、\"Pen 120 true \" が表示されます。"
    },
    "questionCategory": {
      "en-US": "Raw Type ArrayList と要素の追加"
    }
  },
  {
    "qid": {
      "en-US": "2-39"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「ACDB」と表示される",
        "B. 「ABCD」と表示される",
        "C. 「ACBD」と表示される",
        "D. コンパイルエラーが発生する",
        "E. 実行時に `IndexOutOfBoundsException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "1. import java.util.ArrayList;\n2. import java.util.List;\n3.\n4. public class InsertElement {\n5.  public static void main(String[] arg\n      s) {\n6.   List<Character> chars = new ArrayL\n      ist<>();\n7.   chars.add('A');\n8.   chars.add('C'); // list: ['A', 'C']\n9.   chars.add('D'); // list: ['A', 'C',\n       'D']\n10.  chars.add(1, 'B'); // インデックス1\n      に'B'を挿入\n11.  for (Character c : chars) {\n12.   System.out.print(c);\n13.  }\n14. }\n15.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`ArrayList` の `add(int index, E element)` メソッドは、指定された `index` の位置に要素 `element` を挿入します。挿入位置以降の既存の要素は、インデックスが1つずつ後ろにずれます。\n1. `chars.add('A');` -> `['A']`\n2. `chars.add('C');` -> `['A', 'C']`\n3. `chars.add('D');` -> `['A', 'C', 'D']`\n4. `chars.add(1, 'B');` -> インデックス 1 に `'B'` を挿入。元のインデックス 1 の `'C'` とインデックス 2 の `'D'` が後ろにずれる。結果: `['A', 'B', 'C', 'D']`\nループで各要素が出力されるため、「ABCD」が表示されます。"
    },
    "questionCategory": {
      "en-US": "ArrayList.add(index, element) による挿入"
    }
  },
  {
    "qid": {
      "en-US": "2-40"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「BlueBlackYellow」と表示される",
        "B. 「[Blue, Black, Yellow]」と表示される",
        "C. 「[Red, Black, Yellow]」と表示される",
        "D. 「[Blue, Green, Yellow]」と表示される",
        "E. コンパイルエラーが発生する",
        "F. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "1. import java.util.ArrayList;\n2. import java.util.List;\n3.\n4. public class UpdateElement {\n5.  public static void main(String[] arg\n      s) {\n6.   List<String> colors = new ArrayLis\n      t<>();\n7.   colors.add(\"Red\");    // [\"Red\"]\n8.   colors.add(\"Green\");  // [\"Red\", \"G\n      reen\"]\n9.   colors.set(0, \"Blue\"); // インデック\n      ス0を置換 [\"Blue\", \"Green\"]\n10.  colors.add(\"Yellow\"); // [\"Blue\", \n      \"Green\", \"Yellow\"]\n11.  colors.set(1, \"Black\"); // インデッ\n      クス1を置換 [\"Blue\", \"Black\", \"Yello\n      w\"]\n12.  System.out.println(colors);\n13. }\n14. }"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`ArrayList` の `set(int index, E element)` メソッドは、指定された `index` にある既存の要素を、新しい要素 `element` で置き換えます（上書きします）。\n1. `add(\"Red\")`: `[\"Red\"]`\n2. `add(\"Green\")`: `[\"Red\", \"Green\"]`\n3. `set(0, \"Blue\")`: インデックス 0 の \"Red\" を \"Blue\" で置き換え `[\"Blue\", \"Green\"]`\n4. `add(\"Yellow\")`: 末尾に追加 `[\"Blue\", \"Green\", \"Yellow\"]`\n5. `set(1, \"Black\")`: インデックス 1 の \"Green\" を \"Black\" で置き換え `[\"Blue\", \"Black\", \"Yellow\"]`\n最後に `System.out.println(colors)` を実行すると、`ArrayList` の `toString()` メソッドが呼び出され、リストの内容が `[要素1, 要素2, ...]` の形式で表示されます。したがって、「[Blue, Black, Yellow]」が表示されます。"
    },
    "questionCategory": {
      "en-US": "ArrayList.set() による要素置換"
    }
  },
  {
    "qid": {
      "en-US": "2-41"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"SQL Primer Java Guide Web Design \" と表示される",
        "B. \"SQL Primer Web Design \" と表示される",
        "C. \"Java Guide SQL Primer Java Guide Web Design \" と表示される",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// Book.java\npublic class Book {\n private String title;\n private int pages;\n public Book(String title, int pages) {\n  this.title = title; this.pages = pages;\n }\n // equals は title のみ比較\n @Override\n public boolean equals(Object obj) {\n  if (!(obj instanceof Book)) return false;\n  Book other = (Book) obj;\n  return this.title.equals(other.title);\n }\n @Override public int hashCode() { return title.hashCode(); }\n public String getTitle() { return title; }\n}\n\n// Library.java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Library {\n public static void main(String[] args) {\n  List<Book> shelf = new ArrayList<>();\n  shelf.add(new Book(\"Java Guide\", 300));\n  shelf.add(new Book(\"SQL Primer\", 150));\n  shelf.add(new Book(\"Java Guide\", 400)); // 同じタイトル\n  shelf.add(new Book(\"Web Design\", 200));\n\n  // titleが\"Java Guide\"の最初の本を削除試行\n  shelf.remove(new Book(\"Java Guide\", 999));\n\n  for (Book b : shelf) {\n   System.out.print(b.getTitle() + \" \");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Book` クラスと `Library` クラスがある場合、`Library` クラスをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`ArrayList` の `remove(Object o)` メソッドは、リスト内で引数 `o` と `equals()` メソッドで比較して `true` となる最初の要素を削除します。`Book` クラスの `equals` メソッドは `title` フィールドのみを比較するようにオーバーライドされています。リスト `shelf` には最初に `Book(\"Java Guide\", 300)` が追加されます。`shelf.remove(new Book(\"Java Guide\", 999))` が呼び出されると、リストの最初の要素 `Book(\"Java Guide\", 300)` と `new Book(\"Java Guide\", 999)` が `equals` で比較されます。`title` が同じ \"Java Guide\" なので `equals` は `true` を返し、リストの最初の要素が削除されます。リストに残るのは `[Book(\"SQL Primer\", 150), Book(\"Java Guide\", 400), Book(\"Web Design\", 200)]` です。ループでタイトルを表示すると \"SQL Primer Java Guide Web Design \" となります。"
    },
    "questionCategory": {
      "en-US": "ArrayList.remove(Object) と equals() のオーバーライド"
    }
  },
  {
    "qid": {
      "en-US": "2-42"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 「[Alice, Charlie]」と表示される",
        "B. 「[Alice]」と表示される",
        "C. コンパイルエラーが発生する",
        "D. 実行時に `ConcurrentModificationException` がスローされる",
        "E. 実行時に `NoSuchElementException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "1. import java.util.ArrayList;\n2. import java.util.List;\n3.\n4. public class ConcurrentModification {\n5.  public static void main(String[] arg\n      s) {\n6.   List<String> names = new ArrayLis\n      t<>();\n7.   names.add(\"Alice\");\n8.   names.add(\"Bob\");\n9.   names.add(\"Charlie\");\n10.  for (String name : names) {\n11.   if (\"Bob\".equals(name)) {\n12.    names.remove(name); // ループ中に\n          削除！\n13.   }\n14.  }\n15.  System.out.println(names);\n16. }\n17.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行した場合の結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "拡張 for ループは、内部的にイテレータ（Iterator）を使用してコレクションの要素を反復処理します。イテレータを使用している最中に、イテレータ自身の `remove()` メソッド *以外* の方法で元のコレクションの構造（要素数など）を変更する操作（ここでは `names.remove(name)`）を行うと、イテレータの状態とコレクションの状態に不整合が生じます。これを検出すると、Java のコレクションフレームワークは `ConcurrentModificationException` をスローして、潜在的な問題を知らせます（fail-fast）。このコードでは、`name` が \"Bob\" のときに `names.remove()` が呼び出され、その後のループ処理（またはループ終了後の処理）でこの例外が発生します。"
    },
    "questionCategory": {
      "en-US": "拡張forループ中のリスト構造変更"
    }
  },
  {
    "qid": {
      "en-US": "2-43"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Z-X-W-\" と表示される",
        "B. \"Y-Z-W-\" と表示される",
        "C. \"Z-W-\" と表示される",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "1. import java.util.ArrayList;\n2. import java.util.List;\n3.\n4. public class RemoveOverload {\n5.  public static void main(String[] args) {\n6.   List<String> letters = new ArrayList<>();\n7.   letters.add(\"X\");\n8.   letters.add(\"Y\");\n9.   letters.add(\"Z\");\n10.  letters.add(\"X\"); // 重複\n11.  letters.add(\"W\");\n12.  // list: [\"X\", \"Y\", \"Z\", \"X\", \"W\"]\n13.  letters.remove(1); // インデックス1 (\"Y\") を削除\n14.  // list: [\"X\", \"Z\", \"X\", \"W\"]\n15.  letters.remove(\"X\"); // 最初の \"X\" を削除\n16.  // list: [\"Z\", \"X\", \"W\"]\n17.  for (String s : letters) {\n18.   System.out.print(s + \"-\");\n19.  }\n20. }\n21.}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`ArrayList` には `remove(int index)` と `remove(Object o)` の2つのオーバーロードされた `remove` メソッドがあります。\n1. 初期状態: `[\"X\", \"Y\", \"Z\", \"X\", \"W\"]`\n2. `letters.remove(1)`: インデックス 1 の要素 `\"Y\"` を削除します。結果: `[\"X\", \"Z\", \"X\", \"W\"]`\n3. `letters.remove(\"X\")`: `equals()` で比較して `true` となる最初の要素 `\"X\"`（現在のインデックス 0）を削除します。結果: `[\"Z\", \"X\", \"W\"]`\n最後のループで、残った要素 `\"Z\"`, `\"X\"`, `\"W\"` がハイフン区切りで表示されるため、「Z-X-W-」となります。"
    },
    "questionCategory": {
      "en-US": "ArrayList の remove(index) と remove(Object)"
    }
  },
  {
    "qid": {
      "en-US": "2-44"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `var listA = new ArrayList<String>();`",
        "B. `var listB = List.of(\"a\", \"b\", \"c\");`",
        "C. `var listC = Arrays.asList(\"x\", \"y\", \"z\");`",
        "D. `var listD = new LinkedList<String>();`"
      ]
    },
    "answer": {
      "en-US": [
        1,
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下の選択肢のうち、生成されるリストが *変更不可能（immutable）* または *固定長（fixed-size）* であるものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "A: `new ArrayList<>()` は通常の可変長で変更可能なリストを生成します。\nB: `List.of()` ファクトリメソッドは、変更不可能な（要素の追加、削除、置換ができない）リストを生成します。サイズも固定です。\nC: `Arrays.asList()` は、引数として渡された配列をラップする *固定長* のリストビューを返します。このリストは `set()` メソッドによる要素の置換は可能ですが、要素の追加や削除はできません（`UnsupportedOperationException` がスローされる）。\nD: `new LinkedList<>()` は可変長で変更可能なリスト（リンクリスト実装）を生成します。\nしたがって、変更不可能または固定長なのは B と C です。"
    },
    "questionCategory": {
      "en-US": "固定長リストと不変リストの生成方法"
    }
  },
  {
    "qid": {
      "en-US": "2-45"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "変数の宣言および初期化と変数のスコープ"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. フィールド（インスタンス変数 `classVar`）は、クラス内のどのメソッドからでもアクセスできる。",
        "B. メソッドのパラメータ（`paramVar`）は、そのメソッド内全体で有効である。",
        "C. メソッド内で宣言されたローカル変数（`localVar`）は、宣言されたメソッド内でのみ有効である。",
        "D. if文などのブロック内で宣言された変数（`blockVar`）は、そのブロックの外からでもアクセスできる。",
        "E. あるメソッドで宣言されたローカル変数（`localVar`）は、別のメソッド（`anotherMethod`）からはアクセスできない。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class ScopeTest {\n  int classVar = 10; // フィールド (インスタンス変数)\n\n  public void checkScope(int paramVar) {\n    int localVar = 30; // ローカル変数\n    //System.out.println(anotherLocal); // コンパイルエラー\n    if (paramVar > 5) {\n      int blockVar = 40; // ブロックスコープ変数\n      System.out.println(blockVar);\n    }\n    //System.out.println(blockVar); // コンパイルエラー\n    System.out.println(localVar);\n    System.out.println(classVar);\n  }\n\n  public void anotherMethod() {\n    int anotherLocal = 50; // 別のローカル変数\n    //System.out.println(localVar); // コンパイルエラー\n    System.out.println(classVar);\n  }\n}"
    },
    "questionText": {
      "en-US": "Javaの変数のスコープに関する説明として、 *誤っている* ものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaの変数のスコープ（有効範囲）にはルールがあります。A, B, C, E は正しい説明です。Dは誤りです。`if`, `for`, `while` などのブロック (`{}`) 内で宣言されたローカル変数は、そのブロック内でのみ有効であり、ブロックの外からはアクセスできません。これをブロックスコープと呼びます。"
    },
    "questionCategory": {
      "en-US": "変数のスコープ（フィールド vs ローカル）"
    }
  },
  {
    "qid": {
      "en-US": "2-46"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "変数の宣言および初期化と変数のスコープ"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 宣言時に必ず初期化する必要がある。",
        "B. 宣言されると、自動的にデフォルト値（数値型なら0、booleanならfalse、参照型ならnull）で初期化される。",
        "C. 初期化せずに宣言だけ行い、その値を読み取ろうとするとコンパイルエラーが発生する。",
        "D. 初期化せずに使用した場合、実行時に `UninitializedVariableException` がスローされる。",
        "E. `final` を付けたローカル変数のみ、使用前に初期化されている必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class InitializationCheck {\n  public static void main(String[] args) {\n    int count; // 宣言のみ、初期化なし\n    int factor = 2;\n    if (args.length > 0) {\n      count = 10; // 条件によって初期化される\n    }\n    // int result = count * factor; // コンパイルエラーの可能性\n    // System.out.println(result);\n    // System.out.println(count); // コンパイルエラーの可能性\n  }\n}"
    },
    "questionText": {
      "en-US": "メソッド内で宣言されたローカル変数について、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaのローカル変数（メソッド内で宣言された変数）は、フィールド（インスタンス変数やクラス変数）とは異なり、自動的にデフォルト値で初期化されません。プログラマは、ローカル変数の値を *読み取る前* に、必ず何らかの値を代入して初期化する必要があります。コンパイラは、初期化されずに値が読み取られる可能性があるコードパスを検出し、コンパイルエラーを発生させます(C)。Aは必須ではありません（後で初期化も可）。Bはフィールドの場合の説明。Dのような特定の例外はありません。Eは`final`有無に関わらず初期化が必要です。"
    },
    "questionCategory": {
      "en-US": "ローカル変数の初期化要件"
    }
  },
  {
    "qid": {
      "en-US": "2-47"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ローカル変数型推論 (var)"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. ①の `intVal` の型は `Object` と推論される。",
        "B. ②の `longVal` の型は `int` と推論される。",
        "C. ③の `floatVal` の型は `double` と推論される。",
        "D. ④の `doubleVal` の型は `double` と推論される。",
        "E. `var` で宣言された変数は、後から異なる型の値を代入できる。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class VarPrimitive {\n  public void checkTypes() {\n    var intVal = 100;      // ①\n    var longVal = 100L;    // ②\n    var floatVal = 100.0F; // ③\n    var doubleVal = 100.0; // ④\n    // intVal = 100.5; // コンパイルエラー\n    // longVal = 100.0F; // コンパイルエラー\n  }\n}"
    },
    "questionText": {
      "en-US": "こののコードで `var` を使って宣言された変数に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`var` は初期化式のリテラルの型に基づいて変数の型を推論します。\n① `100` は `int` リテラルなので、`intVal` は `int` 型になります。\n② `100L` は `long` リテラルなので、`longVal` は `long` 型になります。\n③ `100.0F` は `float` リテラルなので、`floatVal` は `float` 型になります。\n④ `100.0` は `double` リテラルなので、`doubleVal` は `double` 型になります。\n`var` で一度推論された型は固定されるため、後から互換性のない型の値を代入することはできません(Eは誤り)。したがって、正しい説明はDです。"
    },
    "questionCategory": {
      "en-US": "var とプリミティブ型リテラル"
    }
  },
  {
    "qid": {
      "en-US": "2-48"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. r1=true, r2=true, r3=true, r4=true, r5=false",
        "B. r1=true, r2=false, r3=true, r4=true, r5=false",
        "C. r1=true, r2=false, r3=false, r4=true, r5=false",
        "D. r1=false, r2=false, r3=false, r4=false, r5=false",
        "E. r1=true, r2=true, r3=true, r4=false, r5=false"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "String s1 = \"\";\nString s2 = \"   \"; // 空白のみ\nString s3 = \" abc \";\n\nboolean r1 = s1.isEmpty();  // ①\nboolean r2 = s2.isEmpty();  // ②\nboolean r3 = s1.isBlank();  // ③\nboolean r4 = s2.isBlank();  // ④\nboolean r5 = s3.isBlank();  // ⑤"
    },
    "questionText": {
      "en-US": "こののコードを実行したとき、変数 `r1`, `r2`, `r3`, `r4`, `r5` の値の組み合わせとして正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String.isEmpty()` は、文字列の長さが 0 の場合にのみ `true` を返します。\n`String.isBlank()` は、文字列が空であるか、または空白文字（スペース、タブ、改行など） *のみ* で構成されている場合に `true` を返します。\n- `s1` (\"\"): 長さ0なので `isEmpty()` は `true` (r1=true)。空白のみなので `isBlank()` も `true` (r3=true)。\n- `s2` (\"   \"): 長さ3なので `isEmpty()` は `false` (r2=false)。空白のみなので `isBlank()` は `true` (r4=true)。\n- `s3` (\" abc \"): 空白以外の文字を含むので `isEmpty()` は `false`。空白以外の文字を含むので `isBlank()` も `false` (r5=false)。\nしたがって、結果は `r1=true, r2=false, r3=true, r4=true, r5=false` となります。"
    },
    "questionCategory": {
      "en-US": "String.isEmpty() と String.isBlank()"
    }
  },
  {
    "qid": {
      "en-US": "2-49"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Start:Process\" と表示される",
        "B. \"Start:Process:\" と表示される",
        "C. \"Process:End\" と表示される",
        "D. \"DEBUG:Start:Process\" と表示される",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "1. public class BuilderDelete {\n2.  public static void main(String[] arg\n      s) {\n3.   StringBuilder log = new StringBuil\n      der(\"DEBUG:Start:Process:End\");\n4.   log.delete(0, 6); // 先頭から6文字\n         削除\n5.   // 現在 log = \"Start:Process:End\"\n6.   log.delete(log.length() - 4, log.l\n      ength()); // 末尾4文字削除\n7.   System.out.println(log);\n8.  }\n9. }"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`StringBuilder.delete(int start, int end)` は、`start` インデックスから `end` インデックスの *手前* までの文字を削除します。\n1. 初期状態: `log = \"DEBUG:Start:Process:End\"`\n2. `log.delete(0, 6)`: インデックス 0 から 6 の手前まで (\"DEBUG:\") を削除。`log` は `\"Start:Process:End\"` になります。\n3. `log.delete(log.length() - 4, log.length())`: 現在の長さは 17。`log.delete(13, 17)` となり、インデックス 13 から 17 の手前まで (\":End\") を削除。`log` は `\"Start:Process\"` になります。\n最終的に \"Start:Process\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "StringBuilder.delete()"
    }
  },
  {
    "qid": {
      "en-US": "2-50"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"1,true,null\" と表示される",
        "B. \"0,false,\" と表示される（末尾は空文字）",
        "C. \"0,false,null\" と表示される",
        "D. コンパイルエラーが発生する",
        "E. 実行時に `NullPointerException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class DefaultValues {\n  static int[] intArr = new int[1];\n  static boolean[] boolArr = new boolean[1];\n  static String[] strArr = new String[1];\n\n  public static void main(String[] args) {\n    System.out.print(intArr[0]);\n    System.out.print(\",\" + boolArr[0]);\n    System.out.print(\",\" + strArr[0]);\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "配列を `new` で生成すると、その要素はデータ型に応じたデフォルト値で自動的に初期化されます。\n- 数値型（`byte`, `short`, `int`, `long`, `float`, `double`）のデフォルト値は `0`（または `0.0`）。\n- `boolean` 型のデフォルト値は `false`。\n- 参照型（クラス型、インターフェース型、配列型）のデフォルト値は `null`。\nしたがって、`intArr[0]` は `0`、`boolArr[0]` は `false`、`strArr[0]` は `null` となります。出力は \"0,false,null\" です。"
    },
    "questionCategory": {
      "en-US": "配列要素のデフォルト初期値"
    }
  },
  {
    "qid": {
      "en-US": "2-51"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 30 が表示される",
        "B. 何も表示されない",
        "C. \"Error: Index out of bounds\" と表示される",
        "D. 実行時に `NullPointerException` がスローされる",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class BoundsCheck {\n  public static void main(String[] args) {\n    int[] data = {10, 20, 30};\n    int index = 3;\n    try {\n      System.out.println(data[index]);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      System.out.println(\"Error: Index out of bounds\");\n    }\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "配列 `data` の要素数は 3 です。有効なインデックスは 0, 1, 2 です。変数 `index` の値は 3 です。`data[index]`（つまり `data[3]`）にアクセスしようとすると、配列の有効なインデックス範囲を超えているため、`ArrayIndexOutOfBoundsException` が実行時にスローされます。この例外は `try-catch` ブロックで捕捉され、`catch` ブロック内のコードが実行されて \"Error: Index out of bounds\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "配列の境界チェック (ArrayIndexOutOfBoundsException)"
    }
  },
  {
    "qid": {
      "en-US": "2-52"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"2,2\" と表示される",
        "B. \"2,3\" と表示される",
        "C. \"3,2\" と表示される",
        "D. \"3,3\" と表示される",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SizeVsLength {\n  public static void main(String[] args) {\n    String[] arr = {\"A\", \"B\"};\n    List<String> list = new ArrayList<>();\n    list.add(\"X\");\n    list.add(\"Y\");\n    list.add(\"Z\");\n\n    System.out.print(arr.length); // 配列の長さ\n    System.out.print(\",\");\n    System.out.print(list.size()); // ArrayListのサイズ\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "配列の要素数を取得するには `length` フィールドを使用します。配列 `arr` の要素数は 2 なので `arr.length` は 2 です。`ArrayList` の要素数を取得するには `size()` メソッドを使用します。リスト `list` には \"X\", \"Y\", \"Z\" の 3 つの要素が追加されているので `list.size()` は 3 です。したがって、出力は \"2,3\" となります。"
    },
    "questionCategory": {
      "en-US": "ArrayList.size() と 配列.length"
    }
  },
  {
    "qid": {
      "en-US": "2-53"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"true,true\" と表示される",
        "B. \"false,false\" と表示される",
        "C. \"true,false\" と表示される",
        "D. \"false,true\" と表示される",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListContains {\n  public static void main(String[] args) {\n    List<Integer> numbers = new ArrayList<>();\n    numbers.add(10);\n    numbers.add(20);\n    numbers.add(30);\n\n    boolean has20 = numbers.contains(20);\n    boolean has40 = numbers.contains(40);\n\n    System.out.println(has20 + \",\" + has40);\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`ArrayList` の `contains(Object o)` メソッドは、リスト内に引数 `o` と `equals()` で比較して `true` となる要素が存在するかどうかを判定します。リスト `numbers` には `10`, `20`, `30` が含まれています。\n- `numbers.contains(20)`: リスト内に `20` (Integer型) が存在するため `true` を返します (`has20 = true`)。\n- `numbers.contains(40)`: リスト内に `40` が存在しないため `false` を返します (`has40 = false`)。\nしたがって、出力は \"true,false\" となります。"
    },
    "questionCategory": {
      "en-US": "ArrayList.contains()"
    }
  },
  {
    "qid": {
      "en-US": "2-54"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"2,2,One\" と表示される",
        "B. \"0,2,One\" と表示される",
        "C. \"2,2,Two\" と表示される",
        "D. コンパイルエラーが発生する",
        "E. 実行時に `ArrayStoreException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Arrays;\n\npublic class ListToArray {\n  public static void main(String[] args) {\n    List<String> list = new ArrayList<>();\n    list.add(\"One\");\n    list.add(\"Two\");\n\n    // Object[] arr1 = list.toArray(); // Object配列になる\n    String[] arr2 = list.toArray(new String[0]); // 型指定\n    String[] arr3 = list.toArray(new String[list.size()]); // サイズ指定\n    String[] arr4 = list.toArray(String[]::new); // Java11以降\n\n    System.out.print(arr2.length + \",\");\n    System.out.print(arr3.length + \",\");\n    System.out.print(arr4[0]);\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`ArrayList` の `toArray(T[] a)` メソッド（またはJava 11以降の `toArray(IntFunction<T[]> generator)`）は、リストの要素を指定された型の配列に変換します。\n- `toArray(new String[0])`: 引数の配列サイズがリストサイズより小さい場合、リストサイズと同じサイズの新しい配列が作成されて返されます。`arr2` は要素数2の `String` 配列になります。\n- `toArray(new String[list.size()])`: 引数の配列サイズがリストサイズと同じ場合、その引数の配列に要素がコピーされて返されます。`arr3` も要素数2の `String` 配列になります。\n- `toArray(String[]::new)`: ジェネレータ関数を使い、適切なサイズの `String` 配列を生成して返します。`arr4` も要素数2の `String` 配列になります。\nすべての配列 `arr2`, `arr3`, `arr4` は `{\"One\", \"Two\"}` という内容になります。`arr2.length` は 2、`arr3.length` は 2、`arr4[0]` は \"One\" です。したがって、出力は \"2,2,One\" となります。"
    },
    "questionCategory": {
      "en-US": "ArrayList から配列への変換 (toArray)"
    }
  },
  {
    "qid": {
      "en-US": "2-55"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ローカル変数型推論 (var)"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `var nums = {1, 2, 3};` のように配列初期化子だけでは型推論できない。",
        "B. `var names[];` のように変数名の後に `[]` を付けることはできない。",
        "C. `var matrix = new int[2][2];` のように `new` を使う場合のみ `var` を配列に使える。",
        "D. `var` で宣言された配列は、要素の型がすべて `Object` と推論される。",
        "E. `var args = args;` のように `main` メソッドの引数を `var` で受け取ることはできない。"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class VarArray {\n  public void testArrays() {\n    var nums = new int[]{1, 2, 3}; // ①\n    var names = new String[]{\"A\", \"B\"}; // ②\n    // var matrix = {{1,0},{0,1}}; // ③ コンパイルエラー\n    var matrixOk = new int[][]{{1,0},{0,1}}; // ④ OK\n\n    System.out.println(nums.length); // 3\n    System.out.println(names[0]);  // A\n    System.out.println(matrixOk[1][1]); // 1\n  }\n}"
    },
    "questionText": {
      "en-US": "`var` を用いた配列の宣言について、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "A: `var` は初期化式から型を明確に推論する必要があります。配列初期化子 `{1, 2, 3}` だけでは型（`int[]`, `short[]` など）が特定できないため、`var nums = {1, 2, 3};` はコンパイルエラーになります。`new int[]{1, 2, 3}` のように `new` を使えば型が明示されるため `var` で推論可能です。これが正しい説明です。\nB: `var[] names;` や `var names[];` のような構文は許可されていません。\nC: `new int[]{...}` だけでなく `new int[size]` でも `var` は使えます。\nD: 推論される型は初期化式に基づきます（例: `new int[]` なら `int[]`）。`Object[]` になるとは限りません。\nE: `var` はローカル変数宣言に使えますが、メソッドパラメータには使えません。`main` の引数 `String[] args` はパラメータなので `var` は使えません。"
    },
    "questionCategory": {
      "en-US": "var と配列宣言"
    }
  },
  {
    "qid": {
      "en-US": "2-56"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. comp1=false, comp2=true, comp3=false, comp4=true",
        "B. comp1=false, comp2=false, comp3=false, comp4=true",
        "C. comp1=true, comp2=true, comp3=true, comp4=true",
        "D. comp1=false, comp2=true, comp3=true, comp4=true",
        "E. comp1=false, comp2=false, comp3=false, comp4=false"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "String str1 = \"Java\";\nString str2 = \"java\";\nString str3 = \"JAVA\";\n\nboolean comp1 = str1.equals(str2); // ①\nboolean comp2 = str1.equalsIgnoreCase(str2); // ②\nboolean comp3 = str1.equals(str3); // ③\nboolean comp4 = str1.equalsIgnoreCase(str3); // ④"
    },
    "questionText": {
      "en-US": "こののコードを実行したとき、変数 `comp1`, `comp2`, `comp3`, `comp4` の値として正しい組み合わせを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`String.equals()` メソッドは、大文字と小文字を区別して文字列の内容が完全に一致するかを比較します。\n`String.equalsIgnoreCase()` メソッドは、大文字と小文字を区別せずに文字列の内容が一致するかを比較します。\n- ① `str1.equals(str2)`: \"Java\" と \"java\" は大文字小文字が異なるため `false`。\n- ② `str1.equalsIgnoreCase(str2)`: 大文字小文字を無視すれば \"Java\" と \"java\" は同じなので `true`。\n- ③ `str1.equals(str3)`: \"Java\" と \"JAVA\" は大文字小文字が異なるため `false`。\n- ④ `str1.equalsIgnoreCase(str3)`: 大文字小文字を無視すれば \"Java\" と \"JAVA\" は同じなので `true`。\nしたがって、`comp1=false, comp2=true, comp3=false, comp4=true` となります。"
    },
    "questionCategory": {
      "en-US": "String.equals() と equalsIgnoreCase()"
    }
  },
  {
    "qid": {
      "en-US": "2-57"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "文字列の作成と操作"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `StringBuilder` 型の変数を直接 `String` 型の変数に代入する。",
        "B. `StringBuilder` オブジェクトに対して `toString()` メソッドを呼び出す。",
        "C. `StringBuilder` オブジェクトを `(String)` でキャストする。",
        "D. `String.valueOf(StringBuilder)` を使用する。",
        "E. `StringBuilder` の `getString()` メソッドを呼び出す。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "StringBuilder sb = new StringBuilder(\"Initial\");\nsb.append(\" Value\");\n\n// String s1 = sb; // コンパイルエラー\nString s2 = sb.toString();\n// String s3 = (String) sb; // コンパイルエラー\n\nSystem.out.println(s2);"
    },
    "questionText": {
      "en-US": "`StringBuilder` オブジェクトの内容を `String` オブジェクトとして取得するための正しい方法を1つ選択してください。"
    },
    "explanation": {
      "en-US": "`StringBuilder` は可変な文字列を扱うクラスであり、`String` は不変な文字列を扱うクラスです。これらは異なるクラスであり、直接の代入(A)やキャスト(C)はできません。`StringBuilder` オブジェクトが現在保持している文字シーケンスと同じ内容を持つ新しい `String` オブジェクトを生成するには、`StringBuilder` の `toString()` メソッドを呼び出します(B)。`String.valueOf(Object)` は引数の `toString()` を呼び出すため、Dも結果的に同じですが、直接的な方法はBです。`getString()` メソッド(E)は存在しません。"
    },
    "questionCategory": {
      "en-US": "StringBuilder から String への変換"
    }
  },
  {
    "qid": {
      "en-US": "2-58"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "配列の宣言、インスタンス化、初期化および使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"2,5,9\" と表示される",
        "B. \"1,4,6\" と表示される",
        "C. \"2,5,8\" と表示される",
        "D. 実行時に `ArrayIndexOutOfBoundsException` がスローされる",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class MultiDimAccess {\n  public static void main(String[] args) {\n    int[][] table = {\n      {1, 2, 3},\n      {4, 5},\n      {6, 7, 8, 9}\n    };\n\n    int val1 = table[0][1]; // ①\n    int val2 = table[1][1]; // ②\n    // int val3 = table[1][2]; // ③ 例外発生\n    int val4 = table[2][3]; // ④\n\n    System.out.println(val1 + \",\" + val2 + \",\" + val4);\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "多次元配列（ここでは2次元配列 `table`）の要素にアクセスするには、各次元に対応するインデックスを指定します `table[行インデックス][列インデックス]`。\n- ① `table[0][1]`: 1行目(`{1, 2, 3}`)のインデックス 1 の要素なので `2`。\n- ② `table[1][1]`: 2行目(`{4, 5}`)のインデックス 1 の要素なので `5`。\n- ③ `table[1][2]`: 2行目のインデックス 2 は存在しないため、アクセスしようとすると `ArrayIndexOutOfBoundsException` が発生します（コメントアウトされているので実行されない）。\n- ④ `table[2][3]`: 3行目(`{6, 7, 8, 9}`)のインデックス 3 の要素なので `9`。\n`println` では `val1`, `val2`, `val4` の値が出力されるため、「2,5,9」が表示されます。"
    },
    "questionCategory": {
      "en-US": "多次元配列の要素アクセス"
    }
  },
  {
    "qid": {
      "en-US": "2-59"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ArrayList の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"3,false\" と表示される",
        "B. \"0,true\" と表示される",
        "C. \"0,false\" と表示される",
        "D. \"3,true\" と表示される",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListClear {\n  public static void main(String[] args) {\n    List<String> items = new ArrayList<>();\n    items.add(\"Apple\");\n    items.add(\"Banana\");\n    items.add(\"Cherry\");\n\n    items.clear(); // リストを空にする\n\n    System.out.print(items.size() + \",\");\n    System.out.print(items.isEmpty());\n  }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行したときの結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`ArrayList` の `clear()` メソッドは、リスト内のすべての要素を削除します。`items.clear()` が実行された後、リスト `items` は空になります。`items.size()` はリストの要素数を返すため、`clear()` 実行後は 0 になります。`items.isEmpty()` はリストが空かどうかを判定し、空であれば `true` を返します。したがって、出力は \"0,true\" となります。"
    },
    "questionCategory": {
      "en-US": "ArrayList.clear()"
    }
  },
  {
    "qid": {
      "en-US": "2-60"
    },
    "chapter": {
      "en-US": "2章"
    },
    "category": {
      "en-US": "ローカル変数型推論 (var)"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 拡張 for ループのループ変数宣言には `var` を使用できない。",
        "B. `var` を使用すると、ループ変数の型は常に `Object` になる。",
        "C. `var` を使用できる。ループ変数の型は、反復処理対象のコレクションや配列の要素型から推論される。",
        "D. 配列の反復処理でのみ `var` を使用でき、コレクションでは使用できない。",
        "E. コレクションの反復処理でのみ `var` を使用でき、配列では使用できない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class VarForLoop {\n  public static void main(String[] args) {\n    List<String> fruits = new ArrayList<>();\n    fruits.add(\"Mango\");\n    fruits.add(\"Orange\");\n\n    for (var fruit : fruits) { // ① 拡張forでvarを使用\n      System.out.print(fruit.toUpperCase() + \" \");\n    }\n\n    int[] scores = {90, 85, 92};\n    for (var score : scores) { // ② 配列でもvarを使用\n      System.out.print(score + 5 + \" \");\n    }\n  }\n}"
    },
    "questionText": {
      "en-US": "`var` を拡張 for ループのループ変数宣言に使用することについて、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "Java 10 以降、ローカル変数型推論 `var` は拡張 for ループのループ変数の宣言にも使用できます(Aは誤り)。この場合、ループ変数の型は、反復処理されるコレクション（例: `List<String>`）の要素型（`String`）や、配列の要素型（例: `int[]` の要素型 `int`）からコンパイラによって推論されます(Cが正しい)。型が常に `Object` になるわけではありません(Bは誤り)。コレクションと配列の両方で使用できます(D, Eは誤り)。コード例①では `fruit` は `String` 型、②では `score` は `int` 型と推論されます。"
    },
    "questionCategory": {
      "en-US": "var と拡張 for ループ"
    }
  },
  {
    "qid": {
      "en-US": "3-1"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 8",
        "B. 11",
        "C. 16",
        "D. 3"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class CalcExample {\n public static void main(String[] args) {\n  int valX = 3;\n  int valY = valX += 5; // 複合代入と代入\n  System.out.println(valX + valY); // 合計表示\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、適切なものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "複合代入演算子 `+=` は右辺の値を左辺の変数に加算し、その結果を左辺の変数に代入します。また、代入式 `var = expression` の結果は代入された値になります。`valX += 5` により `valX` は 8 になり、その結果である 8 が `valY` に代入されます。したがって、`valX` は 8、`valY` も 8 となり、`valX + valY` は 16 です。"
    },
    "questionCategory": {
      "en-US": "複合代入演算子の評価"
    }
  },
  {
    "qid": {
      "en-US": "3-2"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. byte data = 127;",
        "B. short value = 32768;",
        "C. int result = 5 * 2L;",
        "D. float amount = 20.5;"
      ]
    },
    "answer": {
      "en-US": [
        1,
        2,
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下のJavaの変数代入のうち、コンパイルエラーが発生するものを3つ選択してください。"
    },
    "explanation": {
      "en-US": "異なる数値型間の演算結果やリテラルを、より狭い範囲の型に代入する際のルールに関する問題です。\nA: `127` は `byte` の範囲内 (`-128` から `127`) なので、暗黙的な変換が可能です。\nB: `32768` は `short` の範囲 (`-32768` から `32767`) を超えています。`int` リテラルとして扱われ、`short` に代入するには明示的なキャストが必要です。\nC: `5 * 2L` の演算結果は `long` 型 (`10L`) です。`long` 型の値を `int` 型変数に代入するには明示的なキャストが必要です。\nD: `20.5` は `double` リテラルです。`double` 型の値を `float` 型変数に代入するには、明示的なキャスト `(float)` またはリテラルの末尾に `F` か `f` を付ける必要があります。\nしたがって、B, C, D がコンパイルエラーとなります。"
    },
    "questionCategory": {
      "en-US": "数値型の暗黙的/明示的型変換"
    }
  },
  {
    "qid": {
      "en-US": "3-3"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 25",
        "B. 28",
        "C. 27",
        "D. 26",
        "E. 30"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class IncrementSequence {\n public static void main(String[] args) {\n  int count = 5;\n  int result = ++count + count-- + count++ + --count + ++count;\n  // 評価:  (6)   +   (6)   +   (5)   +   (5)   +   (6)\n  // count:  6       5       6       5       6\n  System.out.println(result);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際にコンソールに出力される値として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "前置および後置インクリメント/デクリメント演算子が混在する式の評価順序と副作用を理解する必要があります。式は左から右へ評価されます。\n初期値: `count = 5`\n1. `++count`: `count` が `6` になり、式の値は `6`。\n2. `count--`: 式の値は現在の `count` (`6`) で、その後 `count` が `5` になる。\n3. `count++`: 式の値は現在の `count` (`5`) で、その後 `count` が `6` になる。\n4. `--count`: `count` が `5` になり、式の値は `5`。\n5. `++count`: `count` が `6` になり、式の値は `6`。\n合計 `result = 6 + 6 + 5 + 5 + 6 = 28`。"
    },
    "questionCategory": {
      "en-US": "インクリメント/デクリメント演算子の評価順序"
    }
  },
  {
    "qid": {
      "en-US": "3-4"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `true` が表示される",
        "B. `false` が表示される",
        "C. コンパイルエラーが発生する",
        "D. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class BooleanCompare {\n public static void main(String[] args) {\n  boolean flag1 = false;\n  boolean flag2 = true;\n  //System.out.println(flag1 > flag2); // ① 比較不可\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラム（コメントアウト部分を有効にした場合）のコンパイル結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaの `boolean` 型の値 (`true` または `false`) に対して、大小比較演算子 (`<`, `<=`, `>`, `>=`) を使用することはできません。これらの比較演算子は主に数値型や文字型（内部的に数値として扱われる）に適用されます。`boolean` 型同士の比較には、等価比較 (`==`, `!=`) や論理演算 (`&&`, `||`, `!`, `^`) を使用します。したがって、コメントアウトを外すと `flag1 > flag2` の部分でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "boolean型に対する比較演算子の適用不可"
    }
  },
  {
    "qid": {
      "en-US": "3-5"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. x=5, y=5",
        "B. x=5, y=6",
        "C. x=5, y=7",
        "D. x=6, y=6",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class ShortCircuitAnd {\n public static void main(String[] args) {\n  int x = 5;\n  int y = 5;\n  if (x < 5 && ++y > 5) { // ① x < 5 は false\n   y++; // 実行されない\n  }\n  System.out.println(\"x=\" + x + \", y=\" + y);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "論理AND演算子 `&&` は短絡評価（short-circuit evaluation）を行います。これは、左側のオペランド（条件）が `false` と評価された場合、右側のオペランドは評価（実行）されないことを意味します。なぜなら、左側が `false` であれば式全体の結果は必ず `false` になるためです。このコードでは、`if` 文の条件 `x < 5` (つまり `5 < 5`) が `false` と評価されます。そのため、`&&` の右側にある `++y > 5` は評価されず、`++y` も実行されません。したがって、`y` の値は変化せず、`if` ブロック内の `y++` も実行されません。最終的に `x` は 5、`y` も 5 のままです。"
    },
    "questionCategory": {
      "en-US": "論理AND演算子の短絡評価"
    }
  },
  {
    "qid": {
      "en-US": "3-6"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 5",
        "B. 0",
        "C. 10",
        "D. 25",
        "E. 30"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class OperatorPrecedence {\n public static void main(String[] args) {\n  int p = 50, q = 10, r = 5;\n  // 式: p / q + r * p % q\n  System.out.println(p / q + r * p % q);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "算術演算子の優先順位に関する問題です。乗算 (`*`)、除算 (`/`)、剰余 (`%`) は、加算 (`+`) および減算 (`-`) よりも優先度が高くなります。同じ優先度の演算子は左から右へ評価されます。\n式: `p / q + r * p % q`\n1. `p / q` = `50 / 10` = `5`\n2. `r * p` = `5 * 50` = `250`\n3. `(r * p) % q` = `250 % 10` = `0` (250を10で割った余り)\n4. `(p / q) + ((r * p) % q)` = `5 + 0` = `5`\nしたがって、`5` が表示されます。"
    },
    "questionCategory": {
      "en-US": "算術演算子の優先順位"
    }
  },
  {
    "qid": {
      "en-US": "3-7"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 83",
        "B. 99",
        "C. 101",
        "D. 43",
        "E. 100"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class OperatorPrecedence2 {\n public static void main(String[] args) {\n  int value = 100 - 20 / (4 * 2) + 3;\n  //          100 - 20 /   (8)   + 3\n  //          100 -     2      + 3\n  //               98        + 3\n  //                    101\n  System.out.println(value);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "演算子の優先順位と括弧の影響を考慮します。\n1. 括弧内の演算が最優先: `(4 * 2)` = `8`\n2. 次に乗算・除算: `20 / 8` = `2` (整数除算なので小数点以下は切り捨て)\n3. 最後に加算・減算を左から: \n   `100 - 2` = `98`\n   `98 + 3` = `101`\nしたがって、`101` が表示されます。"
    },
    "questionCategory": {
      "en-US": "算術演算子の優先順位と括弧"
    }
  },
  {
    "qid": {
      "en-US": "3-8"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `true`",
        "B. `false`",
        "C. コンパイルエラーが発生する",
        "D. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Item.java\nclass Item {\n private int id;\n public Item(int id) { this.id = id; }\n}\n\n// Inventory.java\npublic class Inventory {\n public static void main(String[] args) {\n  Item itemA = new Item(101);\n  Item itemB = itemA; // itemB は itemA と同じオブジェクトを指す\n  itemA = new Item(101); // itemA は *新しい* オブジェクトを指すようになる\n  System.out.println(itemA == itemB);\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Inventory` クラスを実行した際のコンソール出力として、正しいものを1つ選びなさい。（`Item` クラスは別で定義されているものとします）"
    },
    "explanation": {
      "en-US": "オブジェクト参照変数と `==` 演算子の動作に関する問題です。`==` 演算子は、二つの参照変数がメモリ上の *同じ* オブジェクトを指しているかどうかを比較します。\n1. `itemA` は `new Item(101)` で生成されたオブジェクトを指します。\n2. `itemB = itemA;` により、`itemB` も `itemA` と同じオブジェクトを指すようになります。\n3. `itemA = new Item(101);` により、`itemA` は *新しく生成された* 別の `Item` オブジェクトを指すように変更されます。`itemB` は依然として最初に生成されたオブジェクトを指したままです。\n4. `System.out.println(itemA == itemB);` では、`itemA` と `itemB` が指しているオブジェクトが異なるため、比較結果は `false` となります。"
    },
    "questionCategory": {
      "en-US": "オブジェクト参照の比較 (==)"
    }
  },
  {
    "qid": {
      "en-US": "3-9"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `true`",
        "B. `false`",
        "C. `Student` クラスでコンパイルエラー",
        "D. `Roster` クラスでコンパイルエラー",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// Student.java\nclass Student {\n private int studentId;\n private String name;\n public Student(int id, String n) {\n  this.studentId = id; this.name = n;\n }\n // studentId が同じなら等しいとみなす equals\n @Override\n public boolean equals(Object obj) {\n  if (obj == null || !(obj instanceof Student)) {\n   return false;\n  }\n  Student other = (Student) obj;\n  return this.studentId == other.studentId;\n }\n // equalsをオーバーライドしたらhashCodeも推奨\n @Override public int hashCode() { return studentId; }\n}\n\n// Roster.java\npublic class Roster {\n public static void main(String[] args) {\n  Student s1 = new Student(100, \"Alice\");\n  Student s2 = new Student(100, \"Bob\"); // IDは同じ\n  System.out.println(s1.equals(s2));\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Roster` クラスを実行した際のコンソール出力として、正しいものを1つ選びなさい。（`Student` クラスは別で定義されているものとします）"
    },
    "explanation": {
      "en-US": "`equals` メソッドのオーバーライドに関する問題です。`Student` クラスでは `equals` メソッドがオーバーライドされ、`studentId` フィールドの値が等しい場合に `true` を返すように定義されています。`s1` と `s2` は異なる名前 (`name`) を持っていますが、`studentId` はどちらも `100` で同じです。`s1.equals(s2)` を呼び出すと、オーバーライドされた `equals` メソッドが実行され、`studentId` が比較されます。IDが等しいため、結果は `true` となります。"
    },
    "questionCategory": {
      "en-US": "equalsメソッドのオーバーライドと内容比較"
    }
  },
  {
    "qid": {
      "en-US": "3-10"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `Point` クラスでコンパイルエラー",
        "B. `ComparePoints` クラスでコンパイルエラー",
        "C. \"Point equals called\" の後に `true` が表示される",
        "D. \"Point equals called\" の後に `false` が表示される",
        "E. `false` のみ表示される"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": "// Point.java\nclass Point {\n private int x;\n public Point(int x) { this.x = x; }\n // これはオーバーロード (引数が Point)\n public boolean equals(Point other) {\n  System.out.println(\"Point equals called\");\n  if (other == null) { return false; }\n  return this.x == other.x;\n }\n // Object.equalsのオーバーライドは未定義\n}\n\n// ComparePoints.java\npublic class ComparePoints {\n public static void main(String[] args) {\n  Object p1 = new Point(5);\n  Object p2 = new Point(5);\n  System.out.println(p1.equals(p2)); // Object.equalsが呼ばれる\n }\n}"
    },
    "questionText": {
      "en-US": "このの `ComparePoints` クラスを実行した際のコンソール出力として、正しいものを1つ選びなさい。（`Point` クラスは別で定義されているものとします）"
    },
    "explanation": {
      "en-US": "`Point` クラスで定義されている `equals(Point other)` メソッドは、`Object` クラスの `equals(Object obj)` メソッドをオーバーライドしていません。引数の型が異なるため、これはオーバーロードです。`ComparePoints` の `main` メソッドでは、`p1` と `p2` は `Object` 型の変数として宣言されています。そのため、`p1.equals(p2)` を呼び出すと、コンパイル時に選択されるのは `Object` クラスの `equals(Object obj)` メソッドです。`Object` クラスのデフォルトの `equals` メソッドは `==` と同じく参照比較を行います。`p1` と `p2` は `new` によって別々に生成された異なるオブジェクトなので、参照比較の結果は `false` となります。`Point` クラスの `equals(Point other)` メソッドは呼び出されないため、\"Point equals called\" は表示されません。"
    },
    "questionCategory": {
      "en-US": "equalsメソッドのオーバーロード vs オーバーライド"
    }
  },
  {
    "qid": {
      "en-US": "3-11"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `true`",
        "B. `false`",
        "C. コンパイルエラーが発生する",
        "D. 実行時に `NullPointerException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class NullCheck {\n public static void main(String[] args) {\n  String text = \"Hello\";\n  String other = null;\n  System.out.println(text.equals(other)); // ① text は null ではない\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`Object` クラスの `equals(Object obj)` メソッドの規約では、非 `null` の参照 `x` に対して `x.equals(null)` は常に `false` を返さなければなりません。`String` クラスの `equals` メソッドもこの規約に従っています。`text` は非 `null` (\"Hello\") であり、`other` は `null` です。したがって、`text.equals(other)` の呼び出しは `false` を返します。`NullPointerException` は `null` 参照に対してメソッドを呼び出そうとした場合に発生しますが、ここでは `text` が `null` ではないため発生しません。"
    },
    "questionCategory": {
      "en-US": "Object.equals() と null 引数"
    }
  },
  {
    "qid": {
      "en-US": "3-12"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `&` (ビットAND)",
        "B. `|` (ビットOR)",
        "C. `^` (ビットXOR)",
        "D. `~` (ビットNOT)"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class FlagCheck {\n private final static int READ_PERMISSION = 0b0100; // 4\n private final static int WRITE_PERMISSION = 0b0010; // 2\n private final static int EXEC_PERMISSION = 0b0001; // 1\n\n public static void main(String[] args) {\n  int userPermissions = 0b0101; // Read + Exec (5)\n  // userPermissions が READ_PERMISSION を含むかチェック\n  boolean canRead = (userPermissions _______ READ_PERMISSION) != 0;\n  System.out.println(canRead);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、コンソールに「true」と表示されるようにしたいと考えています。プログラムの空欄 `_______` に入れるべきビット演算子として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "特定のビットフラグが立っている（含まれている）かを確認するには、ビットAND演算子 `&` を使用します。`userPermissions` (0101) と `READ_PERMISSION` (0100) のビットごとのANDを取ると、`0101 & 0100 = 0100` (4) となります。この結果は 0 ではないため、`(演算結果) != 0` は `true` となり、読み取り権限があることが示されます。ビットOR `|` はフラグを立てる際に、ビットXOR `^` はフラグを反転させる際などに使われます。"
    },
    "questionCategory": {
      "en-US": "ビットAND演算子 (&) によるフラグチェック"
    }
  },
  {
    "qid": {
      "en-US": "3-13"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `if temperature > 20 then`",
        "B. `if (temperature > 20)`",
        "C. `if temperature > 20`",
        "D. `if (temperature > 20) then`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class SimpleIf {\n public static void main(String[] args) {\n  int temperature = 25;\n  ____________ // ← 空欄\n   System.out.println(\"Comfortable\");\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、「Comfortable」と表示させたいと考えています。4行目の空欄に入れるべきコードとして、Javaの `if` 文の構文として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaの `if` 文の基本的な構文は `if (条件式) { 処理 }` または `if (条件式) 処理;` です。条件式は必ず丸括弧 `()` で囲む必要があります。`then` キーワードはJavaの `if` 文では使用しません。選択肢Bは正しい構文であり、条件 `temperature > 20` (つまり `25 > 20`) は `true` なので、次の行の `System.out.println` が実行されます。"
    },
    "questionCategory": {
      "en-US": "if文の基本構文"
    }
  },
  {
    "qid": {
      "en-US": "3-14"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Condition True\" が表示される",
        "B. \"Always Executed\" が表示される",
        "C. \"Condition True\" と \"Always Executed\" が表示される",
        "D. 何も表示されない",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class IfScope {\n public static void main(String[] args) {\n  boolean condition = false;\n  if (condition)\n   System.out.println(\"Condition True\"); // if に属する\n   System.out.println(\"Always Executed\"); // if とは無関係\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`if` 文の後に波括弧 `{}` がない場合、`if` の制御は直後の1つの文にのみ適用されます。このコードでは `if (condition)` の条件が `false` です。そのため、直後の `System.out.println(\"Condition True\");` は実行されません。しかし、その次の `System.out.println(\"Always Executed\");` は `if` 文の制御下にはなく、独立した文として扱われるため、条件に関わらず実行されます。したがって、\"Always Executed\" のみが表示されます。"
    },
    "questionCategory": {
      "en-US": "if文のスコープ（波括弧なし）"
    }
  },
  {
    "qid": {
      "en-US": "3-15"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Y\" と表示される",
        "B. \"Z\" と表示される",
        "C. \"YZ\" と表示される",
        "D. \"YW\" と表示される",
        "E. \"XW\" と表示される"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class IfElseSequence {\n public static void main(String[] args) {\n  int value = 5;\n  if (value > 5) { // false\n   System.out.println(\"X\");\n  } else if (value == 5) { // true\n   System.out.println(\"Y\"); // 表示される\n  }\n  // 上の if-else if とは独立した if-else\n  if (value <= 5) { // true\n   System.out.println(\"Z\"); // 表示される\n  } else {\n   System.out.println(\"W\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "このコードには2つの独立した `if` 構造があります。\n1. 最初の `if-else if` 構造: `value > 5` は `false` です。`else if (value == 5)` は `true` なので、`System.out.println(\"Y\");` が実行されます。このブロックはここで終了します。\n2. 次の `if-else` 構造: `if (value <= 5)` は `true` なので、`System.out.println(\"Z\");` が実行されます。`else` ブロックは実行されません。\n結果として、\"Y\" と \"Z\" が順に表示されます。"
    },
    "questionCategory": {
      "en-US": "if-else if と独立した if-else"
    }
  },
  {
    "qid": {
      "en-US": "3-16"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. Grade A",
        "B. Grade B",
        "C. Grade C",
        "D. Grade D",
        "E. 何も表示されない"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class NestedIfElse {\n public static void main(String[] args) {\n  int score = 75;\n  if (score >= 90) { // false\n   System.out.println(\"Grade A\");\n  } else {\n   if (score >= 80) { // false\n    System.out.println(\"Grade B\");\n   } else {\n    if (score >= 70) { // true\n     System.out.println(\"Grade C\"); // 表示される\n    } else {\n     System.out.println(\"Grade D\");\n    }\n   }\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "ネストされた `if-else` 構造を評価します。\n1. 外側の `if (score >= 90)`: `75 >= 90` は `false` なので、最初の `else` ブロックに進みます。\n2. 最初の `else` 内の `if (score >= 80)`: `75 >= 80` は `false` なので、その `else` ブロックに進みます。\n3. 二番目の `else` 内の `if (score >= 70)`: `75 >= 70` は `true` なので、`System.out.println(\"Grade C\");` が実行されます。\nしたがって、\"Grade C\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "ネストしたif-elseの解釈"
    }
  },
  {
    "qid": {
      "en-US": "3-17"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `byte`",
        "B. `float`",
        "C. `long`",
        "D. `String`",
        "E. `int`",
        "F. `Boolean`",
        "G. `enum` 型",
        "H. `char`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        3,
        4,
        6,
        7
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java の `switch` 文の括弧 `()` 内に記述できる式の型として、適切なものを5つ選択してください。"
    },
    "explanation": {
      "en-US": "Java の `switch` 文の式（セレクタ式）として使用できる型は、`byte`, `short`, `int`, `char` およびそれらのラッパークラス (`Byte`, `Short`, `Integer`, `Character`)、`String` (Java 7 以降)、そして `enum` 型 (Java 5 以降) です。`long`, `float`, `double`, `boolean` およびそのラッパークラス (`Long`, `Float`, `Double`, `Boolean`) は `switch` 文の式として使用できません。したがって、選択肢の中では A, D, E, G, H が適切です。"
    },
    "questionCategory": {
      "en-US": "switch文で使用可能なデータ型"
    }
  },
  {
    "qid": {
      "en-US": "3-18"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `case code:` の行",
        "B. `case 1 + 1:` の行",
        "C. `case (byte)128:` の行",
        "D. `case \"2\":` の行"
      ]
    },
    "answer": {
      "en-US": [
        0,
        3
      ]
    },
    "code": {
      "en-US": "public class SwitchCaseLabel {\n public static void main(String[] args) {\n  final byte CODE_A = 1;\n  byte code = 2;\n  switch (code) {\n   case CODE_A: System.out.println(\"A\"); break; // 定数OK\n   //case code: System.out.println(\"B\"); break; // 変数NG\n   //case 1 + 1: System.out.println(\"C\"); break; // 定数式OK\n   case (byte)128: System.out.println(\"D\"); break; // キャスト定数OK\n   //case \"2\": System.out.println(\"E\"); break; // 型不一致NG\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムについて、コメントアウトされた行のうち、コメントを外すとコンパイルエラーが発生する行を2つ選択してください。"
    },
    "explanation": {
      "en-US": "`switch` 文の `case` ラベルには、コンパイル時に値が確定する定数式（コンパイル時定数）を指定する必要があります。また、その定数の型は `switch` 式の型と互換性がなければなりません。\n- `case CODE_A:`: `CODE_A` は `final byte` なのでコンパイル時定数。OK。\n- `case code:`: `code` は `final` でない変数なのでコンパイル時定数ではない。エラー。\n- `case 1 + 1:`: `1 + 1` はコンパイル時に `2` と評価される定数式。`byte` 型に代入可能。OK。\n- `case (byte)128:`: `(byte)128` はコンパイル時に `-128` と評価される定数式。OK。\n- `case \"2\":`: `\"2\"` は `String` 型リテラルであり、`switch` 式の `byte` 型と互換性がない。エラー。\nしたがって、コンパイルエラーが発生するのは `case code:` の行と `case \"2\":` の行です。"
    },
    "questionCategory": {
      "en-US": "switch文のcaseラベルの定数要件"
    }
  },
  {
    "qid": {
      "en-US": "3-19"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Silver \"",
        "B. \"Silver Gold \"",
        "C. \"Bronze Silver Gold \"",
        "D. \"Bronze Silver Gold Platinum \"",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class SwitchFallthrough {\n public static void main(String[] args) {\n  int level = 2;\n  switch (level) {\n   case 1:\n    System.out.print(\"Bronze \");\n   case 2: // level=2 なのでここから実行\n    System.out.print(\"Silver \"); // 表示 (breakなし)\n   case 3:\n    System.out.print(\"Gold \"); // フォールスルーで表示\n    break; // ここで抜ける\n   default:\n    System.out.print(\"Platinum \");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`switch` 文では、一致した `case` ラベルから実行が始まり、`break` 文に遭遇するか `switch` 文の終わり（`}`）に達するまで、後続の `case` ラベルの処理も実行されます（これをフォールスルーと呼びます）。\n`level` は `2` なので、実行は `case 2:` から始まります。\n1. `System.out.print(\"Silver \");` が実行されます。\n2. `case 2:` には `break` がないため、処理は `case 3:` にフォールスルーします。\n3. `System.out.print(\"Gold \");` が実行されます。\n4. `case 3:` の終わりに `break;` があるため、ここで `switch` 文から抜け出します。\nしたがって、\"Silver Gold \" が表示されます。"
    },
    "questionCategory": {
      "en-US": "switch文のフォールスルー動作"
    }
  },
  {
    "qid": {
      "en-US": "3-20"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"D\"",
        "B. \"DR\"",
        "C. \"DRP\"",
        "D. \"P\"",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class DefaultFallthrough {\n public static void main(String[] args) {\n  String status = \"Pending\";\n  switch (status) {\n   case \"Approved\": System.out.print(\"A\"); break;\n   default: System.out.print(\"D\"); // breakなし\n   case \"Rejected\": System.out.print(\"R\"); break;\n   case \"Pending\": System.out.print(\"P\"); break; // ここに一致\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`status` は \"Pending\" です。`switch` 文は一致する `case` ラベルに直接ジャンプします。`case \"Pending\":` に一致するため、\"P\" が表示され、`break` 文によって `switch` 文から抜け出します。`default` ラベルの位置や `break` の有無は、一致する `case` に直接ジャンプする動作には影響しません。"
    },
    "questionCategory": {
      "en-US": "switch文のdefaultラベルの位置とフォールスルー"
    }
  },
  {
    "qid": {
      "en-US": "3-21"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "switch 式の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Option 1 selected\"",
        "B. \"Option 2 selected\"",
        "C. \"Option 3 selected\"",
        "D. コンパイルエラーが発生する",
        "E. \"Invalid option\""
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class SwitchExpressionArrow {\n public static void main(String[] args) {\n  int option = 3;\n  switch (option) {\n   case 1 -> System.out.println(\"Option 1 selected\");\n   case 2 -> System.out.println(\"Option 2 selected\");\n   case 3 -> System.out.println(\"Option 3 selected\"); // 一致\n   default -> System.out.println(\"Invalid option\");\n  } // 暗黙の break\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラム（Java 14以降）を実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "Java 14 で正式導入された `switch` 式では、アロー構文 (`->`) を使用できます。アロー構文を使用した場合、`case` ラベルに一致すると `->` の右側の式または文ブロックのみが実行され、その後 `switch` 構造全体が終了します（暗黙的な `break` のような動作）。フォールスルーは発生しません。\n`option` は `3` なので、`case 3 -> ...` に一致します。`System.out.println(\"Option 3 selected\");` が実行され、`switch` 式（この場合は文として使用）が終了します。したがって、\"Option 3 selected\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "switch式のアロー構文 (->)"
    }
  },
  {
    "qid": {
      "en-US": "3-22"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "switch 式の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Discount: 10%\"",
        "B. \"Discount: 20%\"",
        "C. \"Discount: 0%\"",
        "D. ②で複数ラベルは指定できないためコンパイルエラー",
        "E. ③でdefaultがないとコンパイルエラーになる場合がある"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class SwitchExpressionValue {\n public static void main(String[] args) {\n  char category = 'B';\n  int discount = switch (category) { // ① switch式\n   case 'A' -> 10;\n   case 'B', 'C' -> 20; // ② 複数ラベル\n   default -> 0; // ③ default必須\n  }; // ④ セミコロン必須\n  System.out.println(\"Discount: \" + discount + \"%\");\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラム（Java 14以降）を実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "これは値を返す `switch` 式の例です。\n① `switch` の結果を変数 `discount` に代入しています。\n② `case` ラベルはカンマ区切りで複数指定できます。`category` は `'B'` なので、`case 'B', 'C' -> 20;` に一致します。\n③ `switch` 式が値を返す場合、すべての可能な入力値に対して対応する `case` (または `default`) が存在する必要があります。`default` は通常必要です。\n④ `switch` 式は式文の一部なので、末尾にセミコロンが必要です。\n`category` が `'B'` なので、`switch` 式の結果は `20` となります。これが `discount` に代入され、\"Discount: 20%\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "値を返すswitch式"
    }
  },
  {
    "qid": {
      "en-US": "3-23"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "switch 式の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Type A\"",
        "B. \"Type B\"",
        "C. \"Unknown\"",
        "D. `yield` ではなく `return` を使うべきでコンパイルエラー",
        "E. `case` の後に `{}` がないと `yield` は使えずコンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class SwitchExpressionYield {\n public static void main(String[] args) {\n  int type = 3;\n  String message = switch (type) {\n   case 1:\n    yield \"Type A\"; // コロン構文ではyieldで値を返す\n   case 2:\n    yield \"Type B\";\n   default:\n    yield \"Unknown\";\n  }; // 式の終わり\n  System.out.println(message);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラム（Java 14以降）を実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`switch` 式で伝統的なコロン (`:`) 構文を使用する場合、その `case` ブロックから値を返すには `yield` キーワードを使用します（`break` ではなく）。`yield` は `switch` 式から値を返し、その `case` ブロックの実行を終了させます。\n`type` は `3` です。`case 1:` と `case 2:` には一致しません。`default:` ラベルが実行され、`yield \"Unknown\"` によって `switch` 式の結果として `\"Unknown\"` が返されます。これが変数 `message` に代入され、表示されます。\n注: `case 1: yield \"A\";` のような書き方もJava 14以降で有効ですが、一般的には `case 1: { yield \"A\"; }` のようにブロックで囲みます。"
    },
    "questionCategory": {
      "en-US": "switch式のコロン構文とyield"
    }
  },
  {
    "qid": {
      "en-US": "3-24"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "switch 式の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `yield true;`",
        "B. `return true;`",
        "C. `break true;`",
        "D. `true;`"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class SwitchYieldBlock {\n public static void main(String[] args) {\n  String input = \"Yes\";\n  int code = 10;\n  boolean result = switch (input) {\n   case \"Yes\" -> true;\n   case \"No\" -> false;\n   case \"Maybe\" -> {\n    System.out.println(\"Checking code...\");\n    if (code > 5) {\n     ____________ // ← 処理ブロックから値を返す\n    } else {\n     yield false;\n    }\n   }\n   default -> false;\n  };\n  System.out.println(result);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムが `input`=\"Maybe\" かつ `code`=10 の場合に `result` が `true` となるように、11行目の空欄に入るべきコードとして正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`switch` 式のアロー (`->`) の右側が処理ブロック (`{}`) になっている場合、そのブロックから `switch` 式の結果となる値を返すには `yield` 文を使用します。`return` はメソッドから値を返すために使われ、`break` は `switch` 文やループを抜けるために使われます（値を返しません）。`true;` だけでは文として不完全です。したがって、ブロックから `boolean` 値 `true` を返すには `yield true;` を使用します。"
    },
    "questionCategory": {
      "en-US": "switch式のブロック内からの値返却 (yield)"
    }
  },
  {
    "qid": {
      "en-US": "3-25"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `counter > limit`",
        "B. `counter >= limit`",
        "C. `counter < limit`",
        "D. `counter <= limit`"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class WhileCondition {\n public static void main(String[] args) {\n  int counter = 5;\n  int limit = 0;\n  while ( ________ ) { // ← 空欄 ループ継続条件\n   System.out.print(counter + \" \"); // 5 4 3 2 1 を表示したい\n   counter--;\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、コンソールに「5 4 3 2 1 」と表示されるようにしたいと考えています。5行目の空欄 `________` に入れるべきループ継続条件として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`counter` が 5 から始まり、ループ内でデクリメントされながらその値が表示されます。「5 4 3 2 1」と表示されるためには、`counter` が 1 のときにループ本体が実行され、`counter` が 0 になった時点でループが終了する必要があります。\nループ条件を評価するのはループ本体の実行 *前* です。\n- `counter = 1` のとき: ループ本体を実行したいので、条件は `true` である必要がある。\n- `counter = 0` のとき: ループを終了したいので、条件は `false` である必要がある。\n変数 `limit` は `0` です。\n選択肢を検証します:\nA. `counter > limit` (`counter > 0`): `counter=1` のとき `1 > 0` は `true`。`counter=0` のとき `0 > 0` は `false`。これが正しい条件です。\nB. `counter >= limit`: `counter=0` のとき `0 >= 0` は `true` となり、ループが余分に実行されます。\nC, D: 明らかに逆の条件です。"
    },
    "questionCategory": {
      "en-US": "whileループの継続条件"
    }
  },
  {
    "qid": {
      "en-US": "3-26"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. ① `do`, ② `while`",
        "B. ① `while`, ② `do`",
        "C. ① `do`, ② `until`",
        "D. ① `do`, ② `while;`"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class DoWhileSyntax {\n public static void main(String[] args) {\n  int index = 0;\n  ① ________ {\n   System.out.print(index + \" \");\n   index++;\n  } ② ________ ( index < 3 );\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、コンソールに「0 1 2 」と表示されるようにしたいと考えています。空欄①と②に入るべきキーワードの組み合わせとして、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`do-while` ループは、ループ本体を最低1回実行し、その後で条件を評価するループ構造です。その基本構文は `do { /* 処理 */ } while (条件式);` です。ループ本体を実行した後に条件を判定するため、`while` の後の条件式の終わりにはセミコロン `;` が必要です。\n- ① には `do` が入ります。\n- ② には `while` が入り、その後に条件式 `( index < 3 )` とセミコロン `;` が続きます。\nしたがって、正しい組み合わせは ① `do`, ② `while;` です。"
    },
    "questionCategory": {
      "en-US": "do-whileループの基本構文"
    }
  },
  {
    "qid": {
      "en-US": "3-27"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「012」と表示される",
        "B. 無限ループになる",
        "C. 何も表示されない",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class DoWhileError {\n public static void main(String[] args) {\n  int counter = 0;\n  do {\n   System.out.print(counter);\n   counter++;\n  } while (counter < 3) // ← セミコロンがない\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルしようとした場合の結果として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`do-while` ループの構文では、`while (条件式)` の後に必ずセミコロン `;` が必要です。このコードでは、`while (counter < 3)` の後にセミコロンが欠落しているため、Javaの構文規則に違反します。したがって、このコードはコンパイルエラーとなります。"
    },
    "questionCategory": {
      "en-US": "do-whileループの構文エラー（セミコロン欠落）"
    }
  },
  {
    "qid": {
      "en-US": "3-28"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. コンパイルエラーが発生する",
        "C. コンパイルは成功するが実行時にエラーが発生する",
        "D. コンパイル時に警告が出るが成功する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class ForInitTypeError {\n public static void main(String[] args) {\n  for (int count = 0, double factor = 1.0; count < 3; count++) {\n   // System.out.println(count * factor);\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルしようとした場合の結果として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`for` ループの初期化部分で複数の変数を宣言して初期化する場合、それらの変数はすべて *同じ* データ型でなければなりません。このコードの `for` ループの初期化部分 `int count = 0, double factor = 1.0` では、`int` 型の変数 `count` と `double` 型の変数 `factor` を同時に宣言しようとしています。異なる型を混在させることはできないため、この部分でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "for文の初期化式での型宣言"
    }
  },
  {
    "qid": {
      "en-US": "3-29"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. ①の行でコンパイルエラーが発生するため、実行できない。",
        "B. ②の行でコンパイルエラーが発生するため、実行できない。",
        "C. 正常にコンパイル・実行され、8 が表示される。",
        "D. 正常にコンパイル・実行され、10 が表示される。",
        "E. 正常にコンパイル・実行され、20 が表示される。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class ForScope {\n public static void main(String[] args) {\n  int multiplier = 2;\n  int sum = 0;\n  for (int i = 1; i <= 4; i++) {\n   sum = multiplier * i; // ループ内で sum が更新される\n  }\n  // System.out.println(i); // ① i はスコープ外\n  System.out.println(sum); // ② sum はスコープ内\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラム（①の行がコメントアウトされている状態）をコンパイルし、実行したときの結果について正しい説明を1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`for` ループの初期化式で宣言された変数（ここでは `i`）のスコープは、その `for` ループのブロック内に限定されます。したがって、ループの外側（①の行）で `i` を参照しようとするとコンパイルエラーになります（現在はコメントアウトされています）。一方、変数 `sum` は `for` ループの外側で宣言されているため、ループの後（②の行）でも有効です。ループは `i` が 1, 2, 3, 4 の場合に実行されます。ループの最後の反復（`i=4`）で `sum` に `multiplier * i` すなわち `2 * 4 = 8` が代入されます。ループ終了後、②の行で `sum` の値 `8` が表示されます。"
    },
    "questionCategory": {
      "en-US": "forループ変数のスコープ"
    }
  },
  {
    "qid": {
      "en-US": "3-30"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `k < 0`",
        "B. `k > 0`",
        "C. `k == 0`",
        "D. `k != 0`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class ForSingleExec {\n public static void main(String[] args) {\n  for (int k = 0; ________ ; k++) {\n   System.out.println(\"Loop body executed\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、コンソールに「Loop body executed」と1回だけ表示されるようにしたいと考えています。3行目の空欄 `________` に入れるべきループ継続条件として適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "ループ本体を1回だけ実行し、その後ループを終了させる条件を考えます。`k` は 0 で初期化されます。\n- ループの最初の反復（`k=0`）: ループ本体を実行したいので、条件は `true` である必要があります。\n- ループの次の反復の評価（`k=1` になった後）: ループを終了したいので、条件は `false` である必要があります。\n選択肢を検証します:\nA. `k < 0`: `k=0` で `0 < 0` は `false`。ループは実行されません。\nB. `k > 0`: `k=0` で `0 > 0` は `false`。ループは実行されません。\nC. `k == 0`: `k=0` で `0 == 0` は `true`。ループ本体が実行され、`k` が 1 になります。次の評価で `k=1` で `1 == 0` は `false`。ループが終了します。これが正しい条件です。\nD. `k != 0`: `k=0` で `0 != 0` は `false`。ループは実行されません。"
    },
    "questionCategory": {
      "en-US": "forループの継続条件（単一実行）"
    }
  },
  {
    "qid": {
      "en-US": "3-31"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"0:5 1:4 \"",
        "B. \"0:5 1:5 \"",
        "C. \"0:5 1:6 \"",
        "D. \"1:4 2:5 \"",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class ForUpdateInteraction {\n public static void main(String[] args) {\n  int total = 0;\n  for (int x = 0, y = 5; x < 2; x++, y--) {\n   System.out.print(x + \":\" + y + \" \"); // ループ中の値表示\n   total += y; // y を total に加算\n   y = y + x; // ループ本体で y を変更\n  }\n  // System.out.println(\"\\nFinal total: \" + total);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`for` ループの実行順序（初期化 -> 条件評価 -> 本体 -> 更新処理）と、ループ本体および更新処理での変数の変化を追跡します。\n初期化: `x = 0`, `y = 5`, `total = 0`\n1. **反復1:**\n   - 条件: `x < 2` ( `0 < 2` ) -> `true`\n   - 本体:\n     - `print(x + \":\" + y + \" \")` -> `0:5 ` を出力\n     - `total += y` -> `total = 0 + 5 = 5`\n     - `y = y + x` -> `y = 5 + 0 = 5`\n   - 更新: `x++` -> `x = 1`, `y--` -> `y = 4`\n2. **反復2:**\n   - 条件: `x < 2` ( `1 < 2` ) -> `true`\n   - 本体:\n     - `print(x + \":\" + y + \" \")` -> `1:4 ` を出力\n     - `total += y` -> `total = 5 + 4 = 9`\n     - `y = y + x` -> `y = 4 + 1 = 5`\n   - 更新: `x++` -> `x = 2`, `y--` -> `y = 4`\n3. **反復3:**\n   - 条件: `x < 2` ( `2 < 2` ) -> `false`。ループ終了。\nしたがって、コンソールには \"0:5 1:4 \" が表示されます。"
    },
    "questionCategory": {
      "en-US": "forループの更新処理とループ本体での変数変更"
    }
  },
  {
    "qid": {
      "en-US": "3-32"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"1-2-3\"",
        "B. \"1-2-3-\"",
        "C. \"-1-2-3\"",
        "D. \"123-\"",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class ForUpdateMethodCall {\n public static void main(String[] args) {\n  for (int count = 1; count <= 3; count++, printDash()) {\n   System.out.print(count);\n  }\n }\n private static void printDash() {\n  System.out.print(\"-\");\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`for` ループの更新処理部分は、ループ本体の実行 *後* に評価されます。\n1. **反復1:** `count=1`. 条件 `1 <= 3` は `true`。本体: `print(1)` 出力。更新: `count` が 2 になり、`printDash()` が呼ばれて `print(\"-\")` 出力。\n2. **反復2:** `count=2`. 条件 `2 <= 3` は `true`。本体: `print(2)` 出力。更新: `count` が 3 になり、`printDash()` が呼ばれて `print(\"-\")` 出力。\n3. **反復3:** `count=3`. 条件 `3 <= 3` は `true`。本体: `print(3)` 出力。更新: `count` が 4 になり、`printDash()` が呼ばれて `print(\"-\")` 出力。\n4. **反復4:** `count=4`. 条件 `4 <= 3` は `false`。ループ終了。\nしたがって、出力は \"1-2-3-\" となります。"
    },
    "questionCategory": {
      "en-US": "forループの更新処理での副作用（メソッド呼び出し）"
    }
  },
  {
    "qid": {
      "en-US": "3-33"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `int col = 0`",
        "B. `col = 0` (事前に `int col;` が必要)",
        "C. `int col = 1`",
        "D. 空欄のままにする"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class NestedLoopInit {\n public static void main(String[] args) {\n  char[][] letters = {{'a', 'b'}, {'c', 'd', 'e'}};\n  String result = \"\";\n  for (int row = 0; row < letters.length; row++) {\n   // 内側ループの開始\n   for ( ________ ; col < letters[row].length; col++) {\n    result += letters[row][col];\n   }\n  }\n  System.out.println(result);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、コンソールに「abcde」と表示されるようにしたいと考えています。7行目の空欄 `________` に入れるべき内側ループの初期化コードとして正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "ネストされた `for` ループで2次元配列の全要素を順番に処理する場合、内側のループ（列を処理するループ）は、外側のループ（行を処理するループ）の各反復が始まるたびに、列インデックスを最初（通常は 0）から始めるように初期化する必要があります。空欄部分には、内側のループ変数 `col` を宣言し、0 で初期化する `int col = 0` を記述するのが適切です。もし `col` がループの外側で宣言されているなら `col = 0` でも良いですが、通常は内側ループの初期化式で宣言・初期化します。"
    },
    "questionCategory": {
      "en-US": "ネストしたforループの内側ループ初期化"
    }
  },
  {
    "qid": {
      "en-US": "3-34"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常に実行完了する",
        "B. コンパイルエラーが発生する",
        "C. 実行時に `NullPointerException` がスローされる",
        "D. 実行時に `ArrayIndexOutOfBoundsException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class JaggedLoopError {\n public static void main(String[] args) {\n  int[][] jagged = new int[3][]; // 要素数は3\n  jagged[0] = new int[2]; // 長さ2\n  jagged[1] = new int[4]; // 長さ4\n  jagged[2] = new int[3]; // 長さ3\n  int count = 0;\n  for (int i = 0; i < jagged.length; i++) {\n   // 注意: 内側ループの条件が固定\n   for (int j = 0; j < 3; j++) { // jagged.length ではなく 3\n    jagged[i][j] = count++;\n   }\n  }\n  // System.out.println(Arrays.deepToString(jagged));\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合の結果として正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "このコードはジャグ配列（行ごとに長さが異なる可能性がある配列）を扱っています。外側のループ (`i`) は正しく配列の行数 (`jagged.length`、つまり 3) だけ繰り返します。しかし、内側のループ (`j`) の条件が `j < 3` と固定されています。\n- `i = 0` のとき: `jagged[0]` の長さは 2 です。内側ループは `j=0, 1, 2` と繰り返そうとしますが、`j=2` のときに `jagged[0][2]` にアクセスしようとすると、インデックス 2 は存在しないため `ArrayIndexOutOfBoundsException` が発生します。\nしたがって、実行時に `ArrayIndexOutOfBoundsException` がスローされます。"
    },
    "questionCategory": {
      "en-US": "ジャグ配列に対するループ条件の誤り"
    }
  },
  {
    "qid": {
      "en-US": "3-35"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `int i = 0; i >= 0; i++`",
        "B. `int i = 0; i < 0; i++`",
        "C. ` ; ; `",
        "D. `int i = 10; ; i--`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        2,
        3
      ]
    },
    "code": {
      "en-US": "public class InfiniteLoop {\n public static void main(String[] args) {\n  for ( ________ ) {\n   System.out.println(\"Running...\");\n   // 無限ループを意図\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムの3行目の空欄 `________` に記述すると、無限ループが発生する可能性のあるコードを3つ選択してください。"
    },
    "explanation": {
      "en-US": "`for` 文が無限ループになる条件を考えます。\n A: `i = 0` で始まり、`i` は増加し続けます。条件 `i >= 0` は `i` が負にならない限り常に `true` なので、無限ループになります。\n B: `i = 0` で始まり、条件 `i < 0` は最初から `false` なので、ループは一度も実行されません。\n C: `for` 文の条件式部分を省略すると、常に `true` とみなされます。初期化と更新処理は行われますが、終了条件がないため無限ループになります。\n D: `i = 10` で始まり、条件式が省略されているため常に `true` とみなされます。`i` はデクリメントされ続けますが、終了条件がないため無限ループになります。\nしたがって、A, C, D が無限ループを引き起こす可能性があります。"
    },
    "questionCategory": {
      "en-US": "for文の無限ループ"
    }
  },
  {
    "qid": {
      "en-US": "3-36"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `String element : matrix`",
        "B. `String[] element : matrix`",
        "C. `matrix : String[] element`",
        "D. `Object element : matrix`",
        "E. `String[][] element : matrix`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class EnhancedFor2D {\n public static void main(String[] args) {\n  String[][] matrix = {{\"X\", \"O\"}, {\"O\", \"X\"}};\n  for ( ________ ) {\n   System.out.println(element); // 各行(String[])を表示したい\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムで、2次元配列 `matrix` の各行（1次元配列）を順番に取り出して表示したいと考えています。4行目の空欄 `________` に記述する拡張 for 文のループ変数宣言として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "拡張 `for` 文の構文は `for (要素の型 ループ変数名 : コレクションまたは配列)` です。2次元配列 `String[][] matrix` を反復処理する場合、各要素は1次元配列 `String[]` になります。したがって、ループ変数の型は `String[]` とするのが適切です。選択肢B `String[] element : matrix` が正しい構文です。選択肢AやDでは型が一致せず、Cは構文が逆、Eは次元が異なります。"
    },
    "questionCategory": {
      "en-US": "拡張for文の構文（多次元配列）"
    }
  },
  {
    "qid": {
      "en-US": "3-37"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"CC\"",
        "B. \"AB\"",
        "C. \"BC\"",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class EnhancedForReassign {\n public static void main(String[] args) {\n  StringBuilder[] builders = {\n   new StringBuilder(\"A\"),\n   new StringBuilder(\"B\")\n  };\n  for (StringBuilder sb : builders) { // ①\n   sb = new StringBuilder(\"C\"); // ② ループ変数に再代入\n  }\n  for (StringBuilder sb : builders) { // ③\n   System.out.print(sb);\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "拡張 `for` ループのループ変数（①の `sb`）は、反復対象の配列やコレクションから取り出された要素への参照を保持するローカル変数です。②の行 `sb = new StringBuilder(\"C\");` では、ループ変数 `sb` が *新しく作成された* `StringBuilder(\"C\")` オブジェクトを参照するように変更されます。これは、元の配列 `builders` が保持している参照には影響を与えません。`builders` 配列の要素は、依然として最初に作成された `StringBuilder(\"A\")` と `StringBuilder(\"B\")` を参照したままです。したがって、③のループでは元の配列の内容が出力され、「AB」が表示されます。"
    },
    "questionCategory": {
      "en-US": "拡張forループ変数への再代入の影響"
    }
  },
  {
    "qid": {
      "en-US": "3-38"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \nint value = 5;\nwhile (value < 5) { // 最初から false\n System.out.print(value + \" \");\n value++;\n}",
        "B. \nint value = 5;\nif (value < 5) { // false なので実行されない\n while (true) {\n  System.out.print(value + \" \");\n  value++;\n  if (!(value < 5)) break;\n }\n}",
        "C. \nint value = 5;\nboolean first = true;\nwhile (first || value < 5) { // 1回実行される\n first = false;\n System.out.print(value + \" \"); // 5\n value++; // 6\n}",
        "D. \nint value = 5;\nSystem.out.print(value + \" \"); // 先に1回実行\nvalue++;\nwhile (value < 5) { // 6 < 5 は false\n System.out.print(value + \" \");\n value++;\n}"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// 基準となる do-while ループ\nint value = 5;\ndo {\n System.out.print(value + \" \"); // 5\n value++; // 6\n} while (value < 5); // 6 < 5 は false\n// 出力: 5"
    },
    "questionText": {
      "en-US": "このの基準となる `do-while` ループと同じコンソール出力を生成する `while` ループを使用したコードを、以下の選択肢から1つ選びなさい。"
    },
    "explanation": {
      "en-US": "基準の `do-while` ループは、条件に関わらず本体を最低1回実行するため、`value=5` の時に「5 」を出力し、その後 `value` が6になり条件 `6 < 5` が `false` となって終了します。これと同じ動作をする `while` ループを探します。\nA: `while(5 < 5)` は偽なのでループは実行されません。\nB: `if(5 < 5)` は偽なので何も実行されません。\nC: 最初の反復で `first` が `true` なのでループに入り、「5 」を出力し `value` は 6 になります。次の反復で `first` は `false`、`value < 5` も `false` なのでループが終了します。結果「5 」が出力されます。\nD: 先に「5 」を出力し `value` は6になります。`while(6 < 5)` は偽なのでループは実行されません。結果「5 」が出力されます。しかし、これはループ構造としては基準コードと異なります。\n選択肢Cが、ループ構造を用いて基準コードと同じ出力を生成する最も近いコードです。（ただし、`do-while` を `while` で完全に等価に模倣するのは少し技巧的になります。）"
    },
    "questionCategory": {
      "en-US": "do-whileとwhileの等価性"
    }
  },
  {
    "qid": {
      "en-US": "3-39"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `while (idx > 0) {`",
        "B. `do { } while (idx > 0);`",
        "C. `while (idx >= 0) {`",
        "D. `do { } while (idx >= 0);`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        1
      ]
    },
    "code": {
      "en-US": "public class ReverseLoop {\n public static void main(String[] args) {\n  char[] chars = {'a', 'b', 'c', 'd'};\n  int idx = chars.length; // ① idx = 4\n  ____________ // ← 空欄② (ループ構造)\n   idx--;\n   System.out.print(chars[idx]);\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行して「dcba」と表示されるようにしたいと考えています。空欄②に入るループ構造のコードとして正しいものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "配列 `chars` のインデックスは 0 から 3 です。「dcba」と表示するには、インデックス 3, 2, 1, 0 の順にアクセスする必要があります。ループ内で `idx` をデクリメント *してから* アクセスするため、ループは `idx` が 4, 3, 2, 1 の時に実行され、`idx` が 0 になった時点で終了する必要があります。\nA: `while (idx > 0)`: `idx=4,3,2,1` でループ実行。`idx=0` で終了。正しい。\nB: `do { } while (idx > 0);`: `idx=4` で実行 -> `idx=3`, `3>0` true. `idx=3` で実行 -> `idx=2`, `2>0` true. `idx=2` で実行 -> `idx=1`, `1>0` true. `idx=1` で実行 -> `idx=0`, `0>0` false. ループ終了。正しい。\nC: `while (idx >= 0)`: `idx=0` の時もループに入り `idx` が -1 になり `chars[-1]` にアクセスしようとしてエラー。\nD: `do { } while (idx >= 0)`: 同様に `chars[-1]` にアクセスしようとしてエラー。\nしたがって、正しいのは A と B です。"
    },
    "questionCategory": {
      "en-US": "while/do-whileでの配列逆順処理"
    }
  },
  {
    "qid": {
      "en-US": "3-40"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 0",
        "B. 3",
        "C. 6",
        "D. 9",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class NestedBreak {\n public static void main(String[] args) {\n  int count = 0;\n  for (int i = 0; i < 3; i++) {\n   for (int j = 0; j < 3; j++) {\n    if (i == j) {\n     break; // 内側の j ループのみ抜ける\n    }\n    count++;\n   }\n   // 内側ループ終了後、外側ループは継続\n  }\n  System.out.println(count);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`break` 文は、ラベルが指定されていない場合、それが含まれる最も内側のループ（`for`, `while`, `do-while`）または `switch` 文を終了させます。\n- **i = 0**: 内側ループ開始。\n  - j = 0: `i == j` が `true` なので `break`。内側ループ終了。\n- **i = 1**: 内側ループ開始。\n  - j = 0: `i == j` が `false`。`count` が 1 になる。\n  - j = 1: `i == j` が `true` なので `break`。内側ループ終了。\n- **i = 2**: 内側ループ開始。\n  - j = 0: `i == j` が `false`。`count` が 2 になる。\n  - j = 1: `i == j` が `false`。`count` が 3 になる。\n  - j = 2: `i == j` が `true` なので `break`。内側ループ終了。\n外側ループ終了。最終的な `count` の値は `3` です。"
    },
    "questionCategory": {
      "en-US": "ネストしたループと単純break"
    }
  },
  {
    "qid": {
      "en-US": "3-41"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 6",
        "B. 10",
        "C. 12",
        "D. 15",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class WhileContinue {\n public static void main(String[] args) {\n  int num = 0;\n  int sum = 0;\n  while (num < 5) {\n   num++; // num をインクリメント\n   if (num == 3) {\n    continue; // numが3の時は以降をスキップ\n   }\n   sum += num; // 1, 2, 4, 5 が加算される\n  }\n  System.out.println(sum);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`continue` 文は、現在のループの反復処理をそこで中断し、ループの次の反復（条件判定）に進みます。\n- num=0: `while` 条件 `true`。`num` が 1 に。`if(1==3)` `false`。`sum = 0 + 1 = 1`。\n- num=1: `while` 条件 `true`。`num` が 2 に。`if(2==3)` `false`。`sum = 1 + 2 = 3`。\n- num=2: `while` 条件 `true`。`num` が 3 に。`if(3==3)` `true`。`continue` 実行。`sum += num` はスキップ。\n- num=3: `while` 条件 `true`。`num` が 4 に。`if(4==3)` `false`。`sum = 3 + 4 = 7`。\n- num=4: `while` 条件 `true`。`num` が 5 に。`if(5==3)` `false`。`sum = 7 + 5 = 12`。\n- num=5: `while` 条件 `false`。ループ終了。\n最終的な `sum` の値は `12` です。"
    },
    "questionCategory": {
      "en-US": "whileループとcontinue"
    }
  },
  {
    "qid": {
      "en-US": "3-42"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `for` ループ文",
        "B. `if` 文",
        "C. 変数宣言文 (`int x = 5;`)",
        "D. コードブロック (`{ ... }`)",
        "E. `switch` 文"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaにおいて、ラベル（例: `myLabel:`）を直接前に付けることができる構文要素として、 *適切でないもの* を1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaでは、ラベルは主に `break` や `continue` 文と組み合わせて、特定のループや `switch` 文、あるいは任意のコードブロックから抜け出したり、ループの次の反復に進んだりするために使用されます。ラベルは、文（ステートメント）の直前に置くことができます。これには、`for`, `while`, `do-while` ループ文(A)、`if` 文(B)、`switch` 文(E)、コードブロック(D)、式文（代入文、メソッド呼び出しなど）などが含まれます。しかし、変数宣言文自体に直接ラベルを付けることはできません。したがって、Cが適切でないものです。"
    },
    "questionCategory": {
      "en-US": "ラベルを適用できる構文要素"
    }
  },
  {
    "qid": {
      "en-US": "3-43"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 2",
        "B. 4",
        "C. 6",
        "D. 7",
        "E. 9"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class LabelControl {\n public static void main(String[] args) {\n  int counter = 0;\n  outer: for (int i = 0; i < 3; i++) {\n   inner: for (int j = 0; j < 3; j++) {\n    if (i == 1) {\n     continue outer; // i=1 の時、外側ループの次へ\n    }\n    if (j == 2) {\n     break inner; // j=2 の時、内側ループを抜ける\n    }\n    counter++; // i=0, j=0,1 | i=2, j=0,1 で実行\n   }\n  }\n  System.out.println(counter);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "ラベル付き `continue` とラベル付き `break` の動作を理解します。\n- `continue outer;` は、`outer` ラベルが付いた `for` ループ（外側のループ）の現在の反復を中断し、次の反復（`i` のインクリメントと条件判定）に進みます。\n- `break inner;` は、`inner` ラベルが付いた `for` ループ（内側のループ）を終了します。\nトレース:\n- **i = 0**:\n  - j = 0: `if(0==1)` false. `if(0==2)` false. `counter` が 1 に。\n  - j = 1: `if(0==1)` false. `if(1==2)` false. `counter` が 2 に。\n  - j = 2: `if(0==1)` false. `if(2==2)` true. `break inner;` 内側ループ終了。\n- **i = 1**:\n  - `if(1==1)` true. `continue outer;` 外側ループの次の反復へ。\n- **i = 2**:\n  - j = 0: `if(2==1)` false. `if(0==2)` false. `counter` が 3 に。\n  - j = 1: `if(2==1)` false. `if(1==2)` false. `counter` が 4 に。\n  - j = 2: `if(2==1)` false. `if(2==2)` true. `break inner;` 内側ループ終了。\n- **i = 3**: 外側ループの条件 `3 < 3` が `false` で終了。\n最終的な `counter` の値は `4` です。"
    },
    "questionCategory": {
      "en-US": "ラベル付きcontinueとラベル付きbreak"
    }
  },
  {
    "qid": {
      "en-US": "3-44"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "switch 式の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 0",
        "B. 1",
        "C. \"Null Error\"",
        "D. コンパイルエラーが発生する",
        "E. 実行時に `IllegalArgumentException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class SwitchNullTest {\n public static void main(String[] args) {\n  String input = null;\n  try {\n   int result = switch (input) { // input が null\n    case \"A\" -> 1;\n    case \"B\" -> 2;\n    default -> 0;\n   };\n   System.out.println(result);\n  } catch (NullPointerException e) {\n   System.out.println(\"Null Error\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラム（Java 17以降）を実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "Java 17 以降、`switch` 文および `switch` 式のセレクタ式が評価された結果が `null` の場合、`NullPointerException` がスローされるようになりました（以前のバージョンでは `case null:` が必要でした）。このコードでは、`switch (input)` の `input` が `null` なので、`switch` 式を評価しようとした時点で `NullPointerException` が発生します。この例外は `catch` ブロックで捕捉され、\"Null Error\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "switch式とnull入力"
    }
  },
  {
    "qid": {
      "en-US": "3-45"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"X\"",
        "B. \"NULL\"",
        "C. \"Other\"",
        "D. コンパイルエラーが発生する",
        "E. 実行時に `NullPointerException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class SwitchCaseNull {\n public static void main(String[] args) {\n  String value = null;\n  switch (value) {\n   case \"X\": System.out.println(\"X\"); break;\n   case null: System.out.println(\"NULL\"); break; // Java 17 Preview 機能\n   default: System.out.println(\"Other\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムについて、Java 17環境でプレビュー機能を有効にしてコンパイル・実行した場合の結果として最も適切なものを1つ選びなさい。（注: `case null` は標準機能ではありません）"
    },
    "explanation": {
      "en-US": "Java 17 では `switch` のパターンマッチングがプレビュー機能として導入され、その一環として `case null` が許容されるようになりました（ただしプレビュー機能の有効化が必要）。`value` が `null` の場合、`case null:` に直接マッチし、\"NULL\" が表示されて `break` で `switch` 文を抜けます。プレビュー機能を有効にしない場合や、以前のバージョンでは `case null:` はコンパイルエラーになります。また、Java 17標準機能では `switch(null)` は `NullPointerException` をスローします。この問題はプレビュー機能下での動作を問うています。"
    },
    "questionCategory": {
      "en-US": "switch文と case null (Java 17 Preview)"
    }
  },
  {
    "qid": {
      "en-US": "3-46"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Check(0) 0 Check(1) 1 Check(2) 2 \"",
        "B. \"Check(0) 0 Check(1) 1 Check(2) 2 Check(3) \"",
        "C. \"0 1 2 Check(0) Check(1) Check(2) Check(3) \"",
        "D. \"Check(0) Check(1) Check(2) Check(3) 0 1 2 \"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class ForConditionMethod {\n static int limit = 3;\n public static void main(String[] args) {\n  for (int i = 0; checkLimit(i); i++) {\n   System.out.print(i + \" \");\n  }\n }\n static boolean checkLimit(int current) {\n  System.out.print(\"Check(\" + current + \") \");\n  return current < limit;\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`for` ループの条件式 `checkLimit(i)` は、ループの各反復の *前* に評価されます。\n1. `i=0`: `checkLimit(0)` 呼び出し -> \"Check(0) \" 表示、`0 < 3` で `true` 返却。ループ本体実行 -> \"0 \" 表示。\n2. `i=1`: `checkLimit(1)` 呼び出し -> \"Check(1) \" 表示、`1 < 3` で `true` 返却。ループ本体実行 -> \"1 \" 表示。\n3. `i=2`: `checkLimit(2)` 呼び出し -> \"Check(2) \" 表示、`2 < 3` で `true` 返却。ループ本体実行 -> \"2 \" 表示。\n4. `i=3`: `checkLimit(3)` 呼び出し -> \"Check(3) \" 表示、`3 < 3` で `false` 返却。ループ終了。\nしたがって、出力は \"Check(0) 0 Check(1) 1 Check(2) 2 Check(3) \" となります。"
    },
    "questionCategory": {
      "en-US": "forループ条件式でのメソッド呼び出し"
    }
  },
  {
    "qid": {
      "en-US": "3-47"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `[1, 3]`",
        "B. `[1, 2, 3, 4]`",
        "C. `ConcurrentModificationException`",
        "D. `IndexOutOfBoundsException`",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ForEachModify {\n public static void main(String[] args) {\n  List<Integer> nums = new ArrayList<>(List.of(1, 2, 3, 4));\n  try {\n   for (Integer num : nums) {\n    if (num % 2 == 0) {\n     nums.remove(num); // ConcurrentModificationException の原因\n    }\n   }\n   System.out.println(nums);\n  } catch (Exception e) {\n   System.out.println(e.getClass().getSimpleName());\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "拡張 `for` ループ（内部的にイテレータを使用）でコレクションを反復処理している最中に、そのコレクションの構造を変更する（要素を追加または削除する）操作を、イテレータを経由せずに行うと `ConcurrentModificationException` がスローされます。このコードでは、`num` が 2 のときに `nums.remove(num)` が呼び出され、リストの構造が変更されます。その後のループ継続時にこの変更が検出され、例外が発生します。`catch` ブロックで例外クラス名が出力されるため、`ConcurrentModificationException` が表示されます。"
    },
    "questionCategory": {
      "en-US": "拡張forループ中のコレクション変更（再掲類似）"
    }
  },
  {
    "qid": {
      "en-US": "3-48"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"0 1 2 3 \"",
        "B. \"0 1 2 3 4 \"",
        "C. \"1 2 3 4 \"",
        "D. 無限に数字が表示される",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class WhileTrueBreak {\n public static void main(String[] args) {\n  int count = 0;\n  while (true) { // 無限ループ\n   System.out.print(count + \" \");\n   count++;\n   if (count >= 4) {\n    break; // countが4以上になったらループを抜ける\n   }\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`while(true)` は無限ループを作りますが、ループ内部の `if` 文と `break` 文によって特定の条件でループを終了させることができます。\n- count=0: print(0). count=1. if(1>=4) false.\n- count=1: print(1). count=2. if(2>=4) false.\n- count=2: print(2). count=3. if(3>=4) false.\n- count=3: print(3). count=4. if(4>=4) true. `break` 実行。ループ終了。\nしたがって、「0 1 2 3 」が表示されます。"
    },
    "questionCategory": {
      "en-US": "while(true) と break"
    }
  },
  {
    "qid": {
      "en-US": "3-49"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"1 2 4 5 7 8 10 \"",
        "B. \"0 1 2 4 5 7 8 \"",
        "C. \"1 2 3 4 5 6 7 8 9 \"",
        "D. \"1 2 4 5 7 8 \"",
        "E. 無限ループになる"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class WhileContinueSkip {\n public static void main(String[] args) {\n  int i = 0;\n  while (i < 10) {\n   i++; // 先にインクリメント\n   if (i % 3 == 0) { // 3の倍数なら\n    continue; // 以降をスキップして次の反復へ\n   }\n   System.out.print(i + \" \"); // 3の倍数以外を表示\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`continue` は現在の反復処理の残りをスキップし、ループの次の反復（この場合は `while` の条件判定）に進みます。ループ内で `i` が 1 から 10 まで変化します。`if (i % 3 == 0)` が `true` になるのは `i` が 3, 6, 9 のときです。これらの場合 `continue` が実行され、`System.out.print` はスキップされます。それ以外の `i` の値 (1, 2, 4, 5, 7, 8, 10) のときに `System.out.print` が実行されます。したがって、「1 2 4 5 7 8 10 」が表示されます。"
    },
    "questionCategory": {
      "en-US": "whileループとcontinue（条件スキップ）"
    }
  },
  {
    "qid": {
      "en-US": "3-50"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Pass\"",
        "B. \"Fail\"",
        "C. \"true\"",
        "D. コンパイルエラー",
        "E. 実行時エラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class TernaryOperator {\n public static void main(String[] args) {\n  int score = 75;\n  String result = (score >= 60) ? \"Pass\" : \"Fail\";\n  System.out.println(result);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "三項演算子（条件演算子） `?:` は、`条件式 ? trueの場合の値 : falseの場合の値` という形式をとります。条件式 `score >= 60` (つまり `75 >= 60`) は `true` です。したがって、演算子の結果は `:` の前の値、つまり文字列 `\"Pass\"` となります。この値が変数 `result` に代入され、表示されます。"
    },
    "questionCategory": {
      "en-US": "三項演算子 (?:)"
    }
  },
  {
    "qid": {
      "en-US": "3-51"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Grade: A\"",
        "B. \"Grade: B\"",
        "C. \"Grade: C\"",
        "D. \"Grade: D\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class GradeBoundary {\n public static void main(String[] args) {\n  int marks = 80;\n  char grade;\n  if (marks > 90) {\n   grade = 'A';\n  } else if (marks > 80) { // 80 > 80 は false\n   grade = 'B';\n  } else if (marks > 70) { // 80 > 70 は true\n   grade = 'C';\n  } else {\n   grade = 'D';\n  }\n  System.out.println(\"Grade: \" + grade);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`if-else if-else` 構造は上から順に条件が評価され、最初に `true` となったブロックが実行され、残りは無視されます。\n- `marks > 90` (`80 > 90`) は `false`。\n- `marks > 80` (`80 > 80`) は `false`。\n- `marks > 70` (`80 > 70`) は `true`。このブロックが実行され、`grade` に `'C'` が代入されます。\n残りの `else` は実行されません。最終的に \"Grade: C\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "if-else if-else の境界値処理"
    }
  },
  {
    "qid": {
      "en-US": "3-52"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "switch 式の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 1",
        "B. 2",
        "C. 3",
        "D. 0",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class SwitchExpressionArrowValue {\n public static void main(String[] args) {\n  String color = \"Blue\";\n  int code = switch (color) {\n   case \"Red\" -> 1;\n   case \"Green\" -> 2;\n   case \"Blue\" -> 1 + 2; // -> の右辺が式\n   default -> 0;\n  };\n  System.out.println(code);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラム（Java 14以降）を実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`switch` 式のアロー構文 (`->`) の右側には、単一の式、ブロック (`{}` で囲まれた文)、または `throw` 文を記述できます。右側が式の場合、その式の評価結果が `switch` 式の値となります。\n`color` は \"Blue\" なので、`case \"Blue\" -> 1 + 2;` に一致します。右側の式 `1 + 2` が評価され、結果の `3` が `switch` 式の値となります。これが変数 `code` に代入され、表示されます。"
    },
    "questionCategory": {
      "en-US": "switch式のアロー構文（値が式）"
    }
  },
  {
    "qid": {
      "en-US": "3-53"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `break` はループを完全に終了するが、`continue` はメソッドの実行を終了する。",
        "B. `break` は現在の反復をスキップして次の反復に進むが、`continue` はループを完全に終了する。",
        "C. `break` はループを完全に終了するが、`continue` は現在の反復の残りをスキップして次の反復に進む。",
        "D. `break` は `switch` 文でのみ使用でき、`continue` はループ文でのみ使用できる。",
        "E. どちらもループを完全に終了させるが、`break` はラベルと併用できない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "ループ制御文 `break` と `continue` の違いに関する説明として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`break` 文は、それが含まれる最も内側のループ（`for`, `while`, `do-while`）または `switch` 文の実行を直ちに終了させ、制御をその文の次に移します。一方、`continue` 文は、ループ文（`for`, `while`, `do-while`）内でのみ使用でき、現在の反復処理の残りの部分をスキップし、ループの次の反復（条件判定または更新処理）に進みます。Cがこの違いを正しく説明しています。A, Bは役割が逆または不正確。Dは`break`もループで使える。Eは`break`もラベルと併用可能。"
    },
    "questionCategory": {
      "en-US": "breakとcontinueの違い"
    }
  },
  {
    "qid": {
      "en-US": "3-54"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Found: 1*1\" と \"Final result: 1\" が表示される",
        "B. \"Found: 2*3\" と \"Final result: 6\" が表示される",
        "C. \"Found: 3*2\" と \"Final result: 6\" が表示される",
        "D. \"Found: 3*3\" と \"Final result: 9\" が表示される",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class LabeledBreak {\n public static void main(String[] args) {\n  int target = 5;\n  int result = 0;\n  search: // ラベル\n  for (int i = 1; i <= 3; i++) {\n   for (int j = 1; j <= 3; j++) {\n    result = i * j;\n    if (result >= target) {\n     System.out.println(\"Found: \" + i + \"*\" + j);\n     break search; // 外側ループ search を抜ける\n    }\n   }\n  }\n  System.out.println(\"Final result: \" + result);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "ラベル付き `break` 文 `break labelName;` は、`labelName` が付けられたループ文または `switch` 文の実行を終了させます。これにより、ネストされたループの内側から外側のループを直接抜けることができます。\nループは `i` と `j` が 1 から 3 まで変化します。\n- i=1: j=1(r=1), j=2(r=2), j=3(r=3)。`result >= target` は `false`。\n- i=2: j=1(r=2), j=2(r=4)。`result >= target` は `false`。j=3(r=6)。`result >= target` (`6 >= 5`) が `true` になり、「Found: 2*3」が表示され、`break search;` が実行されます。これにより、`search` ラベルが付いた外側の `for` ループ全体が終了します。\nループ終了後、「Final result: 6」（`break` 直前の `result` の値）が表示されます。"
    },
    "questionCategory": {
      "en-US": "ラベル付きbreakによる外側ループ脱出"
    }
  },
  {
    "qid": {
      "en-US": "3-55"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "break、continuneを使用した制御"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. Total: 6",
        "B. Total: 10",
        "C. Total: 15",
        "D. Total: 25",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class LabeledContinue {\n public static void main(String[] args) {\n  int total = 0;\n  outerLoop: // ラベル\n  for (int i = 0; i < 5; i++) {\n   for (int j = 0; j < 5; j++) {\n    if (j >= i) {\n     System.out.print(\"(\" + i + \",\" + j + \") Skip... \");\n     continue outerLoop; // 外側ループの次の反復へ\n    }\n    total++; // j < i の場合のみ実行\n   }\n  }\n  System.out.println(\"\\nTotal: \" + total);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力（最後の Total 行）として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "ラベル付き `continue` 文 `continue labelName;` は、`labelName` が付けられたループ文の現在の反復を中断し、そのループの次の反復（条件判定または更新処理）に進みます。\n`if (j >= i)` が `true` になると、`continue outerLoop;` が実行され、内側ループの残りおよび外側ループの現在の反復の残り（もしあれば）がスキップされ、外側ループの `i++` と条件判定に進みます。`total++` は `j < i` の場合にのみ実行されます。\n- i=0: j=0 で `j>=i` true -> continue outer\n- i=1: j=0 で `j<i` true -> total=1. j=1 で `j>=i` true -> continue outer\n- i=2: j=0 で `j<i` true -> total=2. j=1 で `j<i` true -> total=3. j=2 で `j>=i` true -> continue outer\n- i=3: j=0(t=4), j=1(t=5), j=2(t=6). j=3 で `j>=i` true -> continue outer\n- i=4: j=0(t=7), j=1(t=8), j=2(t=9), j=3(t=10). j=4 で `j>=i` true -> continue outer\nループ終了。最終的な `total` は 10 です。"
    },
    "questionCategory": {
      "en-US": "ラベル付きcontinueによる外側ループ継続"
    }
  },
  {
    "qid": {
      "en-US": "3-56"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "演算子と制御構造"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `true`",
        "B. `false`",
        "C. コンパイルエラー",
        "D. 実行時エラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class BitLogicPrecedence {\n public static void main(String[] args) {\n  int x = 5; // 0101\n  int y = 3; // 0011\n  boolean result = x < y || (x & y) > 1 && x > 0;\n  //              false || (0001) > 1 && true\n  //              false ||   (1)  > 1 && true\n  //              false ||    false   && true\n  //              false ||      false\n  //                  false\n  System.out.println(result);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "演算子の優先順位を考慮して式を評価します。一般的に、算術演算子 > ビット演算子 > 関係演算子 > 論理AND(&&) > 論理OR(||) の順です。\n式: `x < y || (x & y) > 1 && x > 0`\n1. 括弧内のビットAND: `(x & y)` = `(5 & 3)` = `(0101 & 0011)` = `0001` (1)\n2. 関係演算子:\n   - `x < y` = `5 < 3` = `false`\n   - `(x & y) > 1` = `1 > 1` = `false`\n   - `x > 0` = `5 > 0` = `true`\n3. 論理AND (&&):\n   - `false && true` = `false` (&& は || より優先度が高い)\n4. 論理OR (||):\n   - `false || false` = `false`\nしたがって、`result` は `false` となり、`false` が表示されます。"
    },
    "questionCategory": {
      "en-US": "演算子の優先順位（ビット演算子と論理演算子）"
    }
  },
  {
    "qid": {
      "en-US": "3-57"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. コンパイルエラーが発生する",
        "C. コンパイルは成功するが実行時にエラーが発生する",
        "D. コンパイル時に警告が出るが成功する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class DuplicateCase {\n public static void main(String[] args) {\n  final int VAL_A = 1;\n  final int VAL_B = 2;\n  int input = 1;\n  switch (input) {\n   case VAL_A: System.out.println(\"A\"); break;\n   case VAL_B: System.out.println(\"B\"); break;\n   case 1: System.out.println(\"One\"); break; // VAL_A と重複\n   default: System.out.println(\"Other\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルしようとした場合の結果として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`switch` 文の `case` ラベルには、同じ `switch` ブロック内で重複する定数値を使用することはできません。このコードでは、`VAL_A` は `1` という値を持つコンパイル時定数です。9行目の `case 1:` は、7行目の `case VAL_A:` と同じ値 `1` を指定しているため、`case` ラベルの重複となりコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "switch文の重複caseラベル"
    }
  },
  {
    "qid": {
      "en-US": "3-58"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 初期化、条件、更新がないため、コンパイルエラーになる。",
        "B. 条件式がないため、ループ本体は一度も実行されない。",
        "C. 条件式がないため、無限ループとなる（`break`がなければ）。",
        "D. 正常にコンパイル・実行され、「Looping...」が3回表示される。",
        "E. 実行時に `NullPointerException` がスローされる。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class ForEmptyParts {\n public static void main(String[] args) {\n  int count = 0;\n  for ( ; ; ) { // 初期化、条件、更新をすべて省略\n   System.out.println(\"Looping...\");\n   count++;\n   if (count > 2) {\n    break;\n   }\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`for` 文の初期化、条件式、更新処理の各部分は省略可能です。条件式を省略した場合、常に `true` とみなされ、`break` 文などで明示的にループを終了させない限り無限ループになります。このコードでは、`for( ; ; )` は無限ループを意図していますが、ループ内で `count` がインクリメントされ、`count > 2` になった時点で `break` によりループが終了します。A, B は誤り。C は `break` がなければ正しいが、`break` があるので C も不正確。D は表示回数が正しい。最も根本的な説明としてCが適切。"
    },
    "questionCategory": {
      "en-US": "for(;;) の動作"
    }
  },
  {
    "qid": {
      "en-US": "3-59"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "繰り返し文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"List NPE \"",
        "B. \"Array NPE\"",
        "C. \"List NPE Array NPE\"",
        "D. 何も表示されない",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "import java.util.List;\n\npublic class ForEachNullCollection {\n public static void main(String[] args) {\n  List<String> names = null;\n  String[] codes = null;\n  try {\n   for (String name : names) { // names が null\n    System.out.println(name);\n   }\n  } catch (NullPointerException e) {\n   System.out.print(\"List NPE \");\n  }\n  try {\n   for (String code : codes) { // codes が null\n    System.out.println(code);\n   }\n  } catch (NullPointerException e) {\n   System.out.print(\"Array NPE\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "拡張 `for` ループで反復処理を行う対象のコレクションまたは配列が `null` の場合、ループを開始しようとした時点で `NullPointerException` がスローされます。\n- 最初の `try` ブロック: `names` が `null` なので、`for (String name : names)` を実行しようとすると `NullPointerException` が発生します。`catch` ブロックが実行され、「List NPE 」が出力されます。\n- 次の `try` ブロック: `codes` が `null` なので、`for (String code : codes)` を実行しようとすると `NullPointerException` が発生します。`catch` ブロックが実行され、「Array NPE」が出力されます。\nしたがって、最終的な出力は「List NPE Array NPE」となります。"
    },
    "questionCategory": {
      "en-US": "拡張for文と null コレクション/配列"
    }
  },
  {
    "qid": {
      "en-US": "3-60"
    },
    "chapter": {
      "en-US": "3章"
    },
    "category": {
      "en-US": "分岐文の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 0",
        "B. 10",
        "C. コンパイルエラー (比較演算子 == が必要)",
        "D. 実行時エラー",
        "E. true"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class IfAssignment {\n public static void main(String[] args) {\n  boolean isValid = false;\n  int value = 0;\n  if (isValid = true) { // 代入演算子 = を使用\n   value = 10;\n  }\n  System.out.println(value);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`if` 文の条件式には `boolean` 型の値を期待しますが、代入演算子 (`=`) を使用することも構文的には可能です。`isValid = true` という式は、まず変数 `isValid` に `true` を代入し、そして式全体の結果として代入された値 `true` を返します。したがって、`if` 文の条件は `true` と評価され、ブロック内の `value = 10;` が実行されます。最終的に `value` の値 `10` が表示されます。これはよくある間違い（`==` と `=` の混同）ですが、コンパイルエラーにはなりません。"
    },
    "questionCategory": {
      "en-US": "if文の条件式での代入演算子"
    }
  },
  {
    "qid": {
      "en-US": "4-1"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "Javaクラスの定義とインスタンス化とオブジェクトのライフサイクル"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 250",
        "B. 100",
        "C. 0",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Product.java\npublic class Product {\n private int price = 100;\n public void setPrice(int price) {\n  this.price = price;\n }\n public int getPrice() {\n  return this.price;\n }\n}\n\n// Store.java\npublic class Store {\n public static void main(String[] args) {\n  Product p1 = new Product();\n  Product p2 = new Product();\n  p2.setPrice(250);\n  System.out.println(p1.getPrice());\n }\n}"
    },
    "questionText": {
      "en-US": "以下のプログラム（Product.javaとStore.java）をコンパイルし、実行した場合のコンソール出力として適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インスタンス変数 `price` は、`Product` クラスの各インスタンス（`p1` と `p2`）ごとに独立して保持されます。`p1` と `p2` はそれぞれ生成時に `price` が 100 で初期化されます。`p2.setPrice(250)` はインスタンス `p2` の `price` を 250 に変更しますが、インスタンス `p1` の `price` には影響を与えません。そのため、`p1.getPrice()` は `p1` の `price` の値である 100 を返します。"
    },
    "questionCategory": {
      "en-US": "インスタンス変数とメソッドの独立性"
    }
  },
  {
    "qid": {
      "en-US": "4-2"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "Javaクラスの定義とインスタンス化とオブジェクトのライフサイクル"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Java Basics: 300\"",
        "B. \"SQL Intro: 300\"",
        "C. \"Java Basics: 250\"",
        "D. \"SQL Intro: 250\"",
        "E. コンパイルエラーが発生する",
        "F. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Book.java\npublic class Book {\n public String title;\n public int pages;\n public void display() {\n  System.out.println(title + \": \" + pages);\n }\n}\n\n// Library.java\npublic class Library {\n public static void main(String[] args) {\n  Book bookX = new Book();\n  Book bookY = new Book();\n  bookX.title = \"Java Basics\";\n  bookY.pages = 300;\n  bookX.pages = 250;\n  bookY.title = \"SQL Intro\";\n  bookX = bookY; // bookX が bookY と同じオブジェクトを参照\n  bookX.display();\n }\n}"
    },
    "questionText": {
      "en-US": "以下のプログラム（Book.javaとLibrary.java）をコンパイルし、実行した場合のコンソール出力として適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "オブジェクト参照の代入に関する問題です。`bookX = bookY;` の行で、変数 `bookX` はそれまで参照していたオブジェクト（title=\"Java Basics\", pages=250）ではなく、変数 `bookY` が参照しているオブジェクト（title=\"SQL Intro\", pages=300）を指すようになります。したがって、その後の `bookX.display();` は、`bookY` が参照しているオブジェクトの情報を表示するため、「SQL Intro: 300」が出力されます。"
    },
    "questionCategory": {
      "en-US": "オブジェクト参照の再代入"
    }
  },
  {
    "qid": {
      "en-US": "4-3"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "Javaクラスの定義とインスタンス化とオブジェクトのライフサイクル"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `String reference = \"null\";`",
        "B. `Object reference = NULL;`",
        "C. `Object reference = 0;`",
        "D. `Object reference = null;`",
        "E. `var reference;`"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class NullDisplay {\n public static void main(String[] args) {\n  ____________ reference;\n  System.out.println(reference);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、コンソールに文字列「null」と表示させたいと考えています。3行目の空欄 `____________` に入るコードとして、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`System.out.println()` に `null` 値を渡すと、文字列「null」がコンソールに出力されます。`null` はどの参照型変数にも代入できる特別なリテラルです。\nA: 文字列リテラル \"null\" を代入するため、出力は \"null\" ではなく `null`。B: `NULL` はJavaのリテラルではありません。C: `0` は `int` リテラルであり、`Object` に直接代入できません（`Integer` へのオートボクシング後なら可能だが、`null` ではない）。D: 変数 `reference` に `null` 値を代入しており、これが `println` に渡されると「null」が出力されます。E: `var` は初期化が必要なためエラー。"
    },
    "questionCategory": {
      "en-US": "null リテラル"
    }
  },
  {
    "qid": {
      "en-US": "4-4"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "Javaクラスの定義とインスタンス化とオブジェクトのライフサイクル"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. ①で生成されたインスタンスXのみ",
        "B. ②で生成されたインスタンスYのみ",
        "C. ①と②で生成された両方のインスタンス",
        "D. どちらのインスタンスも対象にならない"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class GCTarget {\n public static void main(String[] args) {\n  Object objX = new Object(); // ① インスタンスX生成\n  Object objY = new Object(); // ② インスタンスY生成\n  Object objZ = objX;         // ③ objZ -> インスタンスX\n  objX = null;               // ④ objX -> null\n  objY = null;               // ⑤ objY -> null (インスタンスY参照切れ)\n  // ここでGCが発生すると仮定\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムで5行目の `objY = null;` が実行された直後、ガベージコレクション(GC)が実行された場合に回収対象となる可能性があるインスタンスについて、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "ガベージコレクションの対象となるのは、プログラム中のどの有効な参照変数からも到達不可能になったオブジェクトです。5行目が実行された時点での参照状況を確認します。\n- インスタンスX（①で生成）: 変数 `objX` は `null` を指していますが、変数 `objZ` がインスタンスXを指しています。そのため、インスタンスXはまだ参照されており、GC対象ではありません。\n- インスタンスY（②で生成）: 変数 `objY` が `null` を指すようになり、他にインスタンスYを指す変数はありません。そのため、インスタンスYは到達不可能となり、GCの対象となります。\nしたがって、GC対象となる可能性があるのは②で生成されたインスタンスYのみです。"
    },
    "questionCategory": {
      "en-US": "ガベージコレクションの対象特定"
    }
  },
  {
    "qid": {
      "en-US": "4-5"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "static変数とstaticメソッド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 5",
        "B. 15",
        "C. 25",
        "D. 0",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Counter.java\npublic class Counter {\n static int count = 0; // クラス変数\n}\n\n// App.java\npublic class App {\n public static void main(String[] args) {\n  Counter.count = 5;\n  Counter c1 = new Counter();\n  Counter c2 = new Counter();\n  c1.count = 15;\n  c2.count = 25;\n  System.out.println(Counter.count);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のプログラム（Counter.javaとApp.java）をコンパイルし、実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`static` キーワードが付与されたフィールド（クラス変数）は、そのクラスのすべてのインスタンス間で共有されます。一つのインスタンスを通じて値を変更すると、他のインスタンスからアクセスした場合やクラス名を通じてアクセスした場合もその変更された値が見えます。\n1. `Counter.count = 5;` -> `count` は 5 になります。\n2. `c1.count = 15;` -> 共有されている `count` が 15 になります。\n3. `c2.count = 25;` -> 共有されている `count` が 25 になります。\n4. `System.out.println(Counter.count);` -> 最後に設定された共有値 `25` が表示されます。"
    },
    "questionCategory": {
      "en-US": "staticフィールド（クラス変数）の共有"
    }
  },
  {
    "qid": {
      "en-US": "4-6"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "static変数とstaticメソッド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. インスタンスメソッド内から `static` メソッドを呼び出すことはできない。",
        "B. `static` メソッド内から `static` フィールドにアクセスすることはできない。",
        "C. `static` メソッド内からインスタンスメソッドを（インスタンスを生成せずに）直接呼び出すことはできない。",
        "D. `static` メソッド内からインスタンスフィールドに（インスタンスを生成せずに）直接アクセスすることはできない。",
        "E. インスタンスメソッド内から `static` フィールドにアクセスすることはできない。"
      ]
    },
    "answer": {
      "en-US": [
        2,
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaにおける `static` メンバー（フィールドやメソッド）とインスタンスメンバー（非 `static` なフィールドやメソッド）間のアクセスに関する説明として、正しいものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "アクセスルールのまとめ:\n- **`static` メソッド/ブロック内から:**\n  - 他の `static` メンバー（フィールド、メソッド）には直接アクセス可能。\n  - インスタンスメンバー（非 `static` なフィールド、メソッド）には、特定のインスタンス（オブジェクト参照）を経由しないとアクセスできない（直接アクセス不可）。(C, D が正しい)\n- **インスタンスメソッド/コンストラクタ内から:**\n  - 他のインスタンスメンバー（同じインスタンスの）には直接アクセス可能。\n  - `static` メンバー（フィールド、メソッド）には直接アクセス可能。(A, E は誤り)\nB は誤り（`static` メソッドから `static` フィールドはアクセス可能）。"
    },
    "questionCategory": {
      "en-US": "staticメンバーとインスタンスメンバー間のアクセスルール"
    }
  },
  {
    "qid": {
      "en-US": "4-7"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `sayHello();`",
        "B. `myGreeter.sayHello();`",
        "C. `Greeter.sayHello();`",
        "D. `myGreeter.sayHello;`",
        "E. `new Greeter().sayHello;`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Greeter.java\npublic class Greeter {\n public void sayHello() {\n  System.out.println(\"Hello there!\");\n }\n}\n\n// MainApp.java\npublic class MainApp {\n public static void main(String[] args) {\n  Greeter myGreeter = new Greeter();\n  ___________ // ← greetメソッドを呼び出す\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムで `Greeter` クラスの `sayHello` メソッドを呼び出し、コンソールに「Hello there!」と表示させたいと考えています。`MainApp.java` の4行目の空欄に入るべきコードとして、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インスタンスメソッド（`static` でないメソッド）を呼び出すには、まずそのクラスのインスタンス（オブジェクト）が必要です。`main` メソッド内で `Greeter myGreeter = new Greeter();` によってインスタンスが生成され、変数 `myGreeter` がそれを参照しています。次に、インスタンスを参照している変数（`myGreeter`）とドット演算子 (`.`) を使用してメソッドを呼び出します。メソッド呼び出しにはメソッド名の後に丸括弧 `()` が必要です。したがって、`myGreeter.sayHello();` が正しい呼び出し方です。C は `static` メソッドの呼び出し方（`sayHello` は `static` ではない）。A, D, E は構文エラー。"
    },
    "questionCategory": {
      "en-US": "インスタンスメソッドの正しい呼び出し方"
    }
  },
  {
    "qid": {
      "en-US": "4-8"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. コンパイルは成功するが実行時にエラーが発生する",
        "C. コンパイルエラーが発生する",
        "D. 0.0 が表示される",
        "E. NaN が表示される"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Calculator.java\npublic class Calculator {\n public double multiply(double x, double y) {\n  return x * y;\n }\n}\n\n// Compute.java\npublic class Compute {\n public static void main(String[] args) {\n  Calculator calc = new Calculator();\n  // メソッド呼び出しで引数が1つ足りない\n  System.out.println(calc.multiply(5.0)); // ③\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Calculator.javaとCompute.java）をコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッド呼び出しにおいて、渡される引数の数と型は、メソッド定義で宣言されているパラメータの数と型に一致（または互換性が）する必要があります。`Calculator` クラスの `multiply` メソッドは `double` 型の引数を2つ (`x`, `y`) 要求しています。しかし、`Compute` クラスの③の行では、`calc.multiply(5.0)` のように引数を1つしか渡していません。引数の数が合わないため、コンパイラは適切な `multiply` メソッドを見つけられず、コンパイルエラーを発生させます。"
    },
    "questionCategory": {
      "en-US": "メソッド呼び出し時の引数の不一致"
    }
  },
  {
    "qid": {
      "en-US": "4-9"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `System.out.println(val1);`",
        "B. `if (val1 > 0) { int innerVal = 5; } System.out.println(innerVal);`",
        "C. `System.out.println(msg.length());`",
        "D. `System.out.println(anotherVar);`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        2
      ]
    },
    "code": {
      "en-US": "public class ScopeCheck {\n public static void main(String[] args) {\n  int val1 = 100;\n  String msg = \"Scope\";\n  // ここにコードを挿入\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムの5行目に記述した場合に、コンパイルエラーに *ならない* コードを2つ選択してください。"
    },
    "explanation": {
      "en-US": "ローカル変数は、宣言された場所（スコープ内）でのみアクセス可能です。\n A: `val1` は `main` メソッド内で宣言されており、5行目はそのスコープ内なのでアクセス可能です。\n B: `innerVal` は `if` 文のブロック内で宣言されています。そのブロックの外側である `System.out.println(innerVal);` からはアクセスできないため、コンパイルエラーになります。\n C: `msg` は `main` メソッド内で宣言されており、5行目はそのスコープ内なのでアクセス可能です。\n D: `anotherVar` は宣言されていないため、コンパイルエラーになります。\nしたがって、コンパイルエラーにならないのは A と C です。"
    },
    "questionCategory": {
      "en-US": "ローカル変数のスコープ確認"
    }
  },
  {
    "qid": {
      "en-US": "4-10"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `processData(int data) {}`",
        "B. `String getMessage() return \"Msg\";`",
        "C. `void printResult(result int) {}`",
        "D. `double calculate(int x, int y) { return x / y; }`",
        "E. `void update() throws Exception;`"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaにおけるメソッド宣言の記述として、構文的に正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッド宣言の基本構文は `[修飾子] 戻り値の型 メソッド名([パラメータリスト]) [throws 例外リスト] { メソッド本体 }` です。\nA: 戻り値の型が指定されていません。\nB: メソッド本体を囲む波括弧 `{}` がなく、`return` 文の記述位置も不適切です。\nC: パラメータ宣言は `型 変数名` の順序です (`int result`)。\nD: 戻り値の型 `double`、メソッド名 `calculate`、パラメータリスト `(int x, int y)`、本体 `{ return x / y; }`。`x / y` は `int` ですが `double` に暗黙変換されるため、構文的に正しいです。\nE: 通常のメソッド宣言には本体 `{}` が必要です（インターフェースのデフォルトメソッドや抽象クラスの抽象メソッドでない場合）。"
    },
    "questionCategory": {
      "en-US": "メソッド宣言の構文規則"
    }
  },
  {
    "qid": {
      "en-US": "4-11"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. ①の行でコンパイルエラーが発生する",
        "C. ②の行でコンパイルエラーが発生する（コメントアウトされているが）",
        "D. コンパイルは成功するが、実行時に `NullPointerException` が発生する",
        "E. コンパイルは成功するが、実行時に `ClassCastException` が発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Configurator.java\npublic class Configurator {\n private String setting;\n // 戻り値がない (void) メソッド\n public void configure(String setting) {\n  this.setting = setting;\n  System.out.println(\"Configured: \" + setting);\n }\n public String getSetting() { return this.setting; }\n}\n\n// AppSetup.java\npublic class AppSetup {\n public static void main(String[] args) {\n  Configurator cfg = new Configurator();\n  // voidメソッドの結果を変数に入れようとしている\n  String result = cfg.configure(\"Mode A\"); // ①\n  // System.out.println(result); // ②\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Configurator.javaとAppSetup.java）をコンパイルしようとした場合の結果について、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "`Configurator` クラスの `configure` メソッドは、戻り値の型が `void` と宣言されています。これは、このメソッドが呼び出し元に値を返さないことを意味します。`AppSetup` クラスの `main` メソッド内の①の行 `String result = cfg.configure(\"Mode A\");` では、値を返さない `void` メソッドの呼び出し結果を、`String` 型の変数 `result` に代入しようとしています。これは型が不適合であるため、コンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "void メソッドの戻り値を受け取ろうとするエラー"
    }
  },
  {
    "qid": {
      "en-US": "4-12"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `int`",
        "B. `long`",
        "C. `float`",
        "D. `double`",
        "E. `Long`",
        "F. `Object`"
      ]
    },
    "answer": {
      "en-US": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    "code": {
      "en-US": "// MathUtil.java\npublic class MathUtil {\n // long 型の値を返すメソッド\n long square(int x) {\n  return (long)x * x;\n }\n}\n\n// Calculation.java\npublic class Calculation {\n public static void main(String[] args) {\n  MathUtil util = new MathUtil();\n  // squareメソッドの戻り値(long)を受け取る\n  _________ squaredValue = util.square(5);\n  System.out.println(squaredValue);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（MathUtil.javaとCalculation.java）において、`squaredValue` 変数の型として空欄 `_________` に記述できるものを5つ選択してください。"
    },
    "explanation": {
      "en-US": "`MathUtil` クラスの `square` メソッドは `long` 型の値を返します。この戻り値を受け取る変数 `squaredValue` の型は、`long` 型自身であるか、`long` 型からの拡大変換が可能な型（`float`, `double`）、またはラッパークラス (`Long`) やスーパータイプ (`Object`) である必要があります。\n A: `int` は `long` より狭い型なので、明示的なキャストなしでは代入できずエラー。\n B: `long` は戻り値と同じ型なのでOK。\n C: `float` は `long` からの拡大変換が可能なのでOK。\n D: `double` は `long` からの拡大変換が可能なのでOK。\n E: `Long` は `long` のラッパークラスであり、オートボクシングにより代入可能なのでOK。\n F: `Object` はすべてのクラスのスーパータイプなのでOK。\nしたがって、適切なのは B, C, D, E, F の5つです。"
    },
    "questionCategory": {
      "en-US": "メソッドの戻り値の型と代入互換性"
    }
  },
  {
    "qid": {
      "en-US": "4-13"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. コンパイルは成功するが実行時にエラー",
        "C. コンパイルエラーが発生する",
        "D. \"Warning\" が1回表示される"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Printer.java\npublic class Printer {\n public void printMessage(String msg, int times) {\n  for (int i = 0; i < times; i++) {\n   System.out.println(msg);\n  }\n }\n}\n\n// Display.java\npublic class Display {\n public static void main(String[] args) {\n  Printer p = new Printer();\n  // 引数を省略してメソッド呼び出し\n  p.printMessage(\"Warning\"); // ②\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Printer.javaとDisplay.java）をコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`Printer` クラスの `printMessage` メソッドは `String` 型と `int` 型の2つの引数を取るように定義されています。しかし、`Display` クラスの `main` メソッド内の②の行では、`String` 型の引数 \"Warning\" のみを渡しており、2番目の `int` 型の引数が省略されています。メソッド呼び出し時に必要な引数が足りないため、コンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "メソッド呼び出し時の引数の省略エラー"
    }
  },
  {
    "qid": {
      "en-US": "4-14"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `void process(String... names, int count)`",
        "B. `void calculate(int... values...)`",
        "C. `void handle(String... data)`",
        "D. `void setup(int... params, String... options)`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaにおけるメソッドの可変長引数（varargs）を使用したパラメータ宣言として、構文的に正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "可変長引数（varargs）を使用する際のルール:\n1. 可変長引数は `型... 変数名` の形式で宣言します。\n2. 1つのメソッドのパラメータリストにおいて、可変長引数は *1つだけ* 宣言できます。\n3. 可変長引数を宣言する場合、それはパラメータリストの *最後* になければなりません。\nA: 可変長引数 `names` が最後のパラメータではないため誤り。\nB: `...` が2回使われており誤り。\nC: 正しい形式で、最後のパラメータとして宣言されています。正しい。\nD: 可変長引数が2つ宣言されており誤り。\nしたがって、正しいのは C のみです。"
    },
    "questionCategory": {
      "en-US": "可変長引数 (varargs) のルール"
    }
  },
  {
    "qid": {
      "en-US": "4-15"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. 実行時に \"Checked\" が表示されないだけでエラーにはならない",
        "C. コンパイルエラー（到達不能コード）が発生する",
        "D. コンパイル時に警告が出るが成功する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class Unreachable {\n public String checkStatus(int code) {\n  if (code == 0) {\n   return \"OK\";\n  }\n  return \"Error\"; // このreturnでメソッドは終了\n  // System.out.println(\"Checked\"); // ③ 到達不能\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムについて、コメントアウトされている③の行のコメントを外した場合のコンパイル結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`return` 文はメソッドの実行を終了し、呼び出し元に制御を（場合によっては値を）返します。`checkStatus` メソッドでは、`if (code == 0)` が `true` であれ `false` であれ、6行目の `return \\\"Error\\\";` の前に必ず `return` 文（3行目または6行目）が実行されます。そのため、6行目の `return` 文より後の文（コメントアウトされている③の行）には、プログラムの制御が到達することが絶対にありません。Javaコンパイラはこのような到達不能コード (unreachable code) を検出し、コンパイルエラーとして報告します。"
    },
    "questionCategory": {
      "en-US": "到達不能コード (unreachable code)"
    }
  },
  {
    "qid": {
      "en-US": "4-16"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドのオーバーロード"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public void execute(int id)`",
        "B. `public int execute(int taskID, String param)`",
        "C. `public void execute(String param, int taskID)`",
        "D. `public void execute(int taskNum, String value)`",
        "E. `public void execute()`"
      ]
    },
    "answer": {
      "en-US": [
        1,
        3
      ]
    },
    "code": {
      "en-US": "// 基準メソッド\npublic void execute(int taskID, String param) {\n // ...\n}"
    },
    "questionText": {
      "en-US": "このの基準メソッド `execute` をオーバーロード *していない* メソッド定義を、以下の選択肢から2つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッドのオーバーロードは、メソッド名が同じであり、かつパラメータリスト（パラメータの型、数、または順序）が異なる場合に成立します。戻り値の型やパラメータ名はオーバーロードの条件には影響しません。\n基準メソッドのパラメータリストは `(int, String)` です。\n A: パラメータリスト `(int)`。異なるのでオーバーロード。\n B: パラメータリスト `(int, String)`。同じなのでオーバーロードではない（戻り値違いは不可）。\n C: パラメータリスト `(String, int)`。順序が異なるのでオーバーロード。\n D: パラメータリスト `(int, String)`。パラメータ名は違いますが型と順序は同じなのでオーバーロードではない。\n E: パラメータリスト `()`。異なるのでオーバーロード。\nしたがって、オーバーロードしていないのは B と D です。"
    },
    "questionCategory": {
      "en-US": "メソッドオーバーロードの条件（引数リスト）"
    }
  },
  {
    "qid": {
      "en-US": "4-17"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドのオーバーロード"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされ、実行時に「Long/Int」が表示される",
        "B. 正常にコンパイルされ、実行時に「Int/Long」が表示される",
        "C. ①の行でコンパイルエラーが発生する（呼び出しが曖昧）",
        "D. ②または③のどちらかでコンパイルエラーが発生する",
        "E. コンパイルは成功するが実行時にエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class OverloadAmbiguity {\n public static void main(String[] args) {\n  OverloadAmbiguity oa = new OverloadAmbiguity();\n  oa.process(10, 20); // ① int, int で呼び出し\n }\n // メソッド候補\n void process(long a, int b) { System.out.println(\"Long/Int\"); } // ②\n void process(int a, long b) { System.out.println(\"Int/Long\"); } // ③\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッドのオーバーロード解決において、コンパイラは呼び出し時の引数に最も適合するメソッドを選択しようとします。①の呼び出し `oa.process(10, 20)` の引数は `(int, int)` です。\n- メソッド② `process(long a, int b)` を呼び出すには、第1引数 `10` を `int` から `long` へ拡大変換する必要があります（変換コスト1）。\n- メソッド③ `process(int a, long b)` を呼び出すには、第2引数 `20` を `int` から `long` へ拡大変換する必要があります（変換コスト1）。\nどちらのメソッドも引数1つの拡大変換で呼び出し可能であり、コンパイラにとってどちらが「より適しているか」を判断する基準がありません。このような状況を「呼び出しが曖昧 (ambiguous)」であるといい、コンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "オーバーロード解決の曖昧性"
    }
  },
  {
    "qid": {
      "en-US": "4-18"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドのオーバーロード"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public int calculate(int x)`",
        "B. `private int calculate(int value)`",
        "C. `int calculate(double x)`",
        "D. `double calculate(int x)`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// 基準メソッド\nint calculate(int x) {\n return x * x;\n}"
    },
    "questionText": {
      "en-US": "このの基準メソッド `calculate` を *オーバーロードする* メソッド定義として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッドのオーバーロードは、メソッド名が同じで、パラメータリスト（型、数、順序）が異なる場合に成立します。アクセス修飾子や戻り値の型はオーバーロードの条件ではありません。\n基準メソッドのパラメータリストは `(int)` です。\nA: パラメータリスト `(int)`。同じなのでオーバーロードではない。\nB: パラメータリスト `(int)`。同じなのでオーバーロードではない。\nC: パラメータリスト `(double)`。異なるのでオーバーロード。\nD: パラメータリスト `(int)`。同じなのでオーバーロードではない（戻り値が違うだけでは不可）。\nしたがって、オーバーロードするのは C です。"
    },
    "questionCategory": {
      "en-US": "オーバーロードとアクセス修飾子/戻り値"
    }
  },
  {
    "qid": {
      "en-US": "4-19"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public` のみが許可される。",
        "B. `public` または `protected` のみが許可される。",
        "C. `public`, `protected`, `private`, またはアクセス修飾子なし（パッケージプライベート）のいずれも使用できる。",
        "D. アクセス修飾子を使用することはできない。",
        "E. `private` のみが許可される。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "あるクラス `Widget` を定義する際に、そのコンストラクタに適用できるアクセス修飾子に関する説明として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "クラスのコンストラクタも、通常のメソッドと同様に、アクセス修飾子（`public`, `protected`, デフォルト（修飾子なし、パッケージプライベート）、`private`）で修飾することができます。どのアクセス修飾子を適用するかによって、そのコンストラクタを呼び出してインスタンスを生成できる範囲（他のクラスやパッケージからの可視性）が決まります。アクセス修飾子の種類に特別な制限はありません。"
    },
    "questionCategory": {
      "en-US": "コンストラクタに適用可能なアクセス修飾子"
    }
  },
  {
    "qid": {
      "en-US": "4-20"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Method called\"",
        "B. \"Method called\" が2回表示される",
        "C. 何も表示されない",
        "D. `Report` クラスでコンパイルエラー",
        "E. `Generator` クラスでコンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// Report.java\npublic class Report {\n // これはコンストラクタではない (戻り値 void がある)\n void Report() { // ①\n  System.out.println(\"Method called\");\n }\n}\n\n// Generator.java\npublic class Generator {\n public static void main(String[] args) {\n  Report r = new Report(); // ② デフォルトコンストラクタ\n  r.Report(); // ③ 通常メソッド呼び出し\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Report.javaとGenerator.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "コンストラクタは、クラス名と同じ名前を持ち、かつ戻り値の型（`void` も含む）を持ちません。`Report` クラスの① `void Report()` は、戻り値の型 `void` を持っているため、コンストラクタではなく、`Report` という名前の通常のインスタンスメソッドとして扱われます。\n`Generator` クラスの② `new Report()` では、`Report` クラスにプログラマ定義のコンストラクタがないため、引数なしのデフォルトコンストラクタがコンパイラによって自動的に生成され、それが呼び出されます（この時点では何も出力されません）。\n③ `r.Report();` では、①で定義された通常のインスタンスメソッド `Report()` が呼び出され、「Method called」がコンソールに出力されます。"
    },
    "questionCategory": {
      "en-US": "コンストラクタと通常メソッドの識別"
    }
  },
  {
    "qid": {
      "en-US": "4-21"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Constructor InitBlock \"",
        "B. \"InitBlock Constructor \"",
        "C. \"Constructor \"",
        "D. \"InitBlock \"",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// InitializerOrder.java\npublic class InitializerOrder {\n {\n  System.out.print(\"InitBlock \"); // ② 初期化子\n }\n InitializerOrder() { // ① コンストラクタ\n  System.out.print(\"Constructor \");\n }\n}\n\n// TestInit.java\npublic class TestInit {\n public static void main(String[] args) {\n  InitializerOrder obj = new InitializerOrder(); // ③\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（InitializerOrder.javaとTestInit.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "クラスのインスタンスが生成される際、実行順序は以下のようになります:\n1. スーパークラスのコンストラクタ（明示的または暗黙的に呼び出される）\n2. インスタンス変数の初期化とインスタンス初期化ブロック（定義された順に実行される）\n3. コンストラクタ本体の実行\nこのコードでは、インスタンス初期化ブロック（②）がまず実行され、「InitBlock 」が出力されます。次に、コンストラクタ（①）が実行され、「Constructor 」が出力されます。したがって、最終的な出力は「InitBlock Constructor 」となります。"
    },
    "questionCategory": {
      "en-US": "インスタンス初期化子とコンストラクタの実行順序"
    }
  },
  {
    "qid": {
      "en-US": "4-22"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "static変数とstaticメソッド"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"S1:S2:\"",
        "B. \"S1:S2:I1:C1:\"",
        "C. \"S1:S2:S1:S2:I1:C1:\"",
        "D. \"S1:I1:S2:C1:\""
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// SequenceDemo.java\npublic class SequenceDemo {\n static String log = \"S1:\"; // ① Staticフィールド初期化\n {\n  log += \"I1:\"; // ② インスタンス初期化子\n }\n static {\n  log += \"S2:\"; // ③ Static初期化子\n }\n public SequenceDemo() {\n  log += \"C1:\"; // ④ コンストラクタ\n }\n}\n\n// ExecuteSequence.java\npublic class ExecuteSequence {\n public static void main(String[] args) {\n  System.out.print(SequenceDemo.log); // ⑤\n  SequenceDemo sd = new SequenceDemo(); // ⑥\n  System.out.print(SequenceDemo.log); // ⑦\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（SequenceDemo.javaとExecuteSequence.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaクラスの初期化とインスタンス化の実行順序:\n1. **クラスロード時（最初にクラスが参照されたとき）:**\n   - `static` フィールドの初期化（① `log = \"S1:\"`）\n   - `static` 初期化ブロックの実行（③ `log += \"S2:\"` -> `log` は `\"S1:S2:\"`）\n2. **インスタンス生成時 (`new SequenceDemo()`)**\n   - インスタンス初期化子の実行（② `log += \"I1:\"` -> `log` は `\"S1:S2:I1:\"`）\n   - コンストラクタ本体の実行（④ `log += \"C1:\"` -> `log` は `\"S1:S2:I1:C1:\"`）\n実行の流れ:\n- ⑤ `System.out.print(SequenceDemo.log);`: クラスロードが発生し、`static` 初期化が完了。`\"S1:S2:\"` が出力される。\n- ⑥ `SequenceDemo sd = new SequenceDemo();`: インスタンス生成が行われ、インスタンス初期化子とコンストラクタが実行される。`log` は `\"S1:S2:I1:C1:\"` に更新される。\n- ⑦ `System.out.print(SequenceDemo.log);`: 更新された `log` の値 `\"S1:S2:I1:C1:\"` が出力される。\nしたがって、最終的な出力は `S1:S2:S1:S2:I1:C1:` となります。"
    },
    "questionCategory": {
      "en-US": "static変数、初期化ブロック、コンストラクタ実行順序"
    }
  },
  {
    "qid": {
      "en-US": "4-23"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. `DataHolder` クラスでコンパイルエラー",
        "C. `AppMain` クラスでコンパイルエラー",
        "D. コンパイルは成功するが実行時にエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// DataHolder.java\npublic class DataHolder {\n // 引数ありコンストラクタのみ定義\n public DataHolder(String data) { // ②\n  System.out.println(\"Data: \" + data);\n }\n // ① 戻り値あり -> 通常メソッド\n String DataHolder() {\n  return \"Method\";\n }\n}\n\n// AppMain.java\npublic class AppMain {\n public static void main(String[] args) {\n  // 引数なしコンストラクタを呼び出し試行\n  DataHolder dh = new DataHolder(); // ③\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（DataHolder.javaとAppMain.java）をコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaコンパイラは、クラス内にプログラマが *一つも* コンストラクタを定義しなかった場合に限り、引数なしのデフォルトコンストラクタを自動的に生成します。`DataHolder` クラスには、②のように引数ありのコンストラクタ `DataHolder(String data)` が定義されています。そのため、コンパイラはデフォルトコンストラクタを生成しません。`AppMain` クラスの③の行では、引数なしのコンストラクタ `new DataHolder()` を呼び出そうとしていますが、該当するコンストラクタが存在しないため、コンパイルエラーが発生します。①は戻り値があるため通常のメソッドであり、コンストラクタではありません。"
    },
    "questionCategory": {
      "en-US": "デフォルトコンストラクタの自動生成条件"
    }
  },
  {
    "qid": {
      "en-US": "4-24"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Widget(name, 1);`",
        "B. `super(name, 1);`",
        "C. `this(name, 1);`",
        "D. `new Widget(name, 1);`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Widget.java\npublic class Widget {\n private String name;\n private int version;\n\n public Widget(String name, int version) { // ③ 基底コンストラクタ\n  this.name = name; this.version = version;\n  System.out.println(\"Widget created!\");\n }\n public Widget(String name) { // ①\n  // ここで③を呼び出したい\n  ____________ // ← 空欄\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Widget` クラスのコンストラクタ①からコンストラクタ③を呼び出し、「Widget created!」と表示させたいと考えています。空欄 `____________` に入れるべきコードとして正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "あるコンストラクタから同じクラスの別のコンストラクタを呼び出すには、`this(...)` 構文を使用します。呼び出したいコンストラクタの引数リストに一致する引数を `this` の括弧内に指定します。この呼び出しは、コンストラクタ本体の *最初の* 文でなければなりません。コンストラクタ③ `Widget(String name, int version)` を呼び出すには、`String` と `int` の引数を渡す必要があります。例えば、デフォルトバージョンとして 1 を使うなら `this(name, 1);` と記述します。A はメソッド呼び出しの形式、B はスーパークラスのコンストラクタ呼び出し、D は新しいインスタンス生成であり、目的と異なります。"
    },
    "questionCategory": {
      "en-US": "コンストラクタからのthis(...)呼び出し"
    }
  },
  {
    "qid": {
      "en-US": "4-25"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. `Box` クラスでコンパイルエラー",
        "C. `Packer` クラスでコンパイルエラー",
        "D. コンパイルは成功するが実行時にエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Box.java\npublic class Box {\n public Box(String label) { // ③\n  System.out.println(\"Label: \" + label);\n }\n public Box() { // ①\n  System.out.println(\"Creating Box...\");\n  this(\"Default\"); // ② this()呼び出しが最初でない\n }\n}\n\n// Packer.java\npublic class Packer {\n public static void main(String[] args) {\n  Box b = new Box();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Box.javaとPacker.java）をコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "コンストラクタ内から `this(...)` を使って同じクラスの別のコンストラクタを呼び出す場合、その `this(...)` 呼び出しはコンストラクタ本体の *必ず最初の文* でなければなりません。`Box` クラスの引数なしコンストラクタ①では、`System.out.println` の後に `this(\"Default\")` が記述されています（②）。これはルール違反であるため、`Box` クラスのこの箇所でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "this(...)呼び出しの位置制約"
    }
  },
  {
    "qid": {
      "en-US": "4-26"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "アクセス修飾子の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. `displayValue` メソッド内の `println` でコンパイルエラー",
        "C. `main` メソッド内の `println` でコンパイルエラー",
        "D. 両方の `println` でコンパイルエラー",
        "E. コンパイルは成功するが実行時にエラー"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "// com/base/BaseClass.java\npackage com.base;\npublic class BaseClass {\n int value = 100; // デフォルトアクセス\n}\n\n// com/derived/DerivedClass.java\npackage com.derived;\nimport com.base.BaseClass;\n\npublic class DerivedClass extends BaseClass {\n public void displayValue() {\n  // System.out.println(value); // ← アクセス試行\n }\n public static void main(String[] args) {\n  DerivedClass d = new DerivedClass();\n  // System.out.println(d.value); // ← アクセス試行\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム構成（BaseClassとDerivedClassが異なるパッケージ）において、`DerivedClass` 内のコメントアウトされた行のコメントを外した場合のコンパイル結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "アクセス修飾子が指定されていないメンバー（フィールドやメソッド）は、デフォルトアクセス（パッケージプライベート）となります。これは、そのメンバーが宣言されたクラスと同じパッケージに属するクラスからのみアクセス可能であることを意味します。`BaseClass` の `value` フィールドは `com.base` パッケージでデフォルトアクセスとして宣言されています。`DerivedClass` は `com.derived` という異なるパッケージに属しています。したがって、`DerivedClass` からは、たとえ `BaseClass` を継承していても、デフォルトアクセスの `value` フィールドに直接アクセスすることはできません。`displayValue` メソッド内 (`this.value` または単に `value`) でも、`main` メソッド内 (`d.value`) でもアクセスは許可されず、どちらの行でもコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "デフォルト（パッケージプライベート）アクセス"
    }
  },
  {
    "qid": {
      "en-US": "4-27"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "アクセス修飾子の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. コンパイルエラーが発生する",
        "B. \"ID: null\" と表示される",
        "C. \"ID: AB123\" と表示される",
        "D. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// com/library/Media.java\npackage com.library;\npublic class Media {\n private String id;\n public void setId(String id) { this.id = id; }\n protected void displayId() { // protected メソッド\n  System.out.println(\"ID: \" + id);\n }\n}\n\n// com/app/AudioBook.java\npackage com.app;\nimport com.library.Media;\npublic class AudioBook extends Media {}\n\n// com/app/MainPlayer.java\npackage com.app;\n// import com.library.Media; // 不要\npublic class MainPlayer {\n public static void main(String[] args) {\n  AudioBook ab = new AudioBook();\n  ab.setId(\"AB123\"); // public なので OK\n  ab.displayId(); // ② サブクラス経由で protected 呼び出し\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Media.java, AudioBook.java, MainPlayer.java）をコンパイルし、実行した場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`protected` メンバーは、同じパッケージ内のクラス、または異なるパッケージであってもそのクラスを継承したサブクラスからアクセス可能です。`Media` クラスの `displayId` メソッドは `protected` です。`MainPlayer` クラスは `Media` とは異なるパッケージ (`com.app`) にありますが、`AudioBook` は `Media` のサブクラスです。`MainPlayer` の `main` メソッド内で、`AudioBook` のインスタンス `ab` を通じて `displayId()` を呼び出すことは許可されています（サブクラスのインスタンス経由でのアクセス）。`setId` メソッドは `public` なので問題なく呼び出せます。したがって、プログラムは正常にコンパイル・実行され、設定された ID \"AB123\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "protected アクセス（異なるパッケージのサブクラス）"
    }
  },
  {
    "qid": {
      "en-US": "4-28"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 50",
        "B. 150",
        "C. 100",
        "D. コンパイルエラー",
        "E. 実行時エラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// DataModifier.java\npublic class DataModifier {\n int dataValue;\n public DataModifier(int val) { this.dataValue = val; }\n}\n\n// MainProcess.java\npublic class MainProcess {\n public static void main(String[] args) {\n  DataModifier dm = new DataModifier(50);\n  updateValue(dm.dataValue); // ① プリミティブ値(50)を渡す\n  System.out.println(dm.dataValue); // ③\n }\n // 渡された値のコピーを変更するメソッド\n private static void updateValue(int val) { // ②\n  val = val + 100;\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（DataModifier.javaとMainProcess.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Java では、メソッドにプリミティブ型（`int`, `double`, `boolean` など）の値を渡す場合、「値渡し」が行われます。これは、メソッドに渡されるのが元の変数の値の *コピー* であることを意味します。①の `updateValue(dm.dataValue)` では、`dm.dataValue` の値である `50` のコピーが `updateValue` メソッドのパラメータ `val`（②）に渡されます。メソッド内で `val` の値が `val + 100` （つまり 150）に変更されても、それはコピーに対する変更であり、呼び出し元の `dm.dataValue` の値には影響しません。したがって、③の `println` では元の値 `50` が表示されます。"
    },
    "questionCategory": {
      "en-US": "メソッド呼び出し（プリミティブ型の値渡し）"
    }
  },
  {
    "qid": {
      "en-US": "4-29"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 20",
        "B. 60",
        "C. 0",
        "D. コンパイルエラー",
        "E. 実行時エラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Config.java\npublic class Config {\n int settingValue;\n public Config(int val) { this.settingValue = val; }\n}\n\n// Setup.java\npublic class Setup {\n public static void main(String[] args) {\n  Config cfg = new Config(20);\n  changeSetting(cfg); // ① オブジェクト参照を渡す\n  System.out.println(cfg.settingValue); // ③\n }\n // 渡された参照を通じてオブジェクトの状態を変更\n private static void changeSetting(Config c) { // ②\n  c.settingValue = c.settingValue * 3;\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Config.javaとSetup.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Java でメソッドにオブジェクト（参照型）を渡す場合、渡されるのはそのオブジェクトへの参照（メモリ上のアドレスのようなもの）のコピーです。メソッド内でその参照（のコピー）を通じてオブジェクトのフィールド（状態）を変更すると、呼び出し元が持っている参照が指すオブジェクトも同じように変更されます。\n① `changeSetting(cfg)` では、`cfg` が参照する `Config` オブジェクトへの参照が `changeSetting` メソッドのパラメータ `c`（②）に渡されます。メソッド内で `c.settingValue = c.settingValue * 3;` が実行されると、`cfg` が参照するオブジェクトの `settingValue` が `20 * 3 = 60` に変更されます。したがって、③の `println` では変更後の値 `60` が表示されます。"
    },
    "questionCategory": {
      "en-US": "メソッド呼び出し（参照型の参照渡し）"
    }
  },
  {
    "qid": {
      "en-US": "4-30"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "instance of のパターン・マッチング"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `instanceof` の右側に指定した型への明示的なキャストが、ブロック内で別途必要になる。",
        "B. 型チェックが `true` の場合、指定した変数名（`text` や `num`）で、キャストされたオブジェクトをその `if` ブロック内（特定のスコープ）で利用できる。",
        "C. パターン変数（`text` や `num`）は、`if` 文の外側でも常に利用可能である。",
        "D. この機能は `String` 型と `Integer` 型にのみ限定されている。",
        "E. `instanceof` の右辺にはクラス型しか指定できず、インターフェース型は指定できない。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public void processObject(Object data) {\n if (data instanceof String text) {\n  // ① text は String 型として使える\n  System.out.println(\"Length: \" + text.length());\n } else if (data instanceof Integer num) {\n  // ② num は Integer 型として使える\n  System.out.println(\"Value: \" + num.intValue());\n } else {\n  System.out.println(\"Unknown type\");\n }\n}"
    },
    "questionText": {
      "en-US": "こののコードで使用されている `instanceof` 演算子のパターンマッチング機能に関する説明として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`instanceof` 演算子のパターンマッチング（Java 16 で正式導入）は、型チェックと条件付きキャストおよび変数束縛を簡潔に行うための機能です。`if (data instanceof String text)` のように記述すると、`data` が `String` のインスタンスであれば、`data` を `String` にキャストした結果が新しい変数 `text` に代入され、その `if` ブロック（正確には `text` が明確に代入されるフローのスコープ）内で `text` を `String` 型として安全に使用できます（①、②）。明示的なキャストは不要です(A誤)。変数のスコープは限定されます(C誤)。任意の型（クラス、インターフェース）に対して使用できます(D, E誤)。したがって、Bが最も適切な説明です。"
    },
    "questionCategory": {
      "en-US": "instanceof パターンマッチングの基本"
    }
  },
  {
    "qid": {
      "en-US": "4-31"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. レコードは不変（immutable）なデータキャリアとして設計されている。",
        "B. レコード宣言で指定したコンポーネントに対応する `private final` なフィールドが自動的に生成される。",
        "C. レコードは他のクラスを継承（`extends`）することができる。",
        "D. 各コンポーネントに対する公開アクセサ（getter）メソッドが自動的に生成される。",
        "E. `equals()`, `hashCode()`, `toString()` メソッドが自動的に生成される。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java のレコード (Record) に関する説明として、 *誤っている* ものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードは、データ保持を目的とした特殊なクラスです。A, B, D, E はレコードの正しい性質です。レコードは不変であり、コンポーネントに対応する `private final` フィールド、公開アクセサメソッド、および `equals`, `hashCode`, `toString` が自動生成されます。しかし、レコードは暗黙的に `java.lang.Record` クラスを継承しており、Java では多重継承が許されていないため、他のクラスを明示的に `extends` することはできません。したがって、Cが誤った説明です。"
    },
    "questionCategory": {
      "en-US": "レコード (Record) の基本的な性質"
    }
  },
  {
    "qid": {
      "en-US": "4-32"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public`",
        "B. `protected`",
        "C. `private`",
        "D. アクセス修飾子なし（パッケージプライベート）",
        "E. `static`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "ソースファイルのトップレベルで（他のクラスやインターフェースにネストされずに）レコードを宣言する場合に、使用可能なアクセス修飾子を2つ選択してください。"
    },
    "explanation": {
      "en-US": "トップレベルで宣言されるレコード（またはクラス、インターフェース）に適用できるアクセス修飾子は、`public` またはアクセス修飾子なし（パッケージプライベート）の2種類のみです。`public` を指定すると、どのパッケージからでもアクセス可能になります。アクセス修飾子を省略すると、同じパッケージ内のクラスからのみアクセス可能になります。`protected` や `private` はトップレベルの宣言には使用できません。`static` はトップレベル宣言のアクセス修飾子ではありません（ネストされた型には使えます）。"
    },
    "questionCategory": {
      "en-US": "トップレベルレコードのアクセス修飾子"
    }
  },
  {
    "qid": {
      "en-US": "4-33"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Point p = Point.create(10, 20);`",
        "B. `Point p = new Point(); p.x=10; p.y=20;`",
        "C. `Point p = {10, 20};`",
        "D. `Point p = new Point(10, 20);`"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public record Point(int x, int y) {}"
    },
    "questionText": {
      "en-US": "このの `Point` レコードのインスタンスを生成するための正しいコードを、以下の選択肢から1つ選びなさい。"
    },
    "explanation": {
      "en-US": "レコードのインスタンスを生成するには、通常のクラスと同様に `new` 演算子とコンストラクタを使用します。レコードを宣言すると、そのコンポーネントリストに対応する引数を持つ「正規コンストラクタ (canonical constructor)」が自動的に生成されます。この例では `Point(int x, int y)` というコンストラクタが生成されるため、`new Point(10, 20)` のようにしてインスタンスを生成します。Aのようなファクトリメソッドは自動生成されません。Bはレコードが不変でありフィールドが `final` なため不可。Cは配列初期化子の構文です。"
    },
    "questionCategory": {
      "en-US": "レコードのインスタンス化方法"
    }
  },
  {
    "qid": {
      "en-US": "4-34"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 他のコンストラクタ（正規コンストラクタ以外）",
        "B. インスタンスメソッド",
        "C. `static` メソッド",
        "D. `static final` フィールド",
        "E. インスタンスフィールド（`static` でないフィールド）"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java のレコード (Record) の本体 `{}` 内に宣言することが *できない* ものを、以下の選択肢から1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードは主に不変なデータを保持するために設計されており、その状態はレコード宣言時に指定されたコンポーネントによって定義されます。これらのコンポーネントに対応する `private final` なインスタンスフィールドが暗黙的に生成されます。レコードの本体には、追加のコンストラクタ(A)、インスタンスメソッド(B)、`static` メソッド(C)、`static` フィールド(D)、ネストされた型などを宣言できます。しかし、レコードの不変性を維持するため、宣言されたコンポーネント以外のインスタンスフィールド（非 `static` なフィールド）を追加で宣言することは禁止されています(E)。"
    },
    "questionCategory": {
      "en-US": "レコードに宣言できないメンバー"
    }
  },
  {
    "qid": {
      "en-US": "4-35"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `user.getUsername()`",
        "B. `user.username`",
        "C. `user.username()`",
        "D. `User.username(user)`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public record User(int id, String username) {}\n\n// 利用コード\nUser user = new User(101, \"guest\");\nString name = ________ ; // username を取得したい"
    },
    "questionText": {
      "en-US": "このの `User` レコードのインスタンス `user` から `username` コンポーネントの値を取得するための正しいコードを、空欄 `________` に入れるものとして1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードを宣言すると、各コンポーネント（この場合は `id` と `username`）に対して、そのコンポーネント名と同じ名前を持つ公開アクセサ（public accessor）メソッドが自動的に生成されます。例えば、`username` コンポーネントに対しては `public String username()` というメソッドが生成されます。したがって、`username` の値を取得するには `user.username()` を呼び出します。Aの `getUsername()` はJavaBeansの命名規則であり、レコードでは生成されません。Bはフィールドが `private` なため直接アクセスできません。Dは不正な構文です。"
    },
    "questionCategory": {
      "en-US": "レコードコンポーネントへのアクセス方法"
    }
  },
  {
    "qid": {
      "en-US": "4-36"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. レコードには引数なしコンストラクタを定義できないため。",
        "B. 追加コンストラクタ（①）の最初の文で、他のコンストラクタ（通常は正規コンストラクタ）を `this(...)` を使って呼び出していないため。",
        "C. 追加コンストラクタ（①）内で `key` フィールドと `value` フィールドを初期化していないため。",
        "D. レコードのコンストラクタは `private` でなければならないため。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public record Config(String key, String value) {\n // 引数なしコンストラクタを追加したい\n public Config() { // ① 追加コンストラクタ\n  // ② this(...) 呼び出しが必要\n  System.out.println(\"Default config created.\");\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Config` レコードの定義はコンパイルエラーとなります。その主な理由として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードにおいて、正規コンストラクタ（すべてのコンポーネントを引数に取るコンストラクタ）以外に追加のコンストラクタを宣言する場合、その追加コンストラクタの本体の *最初の文* で、必ず `this(...)` を使用して同じクラスの別のコンストラクタを呼び出さなければなりません。これは、最終的に正規コンストラクタが呼び出され、すべての `final` なインスタンスフィールドが確実に初期化されることを保証するためです。このコードの引数なしコンストラクタ①には `this(...)` 呼び出しがないため、コンパイルエラーとなります。A, C, D は誤りです。"
    },
    "questionCategory": {
      "en-US": "レコードの追加コンストラクタにおけるthis()呼び出し義務"
    }
  },
  {
    "qid": {
      "en-US": "4-37"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. public のみが使用可能である",
        "B. protected と private は使用できない",
        "C. アクセス修飾子なし（パッケージプライベート）のみ使用可能である",
        "D. public, protected, private, アクセス修飾子なしのいずれも使用可能である",
        "E. アクセス修飾子を使用することはできない"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "record Setting(String key, boolean enabled) {\n // 追加コンストラクタを定義する\n}"
    },
    "questionText": {
      "en-US": "このの `Setting` レコードに、プログラマが明示的にコンストラクタを追加する場合、そのコンストラクタに適用可能なアクセス修飾子について、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードに追加で定義するコンストラクタ（正規コンストラクタ以外や明示的に定義する正規コンストラクタ）も、通常のクラスのコンストラクタと同様に、アクセス修飾子でその可視性を制御できます。使用できるアクセス修飾子は `public`, `protected`, デフォルト（修飾子なし）、`private` のいずれも可能です。"
    },
    "questionCategory": {
      "en-US": "レコードコンストラクタのアクセスレベル"
    }
  },
  {
    "qid": {
      "en-US": "4-38"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `super();`",
        "B. `this.title = \"Unknown\"; this.pages = 0;`",
        "C. `this(\"Unknown\", 0);`",
        "D. `BookInfo(\"Unknown\", 0);`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public record BookInfo(String title, int pages) {\n // 引数なしコンストラクタを追加\n public BookInfo() { // ①\n  // ② ここにコードを挿入してエラー解消\n }\n}"
    },
    "questionText": {
      "en-US": "このの `BookInfo` レコードは、コンパイルエラーとなります。エラーを解消するために②の箇所に挿入すべきコードとして、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードで正規コンストラクタ以外に追加のコンストラクタ（①）を定義する場合、その最初の文で必ず他のコンストラクタを `this(...)` を使って呼び出さなければなりません。これは、最終的に全フィールドが初期化される正規コンストラクタ `BookInfo(String title, int pages)` に処理を委譲するためです。選択肢Cの `this(\"Unknown\", 0);` は、`String` と `int` を引数に取り、正規コンストラクタを呼び出す正しい形式です。"
    },
    "questionCategory": {
      "en-US": "レコードの追加コンストラクタからのthis()呼び出し"
    }
  },
  {
    "qid": {
      "en-US": "4-39"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Validating... \"",
        "B. \"Validating... Alice\"",
        "C. \"Alice\"",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// UserData.java\npublic record UserData(String name) {\n public UserData { // ① コンパクトコンストラクタ\n  System.out.print(\"Validating... \");\n  if (name == null || name.isBlank()) {\n   throw new IllegalArgumentException(\"Name is required\");\n  }\n  // ② 暗黙的に this.name = name; が実行される\n }\n}\n\n// App.java\npublic class App {\n public static void main(String[] args) {\n  UserData user = new UserData(\"Alice\"); // ③\n  System.out.print(user.name()); // ④\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（UserData.javaとApp.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードのコンパクトコンストラクタ（①、引数リストがない形式）は、正規コンストラクタの本体が実行される *前* に実行され、主に引数の検証や正規化を行います。③でインスタンスが生成される際、まずコンパクトコンストラクタが実行され、「Validating... 」が出力されます。検証（nullチェックなど）が行われ、問題なければ暗黙的に正規コンストラクタのフィールド代入処理（②）が実行されます。その後、④でアクセサメソッド `user.name()` が呼び出され、「Alice」が出力されます。したがって、最終的な出力は「Validating... Alice」となります。"
    },
    "questionCategory": {
      "en-US": "レコードのコンパクトコンストラクタの動作"
    }
  },
  {
    "qid": {
      "en-US": "4-40"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルでき、`item.print()` は \"Interface Print\" を返す。",
        "B. 正常にコンパイルでき、`item.print()` は \"Record Print\" を返す。",
        "C. `ItemData` レコードの定義でコンパイルエラーが発生する。",
        "D. コンパイルは成功するが、`item.print()` 呼び出し時に実行時エラーが発生する。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Printable.java\npublic interface Printable {\n default String print() { // デフォルトメソッド\n  return \"Interface Print\";\n }\n}\n\n// ItemData.java\n// レコードは print() アクセサを自動生成\npublic record ItemData(String print) implements Printable {}\n\n// MainPrint.java\npublic class MainPrint {\n public static void main(String[] args) {\n  ItemData item = new ItemData(\"Record Print\");\n  // item.print(); // ← 呼び出し試行\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム構成において、`ItemData` レコードの定義に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコード `ItemData(String print)` は、コンポーネント名 `print` に対応するアクセサメソッド `public String print()` を自動的に生成します。一方で、実装しているインターフェース `Printable` にも同名のデフォルトメソッド `default String print()` が存在します。レコードは、自身が（暗黙的に）生成するメソッド（アクセサ、`equals`, `hashCode`, `toString`）と同じシグネチャを持つメソッドをスーパークラスやインターフェースから継承することはできません。この場合、`print()` メソッドが衝突するため、`ItemData` レコードの定義自体がコンパイルエラーとなります。"
    },
    "questionCategory": {
      "en-US": "レコードのアクセサメソッドとインターフェースメソッドの衝突"
    }
  },
  {
    "qid": {
      "en-US": "4-41"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "static変数とstaticメソッド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイル、実行できる。",
        "B. コンパイルエラーが発生する。",
        "C. コンパイルは成功するが、実行時に `NullPointerException` が発生する。",
        "D. コンパイルは成功するが、実行時に `IllegalAccessException` が発生する。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class StaticContext {\n int instanceVar = 10;\n\n public void instanceMethod() {\n  System.out.println(\"Instance method called\");\n }\n\n public static void staticMethod() {\n  System.out.println(\"Static method called\");\n  // instanceMethod(); // ← NG\n  // System.out.println(instanceVar); // ← NG\n }\n\n public static void main(String[] args) {\n  staticMethod();\n }\n}"
    },
    "questionText": {
      "en-US": "このの `StaticContext` クラスについて、`staticMethod` 内のコメントアウトされた行のコメントを外した場合に発生する事象として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`static` メソッド (`staticMethod`) は特定のインスタンスに属さずにクラスに直接属します。一方、インスタンスメソッド (`instanceMethod`) やインスタンス変数 (`instanceVar`) は特定のインスタンスが存在しないと利用できません。`static` メソッド内からインスタンスメンバーに直接アクセスしようとすると、どのインスタンスのメンバーを指しているのか特定できないため、コンパイルエラーとなります。アクセスするには、まず `StaticContext` のインスタンスを生成し、そのインスタンス経由で呼び出す必要があります（例: `StaticContext obj = new StaticContext(); obj.instanceMethod();`）。"
    },
    "questionCategory": {
      "en-US": "staticメソッドからインスタンスメソッドの直接呼び出し不可"
    }
  },
  {
    "qid": {
      "en-US": "4-42"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "Javaクラスの定義とインスタンス化とオブジェクトのライフサイクル"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. コンパイルエラーが発生する",
        "B. \"\", 0",
        "C. \"null, 0\"",
        "D. 実行時に `NullPointerException` が発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Car.java\npublic class Car {\n String model;\n int year;\n // コンストラクタは定義されていない\n}\n\n// Garage.java\npublic class Garage {\n public static void main(String[] args) {\n  Car myCar = new Car(); // デフォルトコンストラクタ呼び出し\n  System.out.println(myCar.model + \", \" + myCar.year);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Car.javaとGarage.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`Car` クラスにはプログラマが定義したコンストラクタがありません。この場合、Javaコンパイラが引数なしのデフォルトコンストラクタを自動的に生成します。`new Car()` はこのデフォルトコンストラクタを呼び出します。デフォルトコンストラクタは、フィールドをそれぞれの型のデフォルト値で初期化します。参照型（`String`）のデフォルト値は `null`、プリミティブ数値型（`int`）のデフォルト値は `0` です。したがって、`myCar.model` は `null`、`myCar.year` は `0` となり、「null, 0」が表示されます。"
    },
    "questionCategory": {
      "en-US": "デフォルトコンストラクタの呼び出し"
    }
  },
  {
    "qid": {
      "en-US": "4-43"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "アクセス修飾子の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 継承 (Inheritance)",
        "B. ポリモーフィズム (Polymorphism)",
        "C. カプセル化 (Encapsulation)",
        "D. 抽象化 (Abstraction)"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class Employee {\n private String name;\n private int salary;\n\n public String getName() { return name; }\n public void setName(String name) { this.name = name; }\n public int getSalary() { return salary; }\n public void setSalary(int salary) {\n  if (salary >= 0) { this.salary = salary; }\n }\n // mainメソッドなどでの利用を想定\n}"
    },
    "questionText": {
      "en-US": "このの `Employee` クラスのように、フィールドを `private` にし、それらにアクセスするための `public` なメソッド（getter/setter）を提供する設計原則を何と呼びますか。"
    },
    "explanation": {
      "en-US": "カプセル化は、オブジェクト指向プログラミングの原則の一つで、データ（フィールド）とそのデータを操作するメソッドを一つの単位（クラス）にまとめ、内部の詳細を外部から隠蔽することを目指します。フィールドを `private` にして直接アクセスを禁止し、代わりに `public` な getter メソッド（値の取得）と setter メソッド（値の設定、検証ロジックを含む場合もある）を通じてアクセスを制御するのは、カプセル化の典型的な実装方法です。"
    },
    "questionCategory": {
      "en-US": "カプセル化（privateフィールドとpublic getter/setter）"
    }
  },
  {
    "qid": {
      "en-US": "4-44"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドのオーバーロード"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. メソッドオーバーライド。①はString版、②はint版が実行される。",
        "B. メソッドオーバーロード。①はString版、②はint版が実行される。",
        "C. メソッド隠蔽。①はString版、②はint版が実行される。",
        "D. メソッドオーバーロード。どちらの呼び出しもString版が実行される。",
        "E. コンパイルエラー（同じ名前のメソッドは定義できない）。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class DisplayUtil {\n public void show(String message) {\n  System.out.println(\"Text: \" + message);\n }\n public void show(int number) {\n  System.out.println(\"Number: \" + number);\n }\n public static void main(String[] args) {\n  DisplayUtil du = new DisplayUtil();\n  du.show(\"Hello\"); // ①\n  du.show(123);    // ②\n }\n}"
    },
    "questionText": {
      "en-US": "このの `DisplayUtil` クラスには `show` という名前のメソッドが2つ定義されています。この状況を何と呼びますか。また、①と②の呼び出しでそれぞれどちらのメソッドが実行されますか。"
    },
    "explanation": {
      "en-US": "同じクラス内で、メソッド名は同じでもパラメータリスト（型、数、順序）が異なるメソッドを複数定義することをメソッドオーバーロードと呼びます。このコードでは、`show(String)` と `show(int)` があり、これはオーバーロードの例です。①の `du.show(\"Hello\")` は引数が `String` なので `show(String message)` が呼び出されます。②の `du.show(123)` は引数が `int` なので `show(int number)` が呼び出されます。"
    },
    "questionCategory": {
      "en-US": "メソッドオーバーロードの基本的な例"
    }
  },
  {
    "qid": {
      "en-US": "4-45"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `name`",
        "B. `this.name`",
        "C. `ItemData.name`",
        "D. `super.name`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class ItemData {\n private String name;\n\n public void setName(String name) {\n  // フィールドのnameに引数のnameを代入\n  ________ = name; // ← 空欄\n }\n\n public String getName() {\n  return name;\n }\n}"
    },
    "questionText": {
      "en-US": "このの `setName` メソッド内で、引数として受け取った `name` の値を、クラスのインスタンスフィールド `name` に代入したいと考えています。空欄 `________` に記述すべき正しいコードを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッドのパラメータ名（ローカル変数）とインスタンスフィールド名が同じ場合、メソッド内で単に `name` と書くと、スコープのルールによりローカル変数であるパラメータの方を指してしまいます。インスタンスフィールドの方を明示的に指すには、現在のインスタンス自身を参照する `this` キーワードを使って `this.name` と記述します。したがって、`this.name = name;` とすることで、フィールド `this.name` にパラメータ `name` の値を代入できます。"
    },
    "questionCategory": {
      "en-US": "thisキーワードによるフィールドアクセス"
    }
  },
  {
    "qid": {
      "en-US": "4-46"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "Javaクラスの定義とインスタンス化とオブジェクトのライフサイクル"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `main` メソッドからまだ参照されているため、GC対象ではない。",
        "B. `static` メソッド内で生成されたため、プログラム終了までGC対象にならない。",
        "C. メソッド内のローカル変数 `sb` のスコープが終了し、他に参照がなければGCの対象となりうる。",
        "D. オブジェクトは自動的に破棄され、メモリが即座に解放される。",
        "E. `System.gc()` が呼び出されたため、確実にGCされる。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class LifecycleDemo {\n public static void main(String[] args) {\n  createAndUseObject(); // メソッド呼び出し\n  // createAndUseObject 終了後、obj はGC対象になりうる\n  System.gc(); // GCを試みる (保証はない)\n  System.out.println(\"Main finished\");\n }\n\n public static void createAndUseObject() {\n  StringBuilder sb = new StringBuilder(\"Temporary\"); // ①\n  System.out.println(\"Inside method: \" + sb);\n  // メソッド終了時、ローカル変数 sb はスコープ外になる\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムについて、`createAndUseObject` メソッドが終了した後の、①で生成された `StringBuilder` オブジェクトの状態として最も適切な説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッド内で生成され、そのメソッドのローカル変数（例: `sb`）のみから参照されているオブジェクトは、メソッドの実行が終了すると、そのローカル変数がスコープ外になります。他にそのオブジェクトへの参照がなければ、そのオブジェクトは到達不可能となり、ガベージコレクション(GC)の対象となります。GCがいつ実行されるかはJVMに依存しますが、対象にはなりえます(C)。A: `main` から直接参照されていません。B: `static` メソッド内での生成は関係ありません。D: JavaのGCは自動ですが、即座に解放される保証はありません。E: `System.gc()` はGCの実行を依頼するヒントであり、実行を保証するものではありません。"
    },
    "questionCategory": {
      "en-US": "オブジェクトの到達可能性とGC (メソッドローカル)"
    }
  },
  {
    "qid": {
      "en-US": "4-47"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "static変数とstaticメソッド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. ③ → ① → ② → ②",
        "B. ① → ③ → ② → ②",
        "C. ③ → ② → ① → ②",
        "D. ③ → ② → ② → ①",
        "E. ① → ② → ③ → ②"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class StaticInit {\n static {\n  System.out.println(\"Static block executed\"); // ①\n }\n\n public StaticInit() {\n  System.out.println(\"Constructor executed\"); // ②\n }\n\n public static void main(String[] args) {\n  System.out.println(\"Main method started\"); // ③\n  StaticInit obj1 = new StaticInit(); // ④\n  StaticInit obj2 = new StaticInit(); // ⑤\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力の順序として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`static` 初期化ブロック（① `static { ... }`）は、そのクラスがJVMにロードされ、初期化されるときに *一度だけ* 実行されます。これは通常、そのクラスが初めて参照されたとき（例: `main` メソッドの開始前や、最初のインスタンス生成時など）に起こります。コンストラクタ（②）は、`new` 演算子を使ってインスタンスが生成される *たびに* 実行されます。\n実行順序:\n1. クラス `StaticInit` がロードされ、`static` 初期化ブロック①が実行される -> \"Static block executed\"\n2. `main` メソッド③が開始される -> \"Main method started\"\n3. 最初のインスタンス生成④: コンストラクタ②が実行される -> \"Constructor executed\"\n4. 2番目のインスタンス生成⑤: コンストラクタ②が実行される -> \"Constructor executed\"\nしたがって、出力順は B の「① → ③ → ② → ②」に対応します。"
    },
    "questionCategory": {
      "en-US": "static初期化ブロックの実行タイミング"
    }
  },
  {
    "qid": {
      "en-US": "4-48"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "アクセス修飾子の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Sub` からのアクセスのみ可能。",
        "B. `Other` からのアクセスのみ可能。",
        "C. `Sub` と `Other` の両方からアクセス可能。",
        "D. どちらのクラスからもアクセスできず、コンパイルエラーになる。",
        "E. `Base` クラス内からしかアクセスできない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// mypackage/Base.java\npackage mypackage;\npublic class Base {\n protected int protectedVar = 10;\n}\n\n// mypackage/Sub.java\npackage mypackage;\npublic class Sub extends Base {\n public void accessBase() {\n  System.out.println(protectedVar); // サブクラスからアクセス\n }\n}\n\n// mypackage/Other.java\npackage mypackage;\npublic class Other {\n public void accessBaseFromOther() {\n  Base b = new Base();\n  System.out.println(b.protectedVar); // 同一パッケージの別クラスから\n }\n}"
    },
    "questionText": {
      "en-US": "こののクラス `Base`, `Sub`, `Other` はすべて同じ `mypackage` に属しています。`protectedVar` へのアクセスに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`protected` アクセス修飾子が付いたメンバーは、以下の範囲からアクセス可能です:\n1. そのメンバーが宣言されたクラス自身。\n2. 同じパッケージに属する他のクラス。\n3. 異なるパッケージに属していても、そのクラスを継承したサブクラス（特定の条件下で）。\nこのケースでは、`Base`, `Sub`, `Other` はすべて同じパッケージ `mypackage` に属しています。したがって、`Base` の `protected` メンバー `protectedVar` には、サブクラスである `Sub` からも、同じパッケージの別のクラスである `Other` からもアクセスすることができます。よってCが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "protected アクセス（同一パッケージ）"
    }
  },
  {
    "qid": {
      "en-US": "4-49"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "instance of のパターン・マッチング"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"true,false,false,true\"",
        "B. \"true,false,true,true\"",
        "C. \"true,true,false,true\"",
        "D. \"false,false,false,true\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class InstanceOfCheck {\n public static void main(String[] args) {\n  Object obj1 = \"Test String\";\n  Object obj2 = Integer.valueOf(100);\n  Object obj3 = null;\n\n  boolean r1 = obj1 instanceof String; // ①\n  boolean r2 = obj2 instanceof String; // ②\n  boolean r3 = obj3 instanceof String; // ③\n  boolean r4 = obj1 instanceof Object; // ④\n\n  System.out.println(r1 + \",\" + r2 + \",\" + r3 + \",\" + r4);\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`instanceof` 演算子は、左辺のオブジェクト参照が、右辺で指定された型（クラス、インターフェース、配列型）のインスタンスであるかどうかを判定します。\n① `obj1` (\"Test String\") は `String` のインスタンスなので `true`。\n② `obj2` (Integer 100) は `String` のインスタンスではないので `false`。\n③ `instanceof` の左辺が `null` の場合、結果は常に `false`。\n④ `obj1` (\"Test String\") は `String` であり、`String` は `Object` のサブクラスなので、`Object` のインスタンスでもある。`true`。\nしたがって、出力は \"true,false,false,true\" となります。"
    },
    "questionCategory": {
      "en-US": "instanceof 演算子の基本"
    }
  },
  {
    "qid": {
      "en-US": "4-50"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Coordinate[x=1.5, y=-2.0]`",
        "B. `(1.5, -2.0)`",
        "C. `Coordinate@` に続くハッシュコード",
        "D. `x=1.5,y=-2.0`",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public record Coordinate(double x, double y) {}\n\npublic class RecordToString {\n public static void main(String[] args) {\n  Coordinate point = new Coordinate(1.5, -2.0);\n  System.out.println(point);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行した場合のコンソール出力として、最も適切な形式を1つ選択してください。"
    },
    "explanation": {
      "en-US": "レコードを宣言すると、コンパイラは自動的に `toString()` メソッドを生成します。この自動生成される `toString()` は、レコード名と、各コンポーネントの名前と値を `[ ]` で囲んだ形式の文字列表現を返します。例えば、`Coordinate(double x, double y)` レコードの場合、`toString()` は `Coordinate[x=値, y=値]` のような形式になります。したがって、`System.out.println(point)` はこの形式の文字列を出力します。選択肢Aが最も近い形式です。"
    },
    "questionCategory": {
      "en-US": "レコードの自動生成 toString()"
    }
  },
  {
    "qid": {
      "en-US": "4-51"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Admin,5\" と \"Guest,5\"",
        "B. \"Admin,1\" と \"Guest,1\"",
        "C. \"Admin,1\" と \"Guest,5\"",
        "D. \"Admin,0\" と \"Guest,5\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class UserProfile {\n String username;\n int level;\n\n public UserProfile(String username) {\n  this(username, 1); // 他のコンストラクタを呼び出す\n }\n\n public UserProfile(String username, int level) {\n  this.username = username;\n  this.level = level;\n }\n\n public static void main(String[] args) {\n  UserProfile user1 = new UserProfile(\"Admin\");\n  UserProfile user2 = new UserProfile(\"Guest\", 5);\n  System.out.println(user1.username + \",\" + user1.level);\n  System.out.println(user2.username + \",\" + user2.level);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "コンストラクタのオーバーロードと `this()` 呼び出しの例です。\n- `user1 = new UserProfile(\"Admin\")`: `String` 引数を1つ取るコンストラクタが呼び出されます。このコンストラクタは `this(\"Admin\", 1)` によって `String` と `int` を引数に取るコンストラクタを呼び出します。結果、`user1` の `username` は \"Admin\"、`level` は 1 になります。\n- `user2 = new UserProfile(\"Guest\", 5)`: `String` と `int` を引数に取るコンストラクタが直接呼び出され、`user2` の `username` は \"Guest\"、`level` は 5 になります。\nしたがって、出力は「Admin,1」と「Guest,5」になります。"
    },
    "questionCategory": {
      "en-US": "コンストラクタのオーバーロード"
    }
  },
  {
    "qid": {
      "en-US": "4-52"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "static変数とstaticメソッド"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. シングルトンパターン (Singleton Pattern)",
        "B. ファクトリメソッドパターン (Factory Method Pattern)",
        "C. ビルダーパターン (Builder Pattern)",
        "D. プロトタイプパターン (Prototype Pattern)"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class Connection {\n private String url;\n // コンストラクタは private\n private Connection(String url) {\n  this.url = url;\n  System.out.println(\"Connected to \" + url);\n }\n\n // インスタンスを生成して返す static メソッド\n public static Connection create(String targetUrl) {\n  // ここで事前チェックなど可能\n  return new Connection(targetUrl);\n }\n\n public static void main(String[] args) {\n  Connection conn1 = Connection.create(\"db://local\");\n  // Connection conn2 = new Connection(\"db://remote\"); // コンパイルエラー\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Connection` クラスのように、コンストラクタを `private` にし、代わりにインスタンスを生成して返す `public static` なメソッド（例: `create`）を提供する設計パターンを何と呼びますか。"
    },
    "explanation": {
      "en-US": "コンストラクタを直接呼び出す代わりに、インスタンス生成専用の `static` メソッドを提供するパターンは、一般に「static ファクトリメソッド」と呼ばれます。これは GoF のデザインパターンの「ファクトリメソッドパターン」とは少し異なりますが、関連する概念です。コンストラクタを `private` にすることで、インスタンス生成の方法をクラス自身が完全に制御できるようになり、例えば生成前にパラメータを検証したり、特定の条件下で既存のインスタンスを再利用（キャッシュ）したりする柔軟性が生まれます。シングルトンパターンは通常、インスタンスが1つしか存在しないことを保証しますが、このコードは必ずしもそうではありません。ビルダーは複雑なオブジェクト生成、プロトタイプはコピーによる生成に使われます。"
    },
    "questionCategory": {
      "en-US": "static ファクトリメソッド"
    }
  },
  {
    "qid": {
      "en-US": "4-53"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `final` フィールドは必ず宣言と同時に初期化しなければならない。",
        "B. `final` フィールドの値は、オブジェクト生成後でも setter メソッドを使えば変更できる。",
        "C. `final` フィールドは、宣言時またはコンストラクタ内で一度だけ初期化する必要があり、その後は変更できない。",
        "D. `final` フィールドは `static` でなければならない。",
        "E. `final` フィールドは `private` にできない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class ConfigData {\n private final String configKey; // final フィールド\n private String configValue;\n\n public ConfigData(String key, String value) {\n  this.configKey = key; // コンストラクタで初期化\n  this.configValue = value;\n }\n\n public void updateValue(String newValue) {\n  // this.configKey = \"newKey\"; // コンパイルエラー\n  this.configValue = newValue;\n }\n}"
    },
    "questionText": {
      "en-US": "`final` キーワードが付いたインスタンスフィールド（例: `configKey`）に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`final` キーワードが付いたインスタンスフィールドは「定数フィールド」となり、一度値が代入されると、その後は変更することができません。初期化は、フィールド宣言時、またはすべてのコンストラクタが完了するまでに行う必要があります。一度初期化されると、再代入しようとするとコンパイルエラーになります(B誤)。宣言時の初期化は必須ではありません(A誤)。`final` は `static` ともインスタンスフィールドとも組み合わせ可能です(D誤)。アクセス修飾子とも組み合わせ可能です(E誤)。したがって、Cが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "final フィールドの初期化"
    }
  },
  {
    "qid": {
      "en-US": "4-54"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 10",
        "B. 20",
        "C. 30",
        "D. コンパイルエラー",
        "E. 実行時エラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Holder.java\nclass Holder { int value; }\n\npublic class RefReassign {\n public static void main(String[] args) {\n  Holder h = new Holder();\n  h.value = 10;\n  modifyReference(h);\n  System.out.println(h.value);\n }\n\n static void modifyReference(Holder refParam) {\n  refParam.value = 20; // 呼び出し元のオブジェクトの状態を変更\n  refParam = new Holder(); // パラメータ変数に新しい参照を代入\n  refParam.value = 30;\n  // この変更は呼び出し元の変数 h には影響しない\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "メソッドに参照型の変数を渡すと、その参照（アドレスのようなもの）のコピーが渡されます。\n1. `modifyReference(h)` が呼び出され、`refParam` は `h` と同じ `Holder` オブジェクトを指します。\n2. `refParam.value = 20;` により、`h` が指すオブジェクトの `value` が 20 に変更されます。\n3. `refParam = new Holder();` により、ローカル変数 `refParam` は *新しく作成された* 別の `Holder` オブジェクトを指すようになります。呼び出し元の変数 `h` が指すオブジェクトは変わりません。\n4. `refParam.value = 30;` は、新しく作成されたオブジェクトの `value` を 30 に変更します。\nメソッド終了後、`main` メソッドの `h` は依然として最初に作成され、`value` が 20 に変更されたオブジェクトを指しています。したがって、`System.out.println(h.value)` は 20 を表示します。"
    },
    "questionCategory": {
      "en-US": "メソッド引数（参照型）の再代入"
    }
  },
  {
    "qid": {
      "en-US": "4-55"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされ、`r` の値が 200 に変更される。",
        "B. コンパイルエラーが発生する（フィールドに直接アクセスできない）。",
        "C. コンパイルエラーが発生する（`final` フィールドには再代入できない）。",
        "D. コンパイルは成功するが、実行時にエラーが発生する。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public record Color(int r, int g, int b) {}\n\npublic class RecordImmutability {\n public static void main(String[] args) {\n  Color red = new Color(255, 0, 0);\n  // red.r = 200; // コンパイルエラーになるか？\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Color` レコードのインスタンス `red` に対して、コメントアウトされた行 `red.r = 200;` のコメントを外した場合、どのような結果になりますか。"
    },
    "explanation": {
      "en-US": "レコードのコンポーネント（`r`, `g`, `b`）に対応するインスタンスフィールドは、暗黙的に `private` かつ `final` として宣言されます。`final` フィールドは一度初期化されると再代入できません。また、`private` であるため、レコードの外部から直接アクセスすることもできません（アクセサメソッド `r()` 経由で値を取得します）。`red.r = 200;` は、`final` フィールドへの再代入であり、かつ `private` フィールドへの直接アクセスでもあるため、コンパイルエラーが発生します。主な理由は `final` フィールドへの再代入不可です。"
    },
    "questionCategory": {
      "en-US": "レコードの不変性"
    }
  },
  {
    "qid": {
      "en-US": "4-56"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "instance of のパターン・マッチング"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `else` ブロック内でもパターン変数 `s` を使用できる。",
        "B. `else` ブロック内でパターン変数 `s` を使用しようとするとコンパイルエラーになる。",
        "C. `else` ブロックが実行される場合、パターン変数 `s` は `null` になる。",
        "D. `if` 文全体を `switch` 式で書き換える必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class PatternMatchingElse {\n public static void process(Object obj) {\n  if (obj instanceof String s) {\n   System.out.println(\"String: \" + s.toUpperCase());\n  } else {\n   // ここで変数 s は使えるか？\n   // System.out.println(\"Not a String: \" + s);\n   System.out.println(\"Not a String\");\n  }\n }\n public static void main(String[] args) {\n  process(123);\n }\n}"
    },
    "questionText": {
      "en-US": "このの `process` メソッド内の `else` ブロックに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`instanceof` パターンマッチングで宣言されたパターン変数（例: `s`）のスコープは、その型チェックが `true` であることが保証される範囲に限定されます。`if (obj instanceof String s)` の場合、変数 `s` は `if` ブロック内でのみ有効です。`else` ブロックは `obj` が `String` では *ない* 場合に実行されるため、`else` ブロック内では変数 `s` はスコープ外となり、参照しようとするとコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "instanceof パターンマッチングと else ブロック"
    }
  },
  {
    "qid": {
      "en-US": "4-57"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "static変数とstaticメソッド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 指定されたクラスのすべてのメンバー（static およびインスタンス）をインポートする。",
        "B. 指定されたクラスの `public static` なメンバー（フィールドやメソッド）を、クラス名を省略してアクセスできるようにする。",
        "C. `static` な内部クラスのみをインポートするために使用される。",
        "D. `java.lang` パッケージのクラスに対してのみ使用できる。",
        "E. `import` 文よりも先に記述する必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import static java.lang.Math.PI;\nimport static java.lang.System.out;\n\npublic class StaticImportDemo {\n public static void main(String[] args) {\n  double radius = 2.0;\n  double circumference = 2 * PI * radius;\n  // クラス名を省略して static メンバーにアクセス\n  out.println(\"Circumference: \" + circumference);\n }\n}"
    },
    "questionText": {
      "en-US": "こののコードで使用されている `import static` 文に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`import static` 文は、指定したクラスの `public static` なメンバー（定数フィールドや `static` メソッドなど）を、そのクラス名を修飾せずに直接利用できるようにするための機能です。例えば `import static java.lang.Math.PI;` と記述すると、`Math.PI` の代わりに単に `PI` と書けるようになります。`System.out` のような `static` フィールドも対象にできます。インスタンスメンバーは対象外(A誤)。内部クラス限定ではない(C誤)。任意のクラスの`static`メンバーが対象(D誤)。通常の`import`と同様に`package`宣言の後、クラス定義の前に記述します(E誤)。"
    },
    "questionCategory": {
      "en-US": "static インポート"
    }
  },
  {
    "qid": {
      "en-US": "4-58"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "アクセス修飾子の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. コードの行数を減らすこと。",
        "B. すべてのフィールドとメソッドを公開（public）すること。",
        "C. クラスの内部状態（データ）を外部から保護し、アクセスを制御すること。",
        "D. 複数のクラスから共通の性質を抽出してスーパークラスを作ること。",
        "E. 1つのメソッド名で複数の異なる実装を提供すること。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "オブジェクト指向プログラミングにおけるカプセル化（Encapsulation）の主な目的として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "カプセル化の主な目的は、クラスの内部データ（フィールド）を外部からの直接的なアクセスや予期せぬ変更から保護することです。フィールドを `private` にし、必要に応じて `public` なメソッド（getter/setter）を通じてアクセスを提供することで、クラスはその内部状態を一貫性のある方法で管理・制御できます。これにより、クラスの利用者は内部実装の詳細を知らなくても安全にクラスを使用でき、将来的な内部実装の変更が利用側コードに与える影響を最小限に抑えることができます。A, Bは目的ではない。Dは継承、Eはポリモーフィズム（オーバーロードやオーバーライド）の説明に近い。"
    },
    "questionCategory": {
      "en-US": "カプセル化の目的"
    }
  },
  {
    "qid": {
      "en-US": "4-59"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "レコード・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 常に `public` になる。",
        "B. レコード自身のアクセス修飾子と同じになる。",
        "C. 常にパッケージプライベート（修飾子なし）になる。",
        "D. 常に `private` になる。",
        "E. コンストラクタは生成されない。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public record Dimensions(int width, int height) {\n // 正規コンストラクタは暗黙的に生成される\n}"
    },
    "questionText": {
      "en-US": "このの `Dimensions` レコードで暗黙的に生成される正規コンストラクタ `Dimensions(int width, int height)` のアクセス修飾子はどうなりますか。"
    },
    "explanation": {
      "en-US": "レコードで暗黙的に生成される正規コンストラクタのアクセス修飾子は、レコード自身のアクセス修飾子と同じになります。例えば、レコードが `public` で宣言されていれば、正規コンストラクタも `public` になります。レコードがアクセス修飾子なし（パッケージプライベート）で宣言されていれば、正規コンストラクタもパッケージプライベートになります。したがって、Bが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "レコードの正規コンストラクタのアクセスレベル"
    }
  },
  {
    "qid": {
      "en-US": "4-60"
    },
    "chapter": {
      "en-US": "4章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `this(...)` と `super(...)` は、1つのコンストラクタ内で両方とも呼び出すことができる。",
        "B. `this(...)` または `super(...)` のいずれかを呼び出す場合、それはコンストラクタの最初の文でなければならない。",
        "C. `super(...)` は必ず記述しなければならないが、`this(...)` は任意である。",
        "D. `this(...)` は記述できるが、`super(...)` は記述できない。",
        "E. `this(...)` と `super(...)` はコンストラクタの最後の文で呼び出す必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "class Base { Base(int i) {} }\n\nclass Derived extends Base {\n Derived() {\n  this(10); // 同じクラスの別コンストラクタ呼び出し\n }\n Derived(int i) {\n  super(i); // スーパークラスのコンストラクタ呼び出し\n  // this(); // ここに this() は書けない\n }\n}"
    },
    "questionText": {
      "en-US": "Java のコンストラクタ内での `this(...)` 呼び出しと `super(...)` 呼び出しに関するルールとして、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "コンストラクタの最初の文では、`this(...)` を使って同じクラスの別のコンストラクタを呼び出すか、`super(...)` を使って直接のスーパー（親）クラスのコンストラクタを呼び出すかの *どちらか一方* しか行うことができません（どちらも書かない場合は、暗黙的に引数なしの `super()` が呼び出されます）。両方を同時に呼び出すことはできません(A誤)。また、これらの呼び出しは必ずコンストラクタ本体の *最初の文* でなければなりません(B正、E誤)。`super(...)` の記述は必須ではありません（暗黙呼び出しがあるため）(C誤)。両方とも記述可能です（ただし同時ではない）(D誤)。"
    },
    "questionCategory": {
      "en-US": "コンストラクタでの this() と super() の同時使用不可"
    }
  },
  {
    "qid": {
      "en-US": "5-1"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Vehicle` クラスは `display` メソッドを `public` で宣言する必要がある。",
        "B. `Vehicle` クラスには引数なしのコンストラクタが必要である。",
        "C. `Vehicle` クラスには `display` という名前のフィールドが必要である。",
        "D. `Vehicle` クラスには `model` という名前のフィールドが宣言されている必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "// Vehicle.java\npublic class Vehicle {\n String model; // フィールド宣言が必要\n void display() { // メソッド\n  System.out.println(\"Model: \" + model);\n }\n // void Vehicle() {} // これはメソッド\n}"
    },
    "questionText": {
      "en-US": "このの `Vehicle` クラスの定義について、`display` メソッド内で `model` 変数を使用するために必要な前提条件として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`display` メソッド内で変数 `model` が使用されています。この変数がインスタンスフィールドを参照している場合、`Vehicle` クラス内に `model` という名前のフィールドが宣言されている必要があります。アクセス修飾子やコンストラクタの有無、`display` フィールドの有無は直接の関係はありません。"
    },
    "questionCategory": {
      "en-US": "フィールドの宣言要件"
    }
  },
  {
    "qid": {
      "en-US": "5-2"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. スーパークラスの `private` で宣言されたメンバーは、サブクラスから直接利用できる。",
        "B. サブクラスはスーパークラスのコンストラクタを暗黙的に継承する。",
        "C. スーパークラスでアクセス修飾子なし（パッケージプライベート）で宣言されたメンバーは、異なるパッケージのサブクラスからもアクセスできる。",
        "D. サブクラスは、スーパークラスの `public` および `protected` で宣言されたメンバー（コンストラクタを除く）を利用できる。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaのクラス継承に関する説明として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "継承の基本ルールについて問うています。A: `private` メンバーは宣言されたクラス内からしかアクセスできません。B: コンストラクタは継承されません。サブクラスは自身のコンストラクタから `super()` を使ってスーパークラスのコンストラクタを呼び出します。C: パッケージプライベートメンバーは同じパッケージ内からのみアクセス可能です。D: サブクラスはスーパークラスの `public` および `protected` メンバーを利用（継承）できます。これが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "継承におけるメンバーのアクセス可能性"
    }
  },
  {
    "qid": {
      "en-US": "5-3"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "インタフェースの作成と実装"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. インターフェース内で宣言されたフィールドは、暗黙的に `public static final` となる。",
        "B. インターフェースは他のクラスを継承（`extends`）することができる。",
        "C. クラスは最大で1つのインターフェースしか実装（`implements`）できない。",
        "D. インターフェース内で宣言されたメソッド（`default`, `static`, `private` を除く）は、暗黙的に `public abstract` となる。",
        "E. インターフェースのインスタンスを `new` 演算子で直接生成できる。"
      ]
    },
    "answer": {
      "en-US": [
        0,
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaのインターフェースに関する説明として、正しいものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェースの特性について確認します。A: インターフェース内で宣言されたフィールドは定数となり、暗黙的に `public static final` です。正しい。B: インターフェースはクラスを継承できません（インターフェースは他のインターフェースを継承できます）。誤り。C: クラスは複数のインターフェースを実装できます。誤り。D: `default`, `static`, `private` でないメソッドは抽象メソッドとなり、暗黙的に `public abstract` です。正しい。E: インターフェースは抽象的な型であり、直接インスタンス化できません。誤り。"
    },
    "questionCategory": {
      "en-US": "インターフェースの基本特性"
    }
  },
  {
    "qid": {
      "en-US": "5-4"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "インタフェースの作成と実装"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Command` インターフェースで `execute` を `default` メソッドにする必要がある。",
        "B. `MyCommand` クラスでコンパイルエラーが発生する。",
        "C. `Executor` クラスでコンパイルエラーが発生する。",
        "D. コンパイルは成功するが実行時にエラーが発生する。",
        "E. 正常にコンパイル、実行される。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Command.java\npublic interface Command {\n void execute(); // 抽象メソッド\n}\n// MyCommand.java\n// execute() を実装していない具象クラス\npublic class MyCommand implements Command {\n // public void execute() { /* 実装 */ }\n}\n\n// Executor.java\npublic class Executor {\n public static void main(String[] args) {\n  Command cmd = new MyCommand();\n  // cmd.execute();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム構成（Command.java, MyCommand.java, Executor.java）に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェースを実装する具象クラス（`abstract` でないクラス）は、そのインターフェースが持つすべての抽象メソッドを実装（オーバーライド）する義務があります。`MyCommand` クラスは `Command` インターフェースを実装すると宣言していますが、`Command` の抽象メソッド `execute()` を実装していません。そのため、`MyCommand` クラスの定義において、「抽象メソッド execute() を実装していない」という主旨のコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "インターフェースの抽象メソッド実装義務"
    }
  },
  {
    "qid": {
      "en-US": "5-5"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "インタフェースの作成と実装"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Displayable` インターフェースでコンパイルエラー",
        "B. `Widget` クラスでコンパイルエラー",
        "C. 10 が表示される",
        "D. `Widget` オブジェクトのデフォルトハッシュコードが表示される",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Displayable.java\npublic interface Displayable {\n // ObjectクラスのhashCodeを再宣言 (public abstract)\n int hashCode();\n}\n\n// Widget.java\npublic class Widget implements Displayable {\n private int id = 10;\n // hashCode を実装\n @Override\n public int hashCode() {\n  return id;\n }\n}\n\n// MainApp.java\npublic class MainApp {\n public static void main(String[] args) {\n  Displayable d = new Widget();\n  System.out.println(d.hashCode());\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Displayable.java, Widget.java, MainApp.java）をコンパイルし、実行した場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "すべてのインターフェースは、暗黙的に `Object` クラスの `public` メソッド（`toString()`, `equals()`, `hashCode()` など）を（抽象メソッドとして）含んでいるとみなされます。したがって、インターフェース内でこれらのメソッドを明示的に抽象メソッドとして再宣言すること（例: `int hashCode();`）は可能です（冗長ではありますが）。実装クラス `Widget` は `Displayable` を実装し、`hashCode()` メソッドをオーバーライドして `id` (つまり `10`) を返すように実装しています。`main` メソッドでは、`Displayable` 型の変数 `d` が `Widget` インスタンスを参照しています。`d.hashCode()` を呼び出すと、実行時の型である `Widget` クラスでオーバーライドされた `hashCode()` メソッドが実行され、`10` が返されて表示されます。"
    },
    "questionCategory": {
      "en-US": "インターフェースとObjectクラスのメソッド再宣言"
    }
  },
  {
    "qid": {
      "en-US": "5-6"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `super.log(msg);`",
        "B. `Logger.super.log(msg);`",
        "C. `TimestampLogger.super.log(msg);`",
        "D. `this.log(msg);`",
        "E. `log(msg);`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Logger.java\npublic interface Logger {\n default void log(String msg) {\n  System.out.println(\"LOG: \" + msg);\n }\n}\n// TimestampLogger.java\npublic interface TimestampLogger extends Logger {}\n\n// MyLogger.java\npublic class MyLogger implements TimestampLogger {\n @Override\n public void log(String msg) {\n  // ここで Logger の default log を呼びたい\n  ___________ // ← 空欄\n  System.out.println(\"MSG: \" + msg);\n }\n}\n\n// AppLog.java\npublic class AppLog {\n public static void main(String[] args) {\n  Logger logger = new MyLogger();\n  logger.log(\"Error\"); // \"LOG: Error\" \"MSG: Error\"\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行し、「LOG: Error」と「MSG: Error」が順に表示されるようにしたいと考えています。`MyLogger` クラスの空欄 `___________` に入れるべきコードとして、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "実装クラス (`MyLogger`) 内で、実装しているインターフェース（直接または間接的に、この場合は `Logger`）に定義された `default` メソッドを呼び出すには、特別な構文 `インターフェース名.super.メソッド名(...)` を使用します。単なる `super.メソッド名()` はスーパークラスのメソッド呼び出しに使われます。`this.log(msg)` や `log(msg)` は自分自身のメソッドを再帰的に呼び出してしまいます。したがって、`Logger` インターフェースの `log` デフォルトメソッドを呼び出すには `Logger.super.log(msg);` と記述します。"
    },
    "questionCategory": {
      "en-US": "インターフェースのデフォルトメソッド呼び出し構文"
    }
  },
  {
    "qid": {
      "en-US": "5-7"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. `Flyable` インターフェースでコンパイルエラー",
        "C. `Swimmable` インターフェースでコンパイルエラー",
        "D. `Duck` クラスでコンパイルエラー",
        "E. コンパイルは成功するが、`duck.move()` 呼び出し時に実行時エラー"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "// Flyable.java\npublic interface Flyable {\n default void move() { System.out.println(\"Fly\"); }\n}\n// Swimmable.java\npublic interface Swimmable {\n default void move() { System.out.println(\"Swim\"); }\n}\n\n// Duck.java\n// 同じシグネチャの default メソッドを持つIFを両方実装\npublic class Duck implements Flyable, Swimmable {\n // move() メソッドをオーバーライドする必要がある\n\n public static void main(String[] args) {\n  Duck duck = new Duck();\n  // duck.move(); // ← 呼び出し\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Duck` クラスをコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "あるクラスが、同じシグネチャを持つ `default` メソッドをそれぞれ持つ複数のインターフェースを実装する場合、そのクラスはどちらのデフォルト実装を使用するか（あるいは独自の実装を提供するか）を明確にするために、そのメソッドをオーバーライドしなければなりません。`Duck` クラスは `Flyable` と `Swimmable` の両方を実装していますが、どちらも `default void move()` を持っています。`Duck` クラス内で `move()` メソッドがオーバーライドされていないため、コンパイラはどちらのデフォルト実装を使えばよいか判断できず、コンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "デフォルトメソッドの衝突と解決義務"
    }
  },
  {
    "qid": {
      "en-US": "5-8"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `new` 演算子を使って直接インスタンスを生成できる。",
        "B. 抽象メソッド（本体のないメソッド）を持つことができる。",
        "C. 具象メソッド（本体のあるメソッド）を持つことができる。",
        "D. フィールド（変数）を持つことができる。",
        "E. 抽象クラスを継承するクラスは、必ず具象クラスでなければならない。"
      ]
    },
    "answer": {
      "en-US": [
        1,
        2,
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Javaの抽象クラス (`abstract class`) に関する説明として、正しいものを3つ選択してください。"
    },
    "explanation": {
      "en-US": "抽象クラスの特性について確認します。\nA: 抽象クラスは不完全な可能性のあるクラスなので、直接インスタンス化することはできません。誤り。\nB: 抽象クラスの主な目的の一つは、サブクラスで実装されるべき抽象メソッドを定義することです。正しい。\nC: 抽象クラスは、具象メソッドを持つこともできます。サブクラスはこれを継承またはオーバーライドできます。正しい。\nD: 抽象クラスも通常のクラスと同様にフィールド（インスタンス変数、クラス変数）を持つことができます。正しい。\nE: 抽象クラスを継承するクラスが、すべての抽象メソッドを実装しない場合は、そのサブクラスも `abstract` と宣言する必要があります。具象クラスである必要はありません。誤り。"
    },
    "questionCategory": {
      "en-US": "抽象クラスの基本的な特性"
    }
  },
  {
    "qid": {
      "en-US": "5-9"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Start -> End\"",
        "B. \"Start -> Task Execution -> End\"",
        "C. `RealProcessor` クラスでコンパイルエラー",
        "D. `Runner` クラスでコンパイルエラー",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// AbstractProcessor.java\nabstract class AbstractProcessor {\n public void process() {\n  System.out.print(\"Start -> \");\n  executeTask(); // 抽象メソッド呼び出し\n  System.out.print(\" -> End\");\n }\n protected abstract void executeTask(); // 抽象メソッド\n}\n// RealProcessor.java\nclass RealProcessor extends AbstractProcessor {\n @Override\n protected void executeTask() {\n  System.out.print(\"Task Execution\");\n }\n}\n\n// Runner.java\npublic class Runner {\n public static void main(String[] args) {\n  AbstractProcessor processor = new RealProcessor();\n  processor.process();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（AbstractProcessor.java, RealProcessor.java, Runner.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "ポリモーフィズム（多態性）により、スーパークラス型の変数（`processor`）がサブクラスのインスタンス（`RealProcessor`）を参照している場合、メソッド呼び出し（`processor.process()`）はスーパークラスのメソッドが実行されますが、そのメソッド内部から呼び出される抽象メソッド（`executeTask()`）は、実行時のインスタンス（`RealProcessor`）でオーバーライド（実装）されたメソッドが実行されます。\n1. `processor.process()` が呼び出され、`AbstractProcessor` の `process` メソッドが開始。\n2. `System.out.print(\"Start -> \");` が実行。\n3. `executeTask()` が呼び出される。実行時の型は `RealProcessor` なので、`RealProcessor` の `executeTask` メソッドが実行され、`System.out.print(\"Task Execution\");` が実行。\n4. `AbstractProcessor` の `process` メソッドに戻り、`System.out.print(\" -> End\");` が実行。\nしたがって、出力は \"Start -> Task Execution -> End\" となります。"
    },
    "questionCategory": {
      "en-US": "抽象クラスのポリモーフィズムとメソッド実行"
    }
  },
  {
    "qid": {
      "en-US": "5-10"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. メソッド名はスーパークラスのメソッドと同じでなければならない。",
        "B. パラメータリスト（型、数、順序）はスーパークラスのメソッドと同じでなければならない。",
        "C. 戻り値の型はスーパークラスのメソッドと同じか、そのサブタイプ（共変戻り値型）でなければならない。",
        "D. アクセス修飾子は、スーパークラスのメソッドと同じか、より厳しく（公開範囲を狭く）しなければならない。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "メソッドのオーバーライドに関するルールの説明として、 *誤っている* ものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッドをオーバーライドする際のルールについて確認します。A, B, C は正しいルールです。メソッド名とパラメータリストは完全に一致する必要があります。戻り値の型は同じか、より具体的な型（サブタイプ）にすることができます。Dは誤りです。オーバーライドするメソッドのアクセス修飾子は、スーパークラスのメソッドのアクセス修飾子と *同じか、より緩やか（公開範囲が広い）* でなければなりません。アクセスレベルを狭めることはできません（例: `public` を `protected` にすることはできない）。"
    },
    "questionCategory": {
      "en-US": "メソッドオーバーライドの基本条件"
    }
  },
  {
    "qid": {
      "en-US": "5-11"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `private`",
        "B. アクセス修飾子なし（デフォルト）",
        "C. `protected`",
        "D. `public`",
        "E. 上記 B, C, D のいずれでもよい"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": "// Document.java\npublic class Document {\n // デフォルトアクセス（パッケージプライベート）\n void printContent() {\n  System.out.println(\"Document Content\");\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Document` クラスを継承するサブクラス `Report` を定義し、`printContent` メソッドをオーバーライドしようとしています。`Report` クラスで定義する `printContent` メソッドに付与できるアクセス修飾子として、適切なものを1つ選択してください。（`Document` と `Report` は同じパッケージにあるとします）"
    },
    "explanation": {
      "en-US": "メソッドをオーバーライドする際、サブクラスのメソッドのアクセスレベルは、スーパークラスのメソッドのアクセスレベルと *同じか、それより広く（緩く）* なければなりません。スーパークラス `Document` の `printContent` メソッドはアクセス修飾子なし、つまりデフォルト（パッケージプライベート）アクセスです。アクセスレベルの広さの順序は `private` < デフォルト < `protected` < `public` です。したがって、サブクラス `Report` でオーバーライドする `printContent` メソッドのアクセス修飾子は、デフォルト、`protected`、または `public` のいずれかである必要があります。選択肢Eがこれらすべてを包含しています。"
    },
    "questionCategory": {
      "en-US": "オーバーライド時のアクセスレベル変更"
    }
  },
  {
    "qid": {
      "en-US": "5-12"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"SuperSubSuperSub\"",
        "B. \"SuperSuperSubSub\"",
        "C. \"SuperSuperSuperSuper\"",
        "D. \"SubSubSubSub\"",
        "E. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// SuperClass.java\nclass SuperClass {\n String value = \"Super\"; // スーパークラスのフィールド\n void display() { // スーパークラスのメソッド\n  System.out.print(value); // ここでの value は SuperClass の value\n }\n}\n// SubClass.java\nclass SubClass extends SuperClass {\n String value = \"Sub\"; // サブクラスのフィールド（隠蔽）\n // display() はオーバーライドされていない\n}\n\n// TestPoly.java\npublic class TestPoly {\n public static void main(String[] args) {\n  SuperClass obj1 = new SuperClass();\n  SuperClass obj2 = new SubClass(); // 変数はSuper、実体はSub\n\n  obj1.display(); // SuperClassのdisplay() -> SuperClassのvalue\n  obj2.display(); // SuperClassのdisplay() -> SuperClassのvalue\n  System.out.print(obj1.value); // 変数の型SuperClassのvalue\n  System.out.print(obj2.value); // 変数の型SuperClassのvalue\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（SuperClass.java, SubClass.java, TestPoly.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "フィールドアクセスはポリモーフィズムの対象外であり、変数の宣言型に基づいて解決されます。メソッド呼び出しはポリモーフィズムの対象となり、実行時のインスタンスの型に基づいて解決されますが、この例では `display` メソッドはオーバーライドされていません。\n- `obj1.display()`: `obj1` は `SuperClass` なので `SuperClass` の `display` が実行。その内部の `value` は `SuperClass` の `value` (\"Super\")。\n- `obj2.display()`: `obj2` の実行時の型は `SubClass` ですが、`display` はオーバーライドされていないため `SuperClass` の `display` が実行。その内部の `value` は `SuperClass` の `value` (\"Super\")。\n- `obj1.value`: 変数 `obj1` の型は `SuperClass` なので `SuperClass` の `value` (\"Super\")。\n- `obj2.value`: 変数 `obj2` の型も `SuperClass` なので `SuperClass` の `value` (\"Super\")。\nしたがって、出力は \"SuperSuperSuperSuper\" となります。"
    },
    "questionCategory": {
      "en-US": "フィールドの隠蔽（シャドウイング）とメソッドのポリモーフィズム"
    }
  },
  {
    "qid": {
      "en-US": "5-13"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "インタフェースの作成と実装"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `SpecificTask` クラスでコンパイルエラー",
        "B. `Executor` クラスでコンパイルエラー",
        "C. \"Base\" と表示される",
        "D. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Task.java\ninterface Task { void perform(); }\n// BaseTask.java\nclass BaseTask implements Task {\n public void perform() { System.out.print(\"Base\"); }\n}\n// SpecificTask.java\n// BaseTaskを継承、Taskも実装（冗長だがOK）\nclass SpecificTask extends BaseTask implements Task {}\n\n// Executor.java\npublic class Executor {\n public static void main(String[] args) {\n  Task task = new SpecificTask();\n  task.perform();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Task.java, BaseTask.java, SpecificTask.java, Executor.java）をコンパイルし、実行した場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`SpecificTask` クラスは `BaseTask` クラスを継承しています。`BaseTask` は `Task` インターフェースを実装し、`perform()` メソッドを提供しています。したがって、`SpecificTask` は `perform()` メソッドを `BaseTask` から継承します。`SpecificTask` が `implements Task` と再度宣言しても、すでにメソッドが（継承によって）実装されているため問題ありません。`Executor` の `main` メソッドでは、`Task` 型の変数 `task` が `SpecificTask` のインスタンスを参照しています。`task.perform()` を呼び出すと、実行時の型である `SpecificTask` が持つ（`BaseTask` から継承した）`perform()` メソッドが実行され、「Base」が表示されます。"
    },
    "questionCategory": {
      "en-US": "インターフェース実装の継承"
    }
  },
  {
    "qid": {
      "en-US": "5-14"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 5行目でコンパイルエラーが発生する",
        "B. `Car` クラスでコンパイルエラーが発生する",
        "C. `Vehicle` クラスでコンパイルエラーが発生する",
        "D. 正常にコンパイル、実行される"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// Movable.java\npublic interface Movable { void move(); }\n// Vehicle.java\nclass Vehicle implements Movable {\n public void move() { System.out.println(\"Move Vehicle\"); }\n public void checkFuel() { System.out.println(\"Check Fuel\"); }\n}\n// Car.java\nclass Car extends Vehicle {\n public void openDoor() { System.out.println(\"Open Door\"); }\n}\n\n// TestDrive.java\npublic class TestDrive {\n public static void main(String[] args) {\n  Movable movable = new Car();\n  // movable.openDoor(); // ← エラー箇所\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Movable.java, Vehicle.java, Car.java, TestDrive.java）について、`TestDrive.java` の5行目のコメントを外した場合のコンパイル結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "ポリモーフィズムにおいて、あるオブジェクトをスーパークラスやインターフェース型の変数で参照している場合、その変数を通じて呼び出せるのは、その変数の型（宣言型）で定義されているメソッドのみです。変数 `movable` の型は `Movable` インターフェースです。`Movable` インターフェースには `move()` メソッドしか定義されていません。実際のインスタンスは `Car` であり `openDoor()` メソッドを持っていますが、`Movable` 型の変数 `movable` からは `openDoor()` メソッドを直接呼び出すことはできません。したがって、`movable.openDoor();` の行でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "ポリモーフィズムと変数型によるメソッド呼び出し制限"
    }
  },
  {
    "qid": {
      "en-US": "5-15"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 直接 `logger.connectDb()` を呼び出せる。",
        "B. `ILogger` インターフェースに `connectDb()` メソッドを追加する必要がある。",
        "C. `logger instanceof DbLogger` で型を確認し、`true` であれば `(DbLogger)logger` とキャストしてから `connectDb()` を呼び出す必要がある。",
        "D. `logger.getClass().getName().equals(\"DbLogger\")` で確認し、リフレクションを使って呼び出す必要がある。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// ILogger.java\npublic interface ILogger { void log(String msg); }\n// FileLogger.java\npublic class FileLogger implements ILogger {\n public void log(String msg) { /* ... */ }\n}\n// DbLogger.java\npublic class DbLogger implements ILogger {\n public void log(String msg) { /* ... */ }\n public void connectDb() { /* ... */ }\n}\n// ConsoleLogger.java\npublic class ConsoleLogger implements ILogger {\n public void log(String msg) { /* ... */ }\n}\n\n// LogManager.java\npublic class LogManager {\n public static void main(String[] args) {\n  ILogger[] loggers = { new FileLogger(), new DbLogger(), new ConsoleLogger() };\n  for (ILogger logger : loggers) {\n   // logger.connectDb(); // コンパイルエラー\n   // 特定の型でのみメソッドを呼び出したい場合\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムについて、`for` ループ内で `DbLogger` のインスタンスの場合のみ `connectDb()` メソッドを呼び出したい場合、どのようなコードが必要になるか、最も適切な説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "配列 `loggers` は `ILogger` 型で宣言されており、その要素は `FileLogger`, `DbLogger`, `ConsoleLogger` のインスタンスを参照しています。`for` ループ内の変数 `logger` も `ILogger` 型です。`ILogger` インターフェースには `connectDb()` メソッドが定義されていないため、`logger.connectDb()` を直接呼び出すことはできません(A誤)。`DbLogger` 型特有のメソッドを呼び出すには、まず `logger` が実際に `DbLogger` のインスタンスであるかを `instanceof` で確認し、そうであれば `DbLogger` 型にダウンキャストしてからメソッドを呼び出す必要があります(C正)。Bはインターフェースの変更が必要。Dは可能だが一般的ではない。"
    },
    "questionCategory": {
      "en-US": "ポリモーフィックな配列とダウンキャストの必要性"
    }
  },
  {
    "qid": {
      "en-US": "5-16"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. ①の行でコンパイルエラーが発生する",
        "B. ①の行で実行時に `ClassCastException` が発生する",
        "C. 「Rectangle DrawRect 」と表示される",
        "D. 「Figure DrawRect 」と表示される",
        "E. コンパイルエラーも実行時エラーも発生しないが、何も表示されない"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Figure.java\nclass Figure { void identify() { System.out.print(\"Figure \"); } }\n// Rectangle.java\nclass Rectangle extends Figure {\n void identify() { System.out.print(\"Rectangle \"); }\n void draw() { System.out.print(\"DrawRect \"); }\n}\n\n// TestCast.java\npublic class TestCast {\n public static void main(String[] args) {\n  Figure fig = new Rectangle(); // スーパークラス型変数にサブクラスインスタンス\n  // fig.draw(); // コンパイルエラー\n  Rectangle rect = (Rectangle)fig; // ① ダウンキャスト\n  rect.identify(); // ②\n  rect.draw();     // ③\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Figure.java, Rectangle.java, TestCast.java）をコンパイルし、実行した場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "変数 `fig` は `Figure` 型で宣言されていますが、実際に参照しているのは `Rectangle` のインスタンスです。①の行では、`fig` を `Rectangle` 型にダウンキャストしています。参照している実際のオブジェクトが `Rectangle` なので、このキャストは実行時に成功します。変数 `rect` は `Rectangle` 型となり、`Rectangle` インスタンスを参照します。② `rect.identify()` は `Rectangle` クラスでオーバーライドされた `identify` メソッドを実行し、「Rectangle 」を表示します。③ `rect.draw()` は `Rectangle` クラスで定義された `draw` メソッドを実行し、「DrawRect 」を表示します。したがって、出力は「Rectangle DrawRect 」となります。"
    },
    "questionCategory": {
      "en-US": "安全なダウンキャスト"
    }
  },
  {
    "qid": {
      "en-US": "5-17"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. ①と②の両方でコンパイルエラーが発生する。",
        "B. ①ではコンパイルエラーが発生し、②では実行時に `ClassCastException` が発生する。",
        "C. ①では実行時に `ClassCastException` が発生し、②ではコンパイルエラーが発生する。",
        "D. ①と②の両方で実行時に `ClassCastException` が発生する。",
        "E. 正常にコンパイル、実行される。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// X.java\nclass X { }\n// Y.java\nclass Y extends X { }\n// Z.java\nclass Z extends Y { }\n// W.java (独立したクラス)\nclass W { }\n\n// CastCheck.java\npublic class CastCheck {\n public static void main(String[] args) {\n  X xRef = new Y(); // xRef は Y インスタンスを参照\n  // Z zRef = (Z)xRef; // ① 実行時エラーの可能性\n  // W wRef = (W)xRef; // ② コンパイルエラー\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（クラス X, Y, Z, W および CastCheck.java）について、コメントアウトされた①と②の行のコメントを外した場合に発生する事象として、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "キャストの可否は、コンパイル時と実行時でチェックされます。\n① `Z zRef = (Z)xRef;`: 変数 `xRef` の型は `X`、キャスト先の型は `Z` です。`X` と `Z` の間には継承関係が存在する（`Z` は `X` の（間接的な）サブクラス）ため、コンパイラはこのキャストが実行時に成功する *可能性* があると判断し、コンパイルは通ります。しかし、実行時には `xRef` が実際に参照しているのは `Y` のインスタンスです。`Y` は `Z` ではない（`Z` のスーパータイプである）ため、このキャストは失敗し、`ClassCastException` がスローされます。\n② `W wRef = (W)xRef;`: 変数 `xRef` の型は `X`、キャスト先の型は `W` です。`X` と `W` の間には何の継承関係もありません。このような、明らかに互換性のない型へのキャストは、コンパイラがコンパイル時にエラーとして検出します。\nしたがって、Cが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "不正なキャスト（コンパイルエラーと実行時エラー）"
    }
  },
  {
    "qid": {
      "en-US": "5-18"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドとコンストラクタの作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 100",
        "B. 200",
        "C. 0",
        "D. コンパイルエラーが発生する",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// DataContainer.java\npublic class DataContainer {\n int value = 100; // インスタンスフィールド\n void displayValue() {\n  int value = 200; // ローカル変数 (フィールドを隠蔽)\n  System.out.println(value);\n }\n}\n// RunnerMain.java\npublic class RunnerMain {\n public static void main(String[] args) {\n  DataContainer dc = new DataContainer();\n  dc.displayValue();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（DataContainer.javaとRunnerMain.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッド内で宣言されたローカル変数 (`displayValue` 内の `int value = 200;`) が、同じ名前を持つインスタンスフィールド (`int value = 100;`) を隠蔽（シャドウイング）します。メソッド内で単に `value` と記述した場合、スコープのルールにより、より内側で宣言されたローカル変数が優先されます。したがって、`System.out.println(value);` はローカル変数 `value` の値である `200` を表示します。"
    },
    "questionCategory": {
      "en-US": "ローカル変数によるフィールドの隠蔽（シャドウイング）"
    }
  },
  {
    "qid": {
      "en-US": "5-19"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"[LOCAL]Error\" の後に \"[FILE]Error\" の後に \"[BASE]Error\"",
        "B. \"[FILE]Error\" の後に \"[FILE]Error\" の後に \"[BASE]Error\"",
        "C. \"[BASE]Error\" の後に \"[FILE]Error\" の後に \"[LOCAL]Error\"",
        "D. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "// BaseLogger.java\npublic class BaseLogger {\n String prefix = \"[BASE]\";\n}\n// FileLogger.java\npublic class FileLogger extends BaseLogger {\n String prefix = \"[FILE]\"; // フィールドを隠蔽\n void log(String message) {\n  String prefix = \"[LOCAL]\"; // ローカル変数\n  System.out.println(prefix + message); // ① ローカル変数\n  System.out.println(this.prefix + message); // ② 自クラスフィールド\n  System.out.println(super.prefix + message); // ③ 親クラスフィールド\n }\n}\n// LoggerTest.java\npublic class LoggerTest {\n public static void main(String[] args) {\n  FileLogger logger = new FileLogger();\n  logger.log(\"Error\");\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（BaseLogger.java, FileLogger.java, LoggerTest.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "変数名の参照解決と `this`, `super` の使い方。\n① `prefix`: 最も内側のスコープにあるローカル変数 `prefix` (\"[LOCAL]\") を参照します。\n② `this.prefix`: `this` は現在のインスタンス (`FileLogger` のインスタンス）を指し、`this.prefix` は `FileLogger` クラスで宣言されたインスタンスフィールド `prefix` (\"[FILE]\") を参照します。\n③ `super.prefix`: `super` は直接のスーパークラス (`BaseLogger`) を指し、`super.prefix` は `BaseLogger` クラスで宣言されたインスタンスフィールド `prefix` (\"[BASE]\") を参照します。\nしたがって、出力は「[LOCAL]Error」、「[FILE]Error」、「[BASE]Error」の順になります。"
    },
    "questionCategory": {
      "en-US": "this と super によるメンバー参照"
    }
  },
  {
    "qid": {
      "en-US": "5-20"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"L3 L2 L1 \"",
        "B. \"L1 L2 L3 \"",
        "C. \"L3 \"",
        "D. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Level1.java\nclass Level1 { Level1() { System.out.print(\"L1 \"); } }\n// Level2.java\nclass Level2 extends Level1 { Level2() { System.out.print(\"L2 \"); } }\n// Level3.java\nclass Level3 extends Level2 { Level3() { System.out.print(\"L3 \"); } }\n\n// ChainCall.java\npublic class ChainCall {\n public static void main(String[] args) {\n  Level3 obj = new Level3();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Level1.java, Level2.java, Level3.java, ChainCall.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "サブクラスのコンストラクタが呼び出される際、その本体の処理が実行される前に、まずスーパークラスのコンストラクタが呼び出されます。`this(...)` や `super(...)` の明示的な呼び出しがない場合、コンパイラは暗黙的に引数なしのスーパークラスコンストラクタ `super()` を最初の文として挿入します。この呼び出しは連鎖的に行われます。\n1. `new Level3()` が呼び出される。\n2. `Level3` コンストラクタが開始され、暗黙の `super()` により `Level2` コンストラクタが呼び出される。\n3. `Level2` コンストラクタが開始され、暗黙の `super()` により `Level1` コンストラクタが呼び出される。\n4. `Level1` コンストラクタ本体が実行され、「L1 」が出力される。\n5. `Level2` コンストラクタ本体が実行され、「L2 」が出力される。\n6. `Level3` コンストラクタ本体が実行され、「L3 」が出力される。\nしたがって、出力は「L1 L2 L3 」となります。"
    },
    "questionCategory": {
      "en-US": "コンストラクタの暗黙的なsuper()呼び出し連鎖"
    }
  },
  {
    "qid": {
      "en-US": "5-21"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"SuperDefault SuperParam SubDefault SubParam \"",
        "B. \"SuperParam SubParam \"",
        "C. \"SuperDefault SubParam \"",
        "D. \"SuperParam SubDefault SubParam \""
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// SuperType.java\nclass SuperType {\n String code;\n SuperType() {\n  this(\"Default\"); // ③ このクラスの別コンストラクタへ\n  System.out.print(\"SuperDefault \");\n }\n SuperType(String code) { // ②\n  this.code = code;\n  System.out.print(\"SuperParam \");\n }\n}\n// SubType.java\nclass SubType extends SuperType {\n SubType() { // ④\n  // 暗黙の super() 呼び出し\n  System.out.print(\"SubDefault \");\n }\n SubType(String code) { // ⑥\n  super(code); // ⑦ スーパークラスの引数ありコンストラクタへ\n  System.out.print(\"SubParam \");\n }\n}\n// TestConstructors.java\npublic class TestConstructors {\n public static void main(String[] args) {\n  new SubType(\"Custom\"); // ⑧\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（SuperType.java, SubType.java, TestConstructors.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "コンストラクタ呼び出しの連鎖を追跡します。\n1. ⑧ `new SubType(\"Custom\")` が呼び出される。\n2. ⑥ `SubType(String code)` コンストラクタが開始される。\n3. ⑦ `super(code)` (つまり `super(\"Custom\")`) が実行され、スーパークラスの `SuperType(String code)` コンストラクタ②が呼び出される。\n4. ② `SuperType(String code)` コンストラクタ本体が実行され、「SuperParam 」が出力される。(`this(\"Default\")` は呼び出されない)\n5. ② の実行が終了し、⑥ `SubType(String code)` コンストラクタの `super(code)` 呼び出しの次に戻る。\n6. `System.out.print(\"SubParam \");` が実行される。\n7. ⑥ の実行が終了する。\nしたがって、最終的な出力は「SuperParam SubParam 」となります。"
    },
    "questionCategory": {
      "en-US": "明示的なthis()とsuper()によるコンストラクタ呼び出し順序"
    }
  },
  {
    "qid": {
      "en-US": "5-22"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `private` メソッドは `static` でなければならない。",
        "B. `private` メソッドは、そのインターフェース内の `default` メソッドや `static` メソッドからのみ呼び出すことができる。",
        "C. インターフェースを実装したクラスから `private` メソッドを直接呼び出すことができる。",
        "D. `private` メソッドは抽象メソッドとして宣言できる。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public interface Helper {\n default void assist() {\n  init(); // privateメソッド呼び出し\n  System.out.println(\"Assisting...\");\n }\n\n // Java 9以降、privateメソッドを定義可能\n private void init() {\n  System.out.println(\"Initializing helper...\");\n }\n\n static void staticAssist() {\n  staticInit(); // private staticメソッド呼び出し\n  System.out.println(\"Static assisting...\");\n }\n\n private static void staticInit() {\n  System.out.println(\"Static init...\");\n }\n}"
    },
    "questionText": {
      "en-US": "Java 9 で導入されたインターフェースの `private` メソッドに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェースの `private` メソッドは、主にそのインターフェース内の他のメソッド（`default` メソッドや `static` メソッド）の共通ロジックをカプセル化するために使用されます。これにより、コードの重複を避け、可読性を向上させることができます。\nA: `private` インスタンスメソッドも `private static` メソッドも定義可能です。誤り。\nB: `private` メソッドはそのインターフェース内部でのみ利用可能であり、`default` メソッドや `static` メソッドから呼び出されることを意図しています。Java 9以降、`private static` メソッドは、同じインターフェース内の `static` メソッド *および* 非 `static` (`default`, `private`インスタンス) メソッドの両方から呼び出し可能です。したがって、この選択肢は不正確です。\nC: インターフェースを実装したクラスから `private` メソッドを直接呼び出すことはできません。正しい。\nD: `private` メソッドは必ず実装（本体）を持つ必要があります。抽象メソッドにはできません。誤り。"
    },
    "questionCategory": {
      "en-US": "インターフェースの private メソッド"
    }
  },
  {
    "qid": {
      "en-US": "5-23"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "final クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. クラス",
        "B. メソッド",
        "C. インスタンス変数（フィールド）",
        "D. ローカル変数",
        "E. インターフェース"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "`final` キーワードで修飾することが *できない* Javaの要素を、以下の選択肢から1つ選択してください。"
    },
    "explanation": {
      "en-US": "`final` 修飾子は、クラス、メソッド、フィールド（インスタンス変数、クラス変数）、ローカル変数、メソッドパラメータに適用できます。\n- `final` クラス: 継承できなくなります。\n- `final` メソッド: オーバーライドできなくなります。\n- `final` フィールド/ローカル変数/パラメータ: 一度初期化されると再代入できなくなります。\nインターフェースは、その性質上、実装されること（ある種の拡張）を前提としているため、`final` で修飾することはできません。"
    },
    "questionCategory": {
      "en-US": "final 修飾子の適用対象"
    }
  },
  {
    "qid": {
      "en-US": "5-24"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "シール・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `sealed` クラスはインスタンス化できない抽象クラスの一種である。",
        "B. `sealed` クラスは、どのクラスからも自由に継承できる。",
        "C. `sealed` クラスは、`permits` キーワードを使って、それを継承できるサブクラスを明示的に指定する。",
        "D. `sealed` クラスを継承するサブクラスは、必ず `final` でなければならない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java 17 で正式導入されたシールクラス (`sealed class`) に関する説明として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "シールクラス (`sealed`) は、クラスやインターフェースの継承階層を制限するための機能です。`sealed` と宣言されたクラス（またはインターフェース）は、`permits` キーワードの後に、それを直接継承または実装できるクラスやインターフェースを指定します。これにより、許可されていないクラスによる拡張を防ぐことができます。A: `sealed` クラスは抽象クラスでも具象クラスでも構いません。B: 継承は `permits` で指定されたクラスに限定されます。D: `sealed` クラスを継承するサブクラスは、`final`, `sealed`, または `non-sealed` のいずれかで修飾する必要があります。必ずしも `final` である必要はありません。"
    },
    "questionCategory": {
      "en-US": "シールクラス (sealed class) の基本"
    }
  },
  {
    "qid": {
      "en-US": "5-25"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "シール・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public final class Circle extends Shape { ... }`",
        "B. `public class Circle extends Shape { ... }`",
        "C. `public non-sealed class Circle extends Shape { ... }`",
        "D. `public abstract class Circle extends Shape { ... }`",
        "E. `public sealed class Circle extends Shape permits ... { ... }`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        2,
        4
      ]
    },
    "code": {
      "en-US": "public sealed class Shape permits Circle, Square {\n // クラス本体\n}"
    },
    "questionText": {
      "en-US": "このの `Shape` シールクラスを継承する `Circle` クラスを定義する場合、`Circle` クラスの宣言に必要な修飾子の組み合わせとして、正しいものを3つ選択してください。"
    },
    "explanation": {
      "en-US": "`sealed` クラス（またはインターフェース）を継承または実装するクラス（またはインターフェース）は、`permits` リストに含まれていなければならず、かつ、以下のいずれかの修飾子を持たなければなりません:\n1. `final`: これ以上継承を許可しない。\n2. `sealed`: 自身もシールクラスとなり、さらに継承を許可するサブクラスを `permits` で指定する。\n3. `non-sealed`: シールによる制限を解除し、どのクラスでも自由にこのサブクラスを継承できるようにする。\n選択肢の中で、`Circle` は `permits` リストに含まれていると仮定します。A (`final`), C (`non-sealed`), E (`sealed`) は有効な修飾子です。B は必要な修飾子（`final`, `sealed`, `non-sealed` のいずれか）が欠けているため誤り。D の `abstract` はアクセス修飾子ではなく、これだけでは不十分です（例: `public abstract non-sealed class ...` は可能）。設問が2つ選択の場合、A と C が一般的な選択肢です。"
    },
    "questionCategory": {
      "en-US": "シールクラスのサブクラスに必要な修飾子"
    }
  },
  {
    "qid": {
      "en-US": "5-26"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "シール・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Exec \"",
        "B. \"Prep \"",
        "C. \"Exec Prep \"",
        "D. コンパイルエラーが発生する",
        "E. 実行時に `ClassCastException` が発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// Action.java\npublic sealed interface Action permits TaskA, TaskB {\n void execute();\n}\n// TaskA.java\npublic abstract class TaskA implements Action {\n abstract void prepare();\n}\n// TaskB.java\npublic final class TaskB extends TaskA {\n @Override public void execute() { System.out.print(\"Exec \"); }\n @Override void prepare() { System.out.print(\"Prep \"); }\n}\n// Runner.java\npublic class Runner {\n public static void main(String[] args) {\n  Action action = new TaskB(); // ⑤\n  action.execute(); // ⑥\n  // action.prepare(); // コンパイルエラー\n  TaskA taskA = (TaskA) action; // ⑧ キャスト\n  taskA.prepare(); // ⑨\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（Action.java, TaskA.java, TaskB.java, Runner.java）をコンパイルし、実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "シールインターフェース、抽象クラス、具象クラスの階層とポリモーフィズム、キャストを組み合わせた問題です。\n- クラス定義: `Action` (sealed IF) <- `TaskA` (abstract class) <- `TaskB` (final class)。階層は有効です。\n- ⑤: `Action` 型変数 `action` に `TaskB` インスタンスを代入。ポリモーフィズムとして有効。\n- ⑥: `action.execute()` を呼び出す。実行時の型は `TaskB` なので、`TaskB` の `execute` メソッドが実行され、「Exec 」が表示される。\n- ⑧: `action` を `TaskA` 型にダウンキャスト。`action` が参照する実際のオブジェクトは `TaskB` であり、`TaskB` は `TaskA` のサブクラスなので、キャストは成功します。\n- ⑨: `TaskA` 型の変数 `taskA` から `prepare()` メソッドを呼び出す。実行時の型は `TaskB` なので、`TaskB` の `prepare` メソッドが実行され、「Prep 」が表示される。\nしたがって、最終的な出力は「Exec Prep 」となります。"
    },
    "questionCategory": {
      "en-US": "シールインターフェースとクラス階層、キャスト"
    }
  },
  {
    "qid": {
      "en-US": "5-27"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `CalculatorBase` は抽象メソッドがあるのでインスタンス化できない。",
        "B. `Adder` クラスは `CalculatorBase` の抽象メソッド `calculate` を実装していないため、コンパイルエラーになる。",
        "C. `Adder` クラスは `display` メソッドをオーバーライドしている。",
        "D. `TestCalc` で `Adder` をインスタンス化できる。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "abstract class CalculatorBase {\n abstract int calculate(int x, int y);\n void display() { System.out.println(\"Base\"); }\n}\n\n// 実装クラスのはずが抽象メソッドを実装し忘れている\nclass Adder extends CalculatorBase {\n // calculateメソッドの実装がない\n void display() { System.out.println(\"Adder\"); }\n}\n\npublic class TestCalc {\n public static void main(String[] args) {\n  // CalculatorBase calc = new Adder(); // コンパイルエラー\n }\n}"
    },
    "questionText": {
      "en-US": "こののクラス定義について、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "抽象クラス `CalculatorBase` は抽象メソッド `calculate` を持っています。具象クラス（`abstract` でないクラス）が抽象クラスを継承する場合、すべての抽象メソッドを実装（オーバーライド）しなければなりません。`Adder` クラスは `CalculatorBase` を継承していますが、`calculate` メソッドを実装していません。そのため、`Adder` クラス自体も `abstract` と宣言するか、`calculate` を実装する必要があり、現在の状態ではコンパイルエラーとなります(B)。Aは正しいがBが直接的なエラー原因。Cはオーバーライドしている。DはBのエラーのためインスタンス化できない。"
    },
    "questionCategory": {
      "en-US": "抽象メソッドの実装義務"
    }
  },
  {
    "qid": {
      "en-US": "5-28"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "final クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる。",
        "B. `ImmutableData` クラスでコンパイルエラーが発生する。",
        "C. `ExtendedData` クラスでコンパイルエラーが発生する。",
        "D. `TestFinalClass` クラスでコンパイルエラーが発生する。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "final class ImmutableData {\n // ... data and methods\n}\n\n// final クラスを継承しようとしている\nclass ExtendedData extends ImmutableData {\n // ... additional data or methods\n}\n\npublic class TestFinalClass {\n public static void main(String[] args) {\n  // ExtendedData ed = new ExtendedData();\n }\n}"
    },
    "questionText": {
      "en-US": "こののクラス定義について、コンパイル時の結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`final` キーワードがクラス宣言に付与されると、そのクラスは継承することができなくなります。`ImmutableData` クラスは `final` と宣言されています。`ExtendedData` クラスが `extends ImmutableData` によって `ImmutableData` を継承しようとしているため、これは許可されず、`ExtendedData` クラスの定義でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "final クラスの継承不可"
    }
  },
  {
    "qid": {
      "en-US": "5-29"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる。",
        "B. `ReportGenerator` クラスでコンパイルエラー。",
        "C. `DetailedReport` クラスの `generateHeader` メソッドでコンパイルエラー。",
        "D. `DetailedReport` クラスの `generateBody` メソッドでコンパイルエラー。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "class ReportGenerator {\n final void generateHeader() {\n  System.out.println(\"== Header ==\");\n }\n void generateBody() {\n  System.out.println(\"Body\");\n }\n}\n\nclass DetailedReport extends ReportGenerator {\n @Override\n void generateHeader() { // finalメソッドをオーバーライドしようとしている\n  System.out.println(\"** Detailed Header **\");\n }\n @Override\n void generateBody() {\n  System.out.println(\"Detailed Body\");\n }\n}\n\npublic class TestFinalMethod {\n public static void main(String[] args) {\n  // DetailedReport dr = new DetailedReport();\n  // dr.generateHeader();\n }\n}"
    },
    "questionText": {
      "en-US": "こののクラス定義について、コンパイル時の結果として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`final` キーワードがメソッド宣言に付与されると、そのメソッドはサブクラスでオーバーライドすることができなくなります。`ReportGenerator` クラスの `generateHeader` メソッドは `final` と宣言されています。`DetailedReport` クラスがこの `final` メソッドをオーバーライドしようとしているため、`DetailedReport` クラスの `generateHeader` メソッドの定義でコンパイルエラーが発生します。`generateBody` メソッドは `final` ではないため、オーバーライド可能です。"
    },
    "questionCategory": {
      "en-US": "final メソッドのオーバーライド不可"
    }
  },
  {
    "qid": {
      "en-US": "5-30"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 抽象クラス `VehicleBase` はコンストラクタを持てないため、コンパイルエラーになる。",
        "B. `ElectricCar` のコンストラクタから `super(id)` を呼び出せないため、コンパイルエラーになる。",
        "C. プログラムは正常にコンパイル・実行され、初期化メッセージとエンジン始動メッセージが表示される。",
        "D. 抽象クラスのコンストラクタは `private` でなければならない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "abstract class VehicleBase {\n private String id;\n\n // 抽象クラスもコンストラクタを持てる\n protected VehicleBase(String id) {\n  this.id = id;\n  System.out.println(\"VehicleBase initialized: \" + id);\n }\n\n abstract void startEngine();\n}\n\nclass ElectricCar extends VehicleBase {\n ElectricCar(String id) {\n  super(id); // スーパークラスのコンストラクタ呼び出し\n }\n @Override\n void startEngine() {\n  System.out.println(\"Electric engine started silently.\");\n }\n}\n\npublic class TestAbstractConstructor {\n public static void main(String[] args) {\n  ElectricCar ec = new ElectricCar(\"EV001\");\n  ec.startEngine();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "抽象クラスはインスタンス化できませんが、コンストラクタを持つことができます。このコンストラクタは、サブクラスのインスタンスが生成される際に、サブクラスのコンストラクタから `super(...)` を使って呼び出されるために存在します。このコードでは、`ElectricCar` のコンストラクタが `super(id)` を呼び出して `VehicleBase` のコンストラクタを実行しており、これは正しい使い方です。したがって、プログラムは正常にコンパイル・実行され、まず `VehicleBase` のコンストラクタによるメッセージ、次に `startEngine` メソッドによるメッセージが表示されます。A, B, Dは誤りです。"
    },
    "questionCategory": {
      "en-US": "抽象クラスのコンストラクタ"
    }
  },
  {
    "qid": {
      "en-US": "5-31"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "インタフェースの作成と実装"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイル、実行できる。",
        "B. コンパイルエラーが発生する。",
        "C. コンパイルは成功するが、実行時にエラーが発生する。",
        "D. `printUsage` が2回呼び出される。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "interface Utility {\n // インターフェースの static メソッド (Java 8以降)\n static void printUsage() {\n  System.out.println(\"Usage: Utility tool\");\n }\n\n default void performAction() {\n  System.out.println(\"Action performed\");\n }\n}\n\nclass Tool implements Utility {}\n\npublic class TestInterfaceStatic {\n public static void main(String[] args) {\n  Utility.printUsage(); // ① インターフェース名で呼び出し\n\n  Tool tool = new Tool();\n  // tool.printUsage(); // ② インスタンス経由では呼び出せない\n  tool.performAction(); // ③ defaultメソッドは呼び出せる\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムについて、コメントアウトされている②の行 `tool.printUsage();` のコメントを外した場合、どのような結果になりますか。"
    },
    "explanation": {
      "en-US": "インターフェースの `static` メソッドは、そのインターフェースに固有のメソッドであり、実装クラスには継承されません。そのため、`static` メソッドを呼び出すには、クラスの `static` メソッドと同様に `インターフェース名.メソッド名()` の形式を使用する必要があります（①）。実装クラスのインスタンス（②の `tool`）を通じてインターフェースの `static` メソッドを呼び出すことはできません。したがって、②の行のコメントを外すとコンパイルエラーが発生します。③の `default` メソッドはインスタンス経由で呼び出せます。"
    },
    "questionCategory": {
      "en-US": "インターフェースの static メソッド"
    }
  },
  {
    "qid": {
      "en-US": "5-32"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "インタフェースの作成と実装"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. インターフェース `Constants` でフィールドを宣言するとコンパイルエラーになる。",
        "B. `UseConstants` クラスから `MAX_VALUE` にアクセスできない。",
        "C. `MAX_VALUE` は `final` なので、再代入しようとするとコンパイルエラーになる。",
        "D. `Constants.DEFAULT_NAME` のようにインターフェース名で修飾しないとアクセスできない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "interface Constants {\n int MAX_VALUE = 100; // 暗黙的に public static final\n String DEFAULT_NAME = \"Guest\";\n}\n\npublic class UseConstants implements Constants {\n public static void main(String[] args) {\n  System.out.println(MAX_VALUE);\n  System.out.println(Constants.DEFAULT_NAME);\n  // MAX_VALUE = 200; // コンパイルエラー (final)\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェース内で宣言されたフィールドは、明示的に修飾子を付けなくても暗黙的に `public static final` となります（つまり定数）。Aは誤り。`static` なので、インターフェース名を使って `Constants.DEFAULT_NAME` のようにアクセスできます。また、そのインターフェースを実装したクラス内では、定数名を直接（`MAX_VALUE`）参照することも可能です(B, D誤り)。`final` であるため、一度初期化された後に値を変更（再代入）しようとするとコンパイルエラーになります(C正)。"
    },
    "questionCategory": {
      "en-US": "インターフェースの定数フィールド"
    }
  },
  {
    "qid": {
      "en-US": "5-33"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. ①のキャストは、`r` が `Writable` も実装している保証がないため、コンパイルエラーになる。",
        "B. ①のキャストは、実行時に `r` が実際に `Writable` を実装したオブジェクト（ここでは`ReadWriter`）を参照しているため成功する。",
        "C. ②のキャストは、`w` が `ReadWriter` のスーパータイプであるため成功する。",
        "D. `w.close()` は、`Writable` インターフェースに `close()` がなくても呼び出せる。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "interface Readable { void read(); }\ninterface Writable { void write(); }\n\nclass ReadWriter implements Readable, Writable {\n public void read() { System.out.println(\"Reading...\"); }\n public void write() { System.out.println(\"Writing...\"); }\n public void close() { System.out.println(\"Closing...\"); }\n}\n\npublic class TestMultiInterface {\n public static void main(String[] args) {\n  Readable r = new ReadWriter();\n  Writable w = (Writable) r; // ① ReadableからWritableへキャスト\n  // ReadWriter rw = (ReadWriter) w; // ② WritableからReadWriterへ\n\n  r.read();\n  w.write();\n  // w.close(); // コンパイルエラー\n  // rw.close(); // OK\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムについて、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェース間のキャストとインスタンスへのキャストについて。\n変数 `r` は `Readable` 型ですが、実際に参照しているのは `ReadWriter` のインスタンスです。`ReadWriter` は `Readable` と `Writable` の両方を実装しています。\n① `(Writable) r`: `r` が参照するオブジェクトが `Writable` インターフェースも実装しているかをチェックします。実際には `ReadWriter` なので実装しており、キャストは実行時に成功します(B正)。コンパイラは `Readable` と `Writable` の間に直接の関係がなくても、実装クラスが存在する可能性があると判断し、コンパイルエラーにはしません(A誤)。\n② `(ReadWriter) w`: `w` が参照するオブジェクトが `ReadWriter` のインスタンスであるかをチェックします。実際には `ReadWriter` なので、キャストは成功します(Cは理由が不正確だが結果は成功)。\nD: 変数 `w` の型は `Writable` であり、`Writable` には `close()` メソッドが定義されていないため、`w.close()` はコンパイルエラーになります。"
    },
    "questionCategory": {
      "en-US": "複数インターフェース実装とキャスト"
    }
  },
  {
    "qid": {
      "en-US": "5-34"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Woof\"",
        "B. \"Animal sound\"",
        "C. \"Animal sound\" の後に \"Woof\"",
        "D. \"Woof\" の後に \"Animal sound\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "class Animal {\n void makeSound() { System.out.println(\"Animal sound\"); }\n}\n\nclass Dog extends Animal {\n @Override\n void makeSound() {\n  super.makeSound(); // スーパークラスのメソッドを呼び出す\n  System.out.println(\"Woof\");\n }\n}\n\npublic class TestSuperCall {\n public static void main(String[] args) {\n  Dog myDog = new Dog();\n  myDog.makeSound();\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "サブクラスでメソッドをオーバーライドした際に、スーパークラスの元のメソッドを呼び出すには `super.メソッド名()` を使用します。`Dog` クラスの `makeSound` メソッドでは、まず `super.makeSound()` によって `Animal` クラスの `makeSound` メソッドが呼び出され、「Animal sound」が出力されます。その後、`System.out.println(\"Woof\")` が実行され、「Woof」が出力されます。したがって、出力は「Animal sound」の後に「Woof」となります。"
    },
    "questionCategory": {
      "en-US": "superキーワードによるスーパークラスメソッド呼び出し"
    }
  },
  {
    "qid": {
      "en-US": "5-35"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルできるが、インスタンス化も継承もできない。",
        "B. コンパイルエラーが発生する。",
        "C. `abstract` が優先され、`final` は無視される。",
        "D. `final` が優先され、`abstract` は無視される。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// abstract と final を同時にクラスに付けようとする\nabstract final class Shape {\n // ...\n}\n\npublic class TestAbstractFinal {\n // ...\n}"
    },
    "questionText": {
      "en-US": "こののクラス `Shape` の宣言について、正しい説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "`abstract` キーワードは、クラスが抽象的であり、サブクラスによって継承され、抽象メソッドが実装されることを意図しています。一方、`final` キーワードは、クラスがこれ以上継承されることを禁止します。この2つのキーワードの意味は互いに矛盾するため、Javaでは `abstract` と `final` を同時にクラスに指定することはできません。したがって、このクラス宣言はコンパイルエラーとなります。"
    },
    "questionCategory": {
      "en-US": "abstract と final の組み合わせ不可"
    }
  },
  {
    "qid": {
      "en-US": "5-36"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"E:101 \"",
        "B. \"P:Dev \"",
        "C. \"P:Dev E:101 \"",
        "D. \"E:101 P:Dev \"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "class Person {\n String name;\n Person(String name) {\n  this.name = name;\n  System.out.print(\"P:\" + name + \" \");\n }\n}\n\nclass Employee extends Person {\n int id;\n Employee(String name, int id) {\n  super(name); // スーパークラスの引数ありコンストラクタ呼び出し\n  this.id = id;\n  System.out.print(\"E:\" + id + \" \");\n }\n}\n\npublic class TestEmpConstructor {\n public static void main(String[] args) {\n  Employee emp = new Employee(\"Dev\", 101);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "サブクラスのコンストラクタでは、最初にスーパークラスのコンストラクタが呼び出されます。ここでは `Employee` のコンストラクタが `super(name)` を呼び出しているため、まず `Person` の引数ありコンストラクタ `Person(String name)` が実行されます。これにより「P:Dev 」が出力されます。その後、`Employee` コンストラクタの残りの部分が実行され、「E:101 」が出力されます。したがって、最終的な出力は「P:Dev E:101 」となります。"
    },
    "questionCategory": {
      "en-US": "コンストラクタ連鎖（引数ありsuper）"
    }
  },
  {
    "qid": {
      "en-US": "5-37"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. このクラスはどのクラスも継承していない。",
        "B. このクラスは暗黙的に `java.lang.Object` クラスを継承している。",
        "C. `toString()` メソッドを持たないため、`data.toString()` はコンパイルエラーになる。",
        "D. インスタンス化できない。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "class MyData {\n // extends Object は省略されている\n private int value;\n // toString, equals, hashCode などは未定義\n}\n\npublic class TestObjectMethods {\n public static void main(String[] args) {\n  MyData data = new MyData();\n  System.out.println(data.toString()); // 呼び出し可能\n }\n}"
    },
    "questionText": {
      "en-US": "このの `MyData` クラスのように、明示的に他のクラスを継承していないクラスに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaでは、明示的に `extends` キーワードを使って他のクラスを継承していないクラスは、すべて暗黙的に `java.lang.Object` クラスを直接のスーパー（親）クラスとして継承します。`Object` クラスはJavaのクラス階層の最上位に位置します。そのため、`MyData` クラスも `Object` クラスを継承しており、`Object` クラスで定義されているメソッド（例: `toString()`, `equals()`, `hashCode()` など）を利用（またはオーバーライド）することができます。したがって、Bが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "Objectクラスの暗黙的な継承"
    }
  },
  {
    "qid": {
      "en-US": "5-38"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 抽象クラスはインスタンスフィールド（非staticフィールド）を持つことができるが、インターフェースは（定数以外の）インスタンスフィールドを持てない。",
        "B. クラスは複数のインターフェースを実装できるが、継承できるクラス（抽象クラスを含む）は1つだけである。",
        "C. 抽象クラスはコンストラクタを持つことができるが、インターフェースはコンストラクタを持てない。",
        "D. 抽象クラスは抽象メソッドしか持てないが、インターフェースは具象メソッド（デフォルトメソッドなど）も持てる。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "抽象クラスとインターフェースの違いに関する説明として、 *誤っている* ものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "A, B, C は抽象クラスとインターフェースの正しい違いを示しています。Dは誤りです。抽象クラスは抽象メソッド *だけでなく*、具象メソッド（本体を持つメソッド）も持つことができます。一方、インターフェースもJava 8以降、`default` メソッドや `static` メソッドといった具象メソッドを持つことができます。したがって、「抽象クラスは抽象メソッドしか持てない」という部分が誤りです。"
    },
    "questionCategory": {
      "en-US": "抽象クラスとインターフェースの比較"
    }
  },
  {
    "qid": {
      "en-US": "5-39"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `AbstractRunner` は `run()` を実装しないとコンパイルエラー。",
        "B. `AbstractRunner` は `stop()` を実装しないとコンパイルエラー。",
        "C. `ConcreteRunner` は `run()` を実装しないとコンパイルエラー。",
        "D. プログラムは正常にコンパイル、実行され、「Default Run」と「Stopped」が表示される。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "interface Runner {\n default void run() { System.out.println(\"Default Run\"); }\n void stop(); // 抽象メソッド\n}\n\n// インターフェースを実装する抽象クラス\nabstract class AbstractRunner implements Runner {\n // run() は実装しなくてもよい (default実装が継承される)\n // stop() も実装しなくてもよい (抽象クラスだから)\n public void start() { System.out.println(\"Started\"); }\n}\n\n// 具象サブクラス\nclass ConcreteRunner extends AbstractRunner {\n @Override public void stop() { System.out.println(\"Stopped\"); }\n // run() は AbstractRunner から継承された default 実装を使う\n}\n\npublic class TestAbstractImpl {\n public static void main(String[] args) {\n  ConcreteRunner cr = new ConcreteRunner();\n  cr.run();\n  cr.stop();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェースを実装するクラスが `abstract` クラスである場合、その抽象クラスはインターフェースの抽象メソッドを実装する義務を負いません（実装をさらにサブクラスに任せることができます）。また、インターフェースの `default` メソッドは、実装クラスでオーバーライドされなければ、そのまま継承されます。`AbstractRunner` は `abstract` なので `stop()` を実装しなくてもよく、`run()` は `default` 実装を継承します。`ConcreteRunner` は具象クラスなので抽象メソッド `stop()` を実装する必要がありますが、`run()` は `AbstractRunner` から継承した `Runner` の `default` 実装を使用できます。したがって、プログラムは正常に動作し、`cr.run()` ではデフォルト実装が、`cr.stop()` では `ConcreteRunner` の実装が実行されます。"
    },
    "questionCategory": {
      "en-US": "抽象クラスによるデフォルトメソッドの実装省略"
    }
  },
  {
    "qid": {
      "en-US": "5-40"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 実装クラスがこれらのメソッドをオーバーライドできるようになる。",
        "B. インターフェースの外部から直接呼び出すことができるようになる。",
        "C. インターフェース内の `default` メソッドや `static` メソッドの共通ロジックを抽出し、コードの重複を減らすことができる。",
        "D. インターフェースの定数フィールドを初期化するために使用される。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "interface Processor {\n default void processData(String data) {\n  if (isValid(data)) { // private メソッド呼び出し\n   execute(data);\n  } else {\n   logError(\"Invalid data\");\n  }\n }\n\n private boolean isValid(String data) {\n  return data != null && !data.isBlank();\n }\n private void logError(String error) {\n  System.err.println(\"ERROR: \" + error);\n }\n void execute(String data); // 抽象メソッド\n}"
    },
    "questionText": {
      "en-US": "このの `Processor` インターフェースにおける `private` メソッド (`isValid`, `logError`) の主な利点として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェースの `private` メソッドは、そのインターフェースの外部（実装クラスを含む）からはアクセスできません。その主な目的は、インターフェース内に複数の `default` メソッドや `static` メソッドがあり、それらの間で共通して使用される補助的な処理がある場合に、その共通ロジックを `private` メソッドとして切り出すことです。これにより、コードの重複を避け、インターフェース内の実装をより整理し、保守しやすくすることができます。"
    },
    "questionCategory": {
      "en-US": "インターフェースの private メソッド利用"
    }
  },
  {
    "qid": {
      "en-US": "5-41"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Success\"",
        "B. \"ArrayStoreException caught\"",
        "C. \"Other exception\"",
        "D. コンパイルエラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class ArrayCovariance {\n public static void main(String[] args) {\n  Integer[] integerArray = {1, 2, 3};\n  Number[] numberArray = integerArray; // 配列は共変\n\n  try {\n   // Number配列にDoubleを追加しようとする\n   numberArray[0] = Double.valueOf(10.5); // ①\n   System.out.println(\"Success\");\n  } catch (ArrayStoreException e) {\n   System.out.println(\"ArrayStoreException caught\");\n  } catch (Exception e) {\n   System.out.println(\"Other exception\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "Javaの配列は共変 (covariant) です。これは、`Integer` が `Number` のサブタイプである場合、`Integer[]` も `Number[]` のサブタイプとして扱われることを意味します。そのため、`Number[] numberArray = integerArray;` という代入はコンパイル時に許可されます。しかし、`numberArray` が実際に参照しているのは `Integer` の要素しか格納できない配列です。①の行で、`Number` 配列として参照している変数 `numberArray` を使って、互換性のない型（`Double`）の要素を代入しようとすると、実行時に配列の実際の型（`Integer[]`）との不整合が検出され、`ArrayStoreException` がスローされます。この例外が `catch` ブロックで捕捉され、「ArrayStoreException caught」が表示されます。"
    },
    "questionCategory": {
      "en-US": "配列の共変性とArrayStoreException"
    }
  },
  {
    "qid": {
      "en-US": "5-42"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "シール・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `public` のみ",
        "B. `final` のみ",
        "C. `final`, `sealed`, `non-sealed` のいずれか1つ",
        "D. `abstract` または `final` のいずれか1つ",
        "E. 特に必須の修飾子はない"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public sealed interface Vehicle permits Car, Truck {\n // ...\n}\n\n// Vehicle を実装するクラス/インターフェースの宣言"
    },
    "questionText": {
      "en-US": "このの `Vehicle` シールインターフェースを実装または継承するクラスやインターフェース（`Car` または `Truck`）を宣言する際に、 *必須となる* 修飾子はどれですか。"
    },
    "explanation": {
      "en-US": "`sealed` クラスまたはインターフェースを直接継承または実装するクラスやインターフェースは、`permits` 句で許可されている必要があり、かつ、自身の宣言に `final`, `sealed`, `non-sealed` のいずれかの修飾子を明示的に指定しなければなりません。これにより、クラス階層の拡張性がどのように制御されるかをコンパイラと開発者に明確に伝えます。"
    },
    "questionCategory": {
      "en-US": "シールインターフェースのサブタイプ修飾子"
    }
  },
  {
    "qid": {
      "en-US": "5-43"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "シール・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `ImageMessage` はこれ以上継承できない。",
        "B. `ImageMessage` を継承するクラス（`GifMessage`, `JpegMessage`）は、`permits` 句で明示的に許可される必要がある。",
        "C. `ImageMessage` を継承するクラスは、`final` または `sealed` でなければならない。",
        "D. `ImageMessage` を継承するクラスは、特に制限なく自由に定義でき、`final`, `sealed`, `non-sealed` のいずれの修飾子も必須ではない。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public sealed class Message permits TextMessage, ImageMessage {}\npublic final class TextMessage extends Message {}\npublic non-sealed class ImageMessage extends Message {} // non-sealed\n\n// ImageMessage を継承するクラス\npublic class GifMessage extends ImageMessage {}\npublic class JpegMessage extends ImageMessage {}"
    },
    "questionText": {
      "en-US": "こののクラス階層において、`non-sealed` クラスである `ImageMessage` に関する説明として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`sealed` クラスまたはインターフェースのサブクラスが `non-sealed` と宣言されると、そのクラスに対するシール（継承制限）が解除されます。つまり、`non-sealed` クラスは、通常の（シールされていない）クラスと同様に、どのクラスからでも自由に継承できるようになります。そのサブクラス（例: `GifMessage`, `JpegMessage`）に対しては、`final`, `sealed`, `non-sealed` といった特別な修飾子は要求されません。"
    },
    "questionCategory": {
      "en-US": "non-sealed クラスの特性"
    }
  },
  {
    "qid": {
      "en-US": "5-44"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Parent,Parent\"",
        "B. \"Parent,Child\"",
        "C. \"Child,Parent\"",
        "D. \"Child,Child\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "class ParentType {\n String type = \"Parent\";\n String getType() { return type; }\n}\n\nclass ChildType extends ParentType {\n String type = \"Child\"; // フィールド隠蔽\n String getType() { return type; } // メソッドオーバーライド\n}\n\npublic class FieldVsMethod {\n public static void main(String[] args) {\n  ParentType p = new ChildType();\n  System.out.print(p.type + \",\"); // ① フィールドアクセス\n  System.out.print(p.getType()); // ② メソッド呼び出し\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "フィールドアクセスとメソッド呼び出しでは、ポリモーフィズムの適用が異なります。\n① フィールドアクセス (`p.type`): フィールドはポリモーフィズムの対象外です。アクセスされるフィールドは、変数の宣言型（ここでは `ParentType`）に基づいてコンパイル時に決定されます。したがって、`ParentType` の `type` フィールドの値 \"Parent\" が参照されます。\n② メソッド呼び出し (`p.getType()`): メソッド呼び出しはポリモーフィズムの対象です。呼び出されるメソッドは、実行時のインスタンスの型（ここでは `ChildType`）に基づいて決定されます。`ChildType` は `getType` メソッドをオーバーライドしているため、`ChildType` の `getType` メソッドが実行され、その内部の `type`（`ChildType` のフィールド \"Child\"）が返されます。\nしたがって、出力は \"Parent,Child\" となります。"
    },
    "questionCategory": {
      "en-US": "ポリモーフィズムとフィールドアクセス（再掲類似）"
    }
  },
  {
    "qid": {
      "en-US": "5-45"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Hello!\"",
        "B. \"getGreeting!\"",
        "C. コンパイルエラー（抽象クラスはインスタンス化できない）",
        "D. コンパイルエラー（匿名クラス内でメソッドをオーバーライドできない）",
        "E. 実行時エラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "abstract class Greeter {\n abstract String getGreeting();\n void sayHi() {\n  System.out.println(getGreeting() + \"!\");\n }\n}\n\npublic class AnonymousAbstract {\n public static void main(String[] args) {\n  // 抽象クラスを継承する匿名クラスをその場で定義・インスタンス化\n  Greeter englishGreeter = new Greeter() {\n   @Override\n   String getGreeting() {\n    return \"Hello\";\n   }\n  };\n  englishGreeter.sayHi();\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "抽象クラスは `new` 演算子で直接インスタンス化できませんが、抽象クラスを継承する匿名クラスをその場で定義し、その匿名クラスのインスタンスを生成することは可能です。このコードでは、`new Greeter() { ... }` の部分が、`Greeter` を継承し抽象メソッド `getGreeting` を実装した匿名クラスの定義とそのインスタンス化を行っています。`englishGreeter` はこの匿名クラスのインスタンスを参照します。`englishGreeter.sayHi()` を呼び出すと、継承した `sayHi` メソッドが実行され、その内部で `getGreeting()` が呼び出されます。これは匿名クラスでオーバーライドされた実装が実行され、\"Hello\" を返します。結果として \"Hello!\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "抽象クラスの匿名クラスによるインスタンス化"
    }
  },
  {
    "qid": {
      "en-US": "5-46"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Default Notify: Update\" と \"Default Notify: Alert\"",
        "B. \"Email Notify: Update\" と \"Sms Notify: Alert\"",
        "C. \"Email Notify: Update\" と \"Default Notify: Alert\"",
        "D. コンパイルエラーが発生する",
        "E. 実行時エラーが発生する"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "interface Notifier {\n default void notify(String msg) {\n  System.out.println(\"Default Notify: \" + msg);\n }\n}\n\nclass EmailNotifier implements Notifier {\n // デフォルトメソッドをオーバーライド\n @Override\n public void notify(String msg) {\n  System.out.println(\"Email Notify: \" + msg);\n }\n}\n\nclass SmsNotifier implements Notifier {\n // デフォルト実装をそのまま使用\n}\n\npublic class TestDefaultOverride {\n public static void main(String[] args) {\n  Notifier n1 = new EmailNotifier();\n  Notifier n2 = new SmsNotifier();\n  n1.notify(\"Update\");\n  n2.notify(\"Alert\");\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "インターフェースの `default` メソッドは、実装クラスでオーバーライドされなければ、そのデフォルト実装が使用されます。オーバーライドされた場合は、通常のメソッドと同様に、実行時のインスタンスの型でオーバーライドされたメソッドが呼び出されます。\n- `n1` は `EmailNotifier` インスタンスを参照。`EmailNotifier` は `notify` をオーバーライドしているので、そのメソッドが実行され「Email Notify: Update」が表示される。\n- `n2` は `SmsNotifier` インスタンスを参照。`SmsNotifier` は `notify` をオーバーライドしていないので、インターフェース `Notifier` のデフォルト実装が実行され「Default Notify: Alert」が表示される。\nしたがって、Cが正しい出力です。"
    },
    "questionCategory": {
      "en-US": "デフォルトメソッドのオーバーライドとポリモーフィズム"
    }
  },
  {
    "qid": {
      "en-US": "5-47"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `throws Exception` を記述しても問題ない。",
        "B. `throws IOException` またはそのサブクラス、または非チェック例外のみ記述できる。",
        "C. スーパークラスがスローする例外より広い範囲のチェック例外（例: `Exception`）を `throws` 句に記述するとコンパイルエラーになる。",
        "D. `throws` 句を完全に省略することはできない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "import java.io.IOException;\n\nclass BaseAction {\n void perform() throws IOException { // チェック例外をスローする可能性\n  System.out.println(\"Base perform\");\n }\n}\n\nclass SubAction extends BaseAction {\n // オーバーライドするメソッド\n @Override\n void perform() /* throws Exception */ { // スローする例外を変更\n  System.out.println(\"Sub perform\");\n  // IOException は Exception のサブクラス\n }\n}"
    },
    "questionText": {
      "en-US": "このの `SubAction` クラスの `perform` メソッドの `throws` 句に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッドをオーバーライドする際、`throws` 句に指定できるチェック例外には制限があります。サブクラスのメソッドは、スーパークラスのメソッドがスローすると宣言しているチェック例外、またはそのチェック例外のサブクラス、あるいはチェック例外をまったくスローしない（`throws` 句を省略または非チェック例外のみ）ように宣言しなければなりません。スーパークラスのメソッドがスローしない新しいチェック例外や、より広い範囲のチェック例外（スーパークラスの例外のスーパークラス、例: `Exception`）をスローするように宣言することはできません。したがって、`throws Exception` を記述するとコンパイルエラーになります(C)。Bが正しいルール説明です。Dは省略可能です。"
    },
    "questionCategory": {
      "en-US": "オーバーライドと例外のスロー"
    }
  },
  {
    "qid": {
      "en-US": "5-48"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされるが、実行時に `ClassCastException` が発生する。",
        "B. コンパイルエラーが発生する。",
        "C. 正常にコンパイル、実行できる。",
        "D. コンパイル時に警告が出るが、実行はできる。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "class Apple {}\nclass Orange {}\n\npublic class FruitCast {\n public static void main(String[] args) {\n  Apple apple = new Apple();\n  // Orange orange = (Orange) apple; // ← キャスト試行\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムでコメントアウトされた行 `Orange orange = (Orange) apple;` のコメントを外した場合、どのような結果になりますか。"
    },
    "explanation": {
      "en-US": "Javaコンパイラは、キャスト操作の妥当性をコンパイル時にチェックします。ある型から別の型へのキャストが明らかに不可能である（継承関係が全くない）場合、コンパイラはそのキャストをエラーとして報告します。`Apple` クラスと `Orange` クラスの間には何の継承関係もありません。したがって、`Apple` 型のオブジェクトを `Orange` 型にキャストしようとするコード `(Orange) apple` は、コンパイル時にエラーとなります。"
    },
    "questionCategory": {
      "en-US": "互換性のない型へのキャスト（コンパイル時チェック）"
    }
  },
  {
    "qid": {
      "en-US": "5-49"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "アクセス修飾子の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイル、実行できる。",
        "B. コンパイルエラーが発生する。",
        "C. コンパイルは成功するが、実行時に `IllegalAccessException` が発生する。",
        "D. `Service` クラスに `public` なコンストラクタがないとエラーになる。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// pkgA/Service.java\npackage pkgA;\npublic class Service {\n protected void init() { System.out.println(\"Service Init\"); }\n}\n\n// pkgB/Client.java\npackage pkgB;\nimport pkgA.Service;\n\npublic class Client /* extends Service */ {\n public void setup() {\n  Service s = new Service();\n  // s.init(); // ← アクセス試行\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Client` クラス（`Service` を継承していない）の `setup` メソッド内で、コメントアウトされた行 `s.init();` のコメントを外した場合、どのような結果になりますか。"
    },
    "explanation": {
      "en-US": "`protected` メンバーは、同じパッケージ内のクラス、または異なるパッケージにあるサブクラスからアクセスできます。`Client` クラスは `pkgB` にあり、`Service` クラス（`pkgA`）とは異なるパッケージに属しています。さらに、`Client` は `Service` を継承していません。したがって、`Client` クラス内から `Service` インスタンス `s` を通じて `protected` メソッド `init()` を呼び出すことは許可されておらず、コンパイルエラーとなります。"
    },
    "questionCategory": {
      "en-US": "異なるパッケージからのprotectedメソッド呼び出し（サブクラス外）"
    }
  },
  {
    "qid": {
      "en-US": "5-50"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "抽象クラスの作成と継承"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 抽象クラスは `static` メソッドを持てないため、コンパイルエラーになる。",
        "B. `static` メソッドは抽象クラスからは呼び出せないため、コンパイルエラーになる。",
        "C. プログラムは正常にコンパイル・実行され、「Static utility method」が表示される。",
        "D. 実行時に `AbstractMethodError` が発生する。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "abstract class AbstractUtil {\n static void utilityMethod() {\n  System.out.println(\"Static utility method\");\n }\n abstract void process();\n}\n\npublic class TestAbstractStatic {\n public static void main(String[] args) {\n  // AbstractUtil util = new AbstractUtil(); // NG\n  AbstractUtil.utilityMethod(); // staticメソッドはクラス名で呼べる\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "抽象クラスも通常のクラスと同様に `static` メソッドを持つことができます(A誤)。`static` メソッドはクラスに属するため、クラス名を指定して（例: `AbstractUtil.utilityMethod()`）呼び出すことができます。インスタンス化できないこととは無関係です(B誤)。このコードでは、`main` メソッドから `AbstractUtil.utilityMethod()` を正しく呼び出しており、メッセージが表示されます(C正)。抽象メソッド `process()` は呼び出されていないためエラーは発生しません(D誤)。"
    },
    "questionCategory": {
      "en-US": "抽象クラスの static メソッド"
    }
  },
  {
    "qid": {
      "en-US": "5-51"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Base\"",
        "B. \"Impl\"",
        "C. コンパイルエラー (`SubIF` で `execute` を再宣言できない)",
        "D. コンパイルエラー (`MyImpl` で `execute` を実装する必要がない)"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "interface BaseIF {\n default void execute() { System.out.println(\"Base\"); }\n}\n\n// サブインターフェースで execute を抽象メソッドとして再宣言\ninterface SubIF extends BaseIF {\n @Override\n void execute();\n}\n\n// 実装クラス\nclass MyImpl implements SubIF {\n // SubIF の抽象メソッド execute を実装する必要がある\n @Override\n public void execute() { System.out.println(\"Impl\"); }\n}\n\npublic class TestDefaultAbstract {\n public static void main(String[] args) {\n  MyImpl obj = new MyImpl();\n  obj.execute();\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "サブインターフェース (`SubIF`) は、スーパーインターフェース (`BaseIF`) の `default` メソッドを、`abstract` メソッドとして再宣言することができます。これにより、`SubIF` を実装するクラスは、そのメソッドを実装する義務を負うことになります。`MyImpl` は `SubIF` を実装し、`execute` メソッドをオーバーライドして \"Impl\" を出力するように実装しています。したがって、`main` メソッドで `obj.execute()` を呼び出すと、`MyImpl` クラスの実装が実行され、「Impl」が表示されます。"
    },
    "questionCategory": {
      "en-US": "インターフェース継承とデフォルトメソッド再宣言"
    }
  },
  {
    "qid": {
      "en-US": "5-52"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "final クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `final` クラス内のメソッドは、すべて暗黙的に `final` になる。",
        "B. `final` クラス内のメソッドに `final` を付けるとコンパイルエラーになる。",
        "C. `final` クラスは継承できないが、その中のメソッド（`final` でないもの）は、もし継承できればオーバーライド可能である。",
        "D. `final` クラスは抽象メソッドを持つことができる。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "final class FinalClass {\n // final クラス内のメソッド\n public void display() {\n  System.out.println(\"Display in final class\");\n }\n\n public final void finalDisplay() {\n  System.out.println(\"Final display in final class\");\n }\n}"
    },
    "questionText": {
      "en-US": "このの `FinalClass` の定義に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`final` クラスは継承が禁止されます。クラス自体が `final` であっても、その内部のメソッドが自動的に `final` になるわけではありません(A誤)。メソッドに明示的に `final` を付けることは可能であり、エラーにはなりません(B誤)。`final` クラスは継承できないため、そのメソッドがオーバーライドされる機会は実際にはありませんが、もし仮に継承が可能だったとしたら、`final` が付いていないメソッドはオーバーライドの対象となりえます(C正)。`final` クラスはインスタンス化可能である必要があり、抽象メソッドを持つことはできません(D誤)。"
    },
    "questionCategory": {
      "en-US": "final クラス内のメソッド"
    }
  },
  {
    "qid": {
      "en-US": "5-53"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"true\" の後に \"true\"",
        "B. \"true\" の後に \"false\"",
        "C. \"false\" の後に \"true\"",
        "D. 実行時に `NullPointerException`",
        "E. 実行時に `ClassCastException`"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class NullCast {\n public static void main(String[] args) {\n  String s = null;\n  Object o = (Object) s; // null を Object にキャスト\n  String s2 = (String) o; // null を String にキャスト\n\n  System.out.println(o == null); // ①\n  System.out.println(s2 == null); // ②\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した際のコンソール出力として、正しいものを1つ選びなさい。"
    },
    "explanation": {
      "en-US": "`null` 参照はどの参照型にもキャストすることができます。キャスト操作自体は成功し、結果も `null` のままです。`null` を `Object` にキャストしても `null` であり、それをさらに `String` にキャストしても `null` です。キャスト時に `ClassCastException` は発生しません。`println` で `null == null` を評価すると `true` になります。したがって、①も②も `true` となり、「true」が2回表示されます。"
    },
    "questionCategory": {
      "en-US": "null 参照のキャスト"
    }
  },
  {
    "qid": {
      "en-US": "5-54"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "シール・クラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `switch` 式でシールクラス（インターフェース）の全サブタイプが `case` で網羅されている場合でも、`default` 句が必須である。",
        "B. `switch` 式でシールクラス（インターフェース）の全サブタイプが `case` で網羅されている場合、コンパイラはそれを認識し、`default` 句は不要になる。",
        "C. `case Circle c` のようにパターン変数を宣言することはできない。",
        "D. シールクラス（インターフェース）は `switch` 式のセレクタとして使用できない。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "sealed interface Shape permits Circle, Square {}\nfinal class Circle implements Shape { double radius; /*...*/ }\nfinal class Square implements Shape { double side; /*...*/ }\n\npublic class TestSealedSwitch {\n double getArea(Shape shape) {\n  // シールクラス/IF と switch のパターンマッチング\n  return switch (shape) {\n   case Circle c -> Math.PI * c.radius * c.radius;\n   case Square s -> s.side * s.side;\n   // permits で全サブタイプが網羅されている場合、default不要\n  };\n }\n // main メソッド等での利用を想定\n}"
    },
    "questionText": {
      "en-US": "こののコードは Java 17 以降のシールクラス（インターフェース）と `switch` 式のパターンマッチングの組み合わせを示しています。このコードに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`switch` 式（または `switch` 文）でシールクラスまたはシールインターフェースのインスタンスを評価する場合、コンパイラは `permits` 句で指定されたすべての直接のサブタイプが `case` ラベル（パターンマッチングを含む）で網羅されているかどうかをチェックできます。もしすべてのサブタイプが網羅されていれば、それ以外の可能性はないため、`default` 句は不要になります（記述してもよいが冗長）。このコード例では `Circle` と `Square` が `Shape` の許可された全サブタイプであり、両方が `case` で扱われているため、`default` は不要です(B)。A, C, Dは誤りです。"
    },
    "questionCategory": {
      "en-US": "シールクラスと switch パターンマッチング"
    }
  },
  {
    "qid": {
      "en-US": "5-55"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "インタフェースの作成と実装"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `AppConfig` クラスはインターフェース定数にアクセスできないためコンパイルエラー。",
        "B. `DEFAULT_HOST` は `static` なので `AppConfig` 内では `ConfigSettings.DEFAULT_HOST` と書く必要がある。",
        "C. プログラムは正常にコンパイル・実行され、デフォルト設定が表示される。",
        "D. `main` メソッドから `ConfigSettings.DEFAULT_HOST` にアクセスできない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "interface ConfigSettings {\n String DEFAULT_HOST = \"localhost\";\n int DEFAULT_PORT = 8080;\n}\n\nclass AppConfig implements ConfigSettings {\n void displayDefaults() {\n  // インターフェースの定数にアクセス\n  System.out.println(\"Host: \" + DEFAULT_HOST);\n  System.out.println(\"Port: \" + ConfigSettings.DEFAULT_PORT);\n }\n}\n\npublic class TestInterfaceConst {\n public static void main(String[] args) {\n  AppConfig config = new AppConfig();\n  config.displayDefaults();\n  System.out.println(ConfigSettings.DEFAULT_HOST);\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "インターフェースで宣言されたフィールドは暗黙的に `public static final` です。`static` なので、`インターフェース名.フィールド名`（例: `ConfigSettings.DEFAULT_PORT`）でアクセスできます(D誤)。また、そのインターフェースを実装したクラス（`AppConfig`）内では、フィールド名を直接（例: `DEFAULT_HOST`）参照することも可能です(A, B誤り)。したがって、`displayDefaults` メソッド内のアクセスも `main` メソッドからのアクセスも正しく、プログラムは正常に動作します(C正)。"
    },
    "questionCategory": {
      "en-US": "インターフェース定数の利用方法"
    }
  },
  {
    "qid": {
      "en-US": "5-56"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "メソッドのオーバーライド"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 何も変わらず、プログラムは正常に動作する。",
        "B. コンパイルエラーが発生する（メソッドがオーバーライドされていないため）。",
        "C. 実行時にエラーが発生するようになる。",
        "D. `@Override` は単なるコメントであり、影響はない。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "class Vehicle {\n void start() { System.out.println(\"Vehicle starting\"); }\n}\n\nclass Car extends Vehicle {\n // メソッド名をタイポ (start -> star)\n // @Override // ← コメントアウトされている\n void star() { System.out.println(\"Car starting\"); }\n}\n\npublic class TestOverrideAnnotation {\n public static void main(String[] args) {\n  Vehicle v = new Car();\n  v.start(); // 意図せず Vehicle の start が呼ばれる\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムで、`Car` クラスのメソッド宣言の前に `@Override` アノテーションを追加した場合、どのような結果になりますか。"
    },
    "explanation": {
      "en-US": "`@Override` アノテーションは、そのメソッドがスーパークラスまたはインターフェースのメソッドをオーバーライド（または実装）するものであることをコンパイラに伝えるためのものです。コンパイラは、アノテーションが付与されたメソッドが実際にオーバーライドのルールに従っているか（メソッド名、引数リストが一致するかなど）をチェックします。もしルールに違反していれば、コンパイラはエラーを報告します。このコードでは、`Car` クラスのメソッド名が `star` とタイポされており、スーパークラス `Vehicle` の `start` メソッドをオーバーライドしていません。`@Override` を付けると、この不一致がコンパイラによって検出され、コンパイルエラーが発生します。これにより、意図しない動作を防ぐことができます。"
    },
    "questionCategory": {
      "en-US": "@Override アノテーション"
    }
  },
  {
    "qid": {
      "en-US": "5-57"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "参照型のキャストとポリモーフィックなメソッド呼び出し"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされるが、実行時に `ClassCastException`",
        "B. コンパイルエラーが発生する",
        "C. 正常にコンパイル、実行できる",
        "D. コンパイル時に警告"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "class Dog {}\nclass Cat {}\n\npublic class AnimalCast {\n public static void main(String[] args) {\n  Dog dog = new Dog();\n  // Cat cat = (Cat) dog; // ← キャスト試行\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムでコメントアウトされた行 `Cat cat = (Cat) dog;` のコメントを外した場合、どのような結果になりますか。"
    },
    "explanation": {
      "en-US": "Javaでは、互いに継承関係のないクラス間のキャストは、コンパイル時にエラーとして検出されます。`Dog` クラスと `Cat` クラスの間には継承関係が存在しないため、`Dog` 型のオブジェクトを `Cat` 型にキャストしようとする `(Cat) dog` は明らかに不正であり、コンパイラはこれをエラーと判断します。"
    },
    "questionCategory": {
      "en-US": "継承関係のないクラス間のキャストエラー（再掲類似）"
    }
  },
  {
    "qid": {
      "en-US": "5-58"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "スーパークラスとサブクラスの作成と使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイル、実行される。",
        "B. `BaseComponent` クラスでコンパイルエラーが発生する。",
        "C. `SubComponent` クラスのコンストラクタでコンパイルエラーが発生する。",
        "D. `TestImplicitSuper` クラスの `main` メソッドでコンパイルエラーが発生する。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "class BaseComponent {\n // 引数ありコンストラクタのみ定義\n BaseComponent(String config) {\n  System.out.println(\"Base initialized with: \" + config);\n }\n}\n\nclass SubComponent extends BaseComponent {\n // サブクラスのコンストラクタ\n SubComponent() {\n  // super() や this() の明示的な呼び出しがない\n  // → 暗黙的に super() が呼ばれるが...\n  System.out.println(\"Sub initialized\");\n }\n}\n\npublic class TestImplicitSuper {\n public static void main(String[] args) {\n  // SubComponent sub = new SubComponent();\n }\n}"
    },
    "questionText": {
      "en-US": "こののクラス定義について、`main` メソッド内のコメントを外してコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "サブクラスのコンストラクタで `this(...)` または `super(...)` の明示的な呼び出しがない場合、コンパイラは暗黙的に引数なしのスーパークラスコンストラクタ `super()` を最初の文として挿入します。しかし、スーパークラス `BaseComponent` には引数ありのコンストラクタ `BaseComponent(String config)` しか定義されておらず、引数なしのコンストラクタ（デフォルトコンストラクタも含む）が存在しません。そのため、`SubComponent` のコンストラクタ内で暗黙的に呼び出そうとする `super()` が見つからず、`SubComponent` クラスのコンストラクタ定義でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "super()の暗黙呼び出しと引数なしコンストラクタ"
    }
  },
  {
    "qid": {
      "en-US": "5-59"
    },
    "chapter": {
      "en-US": "5章"
    },
    "category": {
      "en-US": "デフォルト・メソッドとプライベート・メソッドの使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `private static` メソッド `readFile` は、インターフェース外部から `Parser.readFile(...)` として呼び出せる。",
        "B. `private static` メソッド `readFile` は、インターフェース内の `static` メソッド (`parseFile`) からのみ呼び出せる。",
        "C. `private static` メソッド `readFile` は、インターフェース内の `static` メソッドおよび `default` メソッド (`processLine`) から呼び出すことができる。",
        "D. `private static` メソッドはインターフェースでは定義できない。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "interface Parser {\n static void parseFile(String filename) {\n  String content = readFile(filename); // private static呼び出し\n  System.out.println(\"Parsing: \" + content);\n }\n\n default void processLine(String line) {\n  // readFile(line); // defaultからprivate staticは呼べる\n  System.out.println(\"Processing: \" + line);\n }\n\n private static String readFile(String file) {\n  // ファイル読み込み処理 (仮)\n  return \"Content of \" + file;\n }\n}"
    },
    "questionText": {
      "en-US": "このの `Parser` インターフェースに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Java 9 以降、インターフェース内で `private static` メソッドを定義できます。\nA: `private` なのでインターフェース外部からは呼び出せません。\nB: `private static` メソッドは、同じインターフェース内の `static` メソッドおよび非 `static` (`default`, `private`インスタンス) メソッドの両方から呼び出し可能です。したがって、`static` メソッドからのみ呼び出せるという記述は不正確です。\nC: `private static` メソッドは、インターフェース内の `static` メソッド (`parseFile`) および `default` メソッド (`processLine`) から呼び出すことができる、という記述が正しいです。\nD: `private static` メソッドは定義できます。\nしたがって、Cが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "インターフェースの private static メソッド"
    }
  },
  {
    "qid": {
      "en-US": "6-1"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 「完了」",
        "B. 「エラー発生」",
        "C. 「完了」「エラー発生」",
        "D. 何も表示されない",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class BasicCatch {\n public static void main(String[] args) {\n  try {\n   int[] data = {}; // 空の配列\n   data[0] = 5; // 範囲外アクセス\n   System.out.println(\"完了\");\n  } catch (ArrayIndexOutOfBoundsException e) {\n   System.out.println(\"エラー発生\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合のコンソール出力として適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロック内で、要素数0の配列 `data` のインデックス0にアクセスしようとしています。これは配列の境界を超えるため、`ArrayIndexOutOfBoundsException` が発生します。この例外は `catch` ブロックで捕捉され、ブロック内の処理が実行されて「エラー発生」と表示されます。例外が発生したため、`try` ブロック内の残りの処理（`println(\"完了\")`）は実行されません。"
    },
    "questionCategory": {
      "en-US": "基本的な例外捕捉 (ArrayIndexOutOfBounds)"
    }
  },
  {
    "qid": {
      "en-US": "6-2"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"X\"",
        "B. \"Y\"",
        "C. \"Z\"",
        "D. \"XZ\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class FinallyTest {\n public static void main(String[] inputs) {\n  try {\n   if (inputs.length == 0) { // 引数なしの場合 true\n    System.out.print(\"X\");\n   }\n  } catch (IllegalArgumentException ex) {\n   System.out.print(\"Y\");\n  } finally {\n   System.out.print(\"Z\"); // 必ず実行\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを、コマンドライン引数を何も指定せずに実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`finally` ブロックは、`try` ブロックで例外が発生したかどうかに関わらず、通常必ず実行されます（JVMが終了する場合などを除く）。コマンドライン引数がない場合、`inputs.length` は 0 であり、`if` 文の条件は `true` となって「X」が表示されます。例外は発生しないため `catch` ブロックはスキップされます。その後、`finally` ブロックが実行され、「Z」が表示されます。したがって、出力は「XZ」となります。"
    },
    "questionCategory": {
      "en-US": "try-catch-finally の基本動作"
    }
  },
  {
    "qid": {
      "en-US": "6-3"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. コンパイルエラーが発生する",
        "C. コンパイルは成功するが実行時にエラー",
        "D. \"Base\" と表示される"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "class BaseError extends Exception {}\nclass SpecificError extends BaseError {}\n\npublic class CatchOrder {\n public static void main(String[] args) {\n  try {\n   handleBase();\n   handleSpecific();\n  } catch (BaseError e) { // ① スーパークラスが先\n   System.out.print(\"Base\");\n  } catch (SpecificError e) { // ② サブクラスが後\n   System.out.print(\"Specific\");\n  }\n }\n static void handleBase() throws BaseError {\n  throw new BaseError();\n }\n static void handleSpecific() throws SpecificError {\n  throw new SpecificError();\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "複数の `catch` ブロックを記述する場合、サブクラスの例外を捕捉する `catch` ブロックは、そのスーパークラスの例外を捕捉する `catch` ブロックよりも *前* に記述する必要があります。もしスーパークラスの `catch` が先にあると、サブクラスの例外もスーパークラスの `catch` で捕捉されてしまい、後続のサブクラスの `catch` ブロックには到達不可能 (unreachable) となるためです。このコードでは、スーパークラス `BaseError` の `catch` (①) がサブクラス `SpecificError` の `catch` (②) よりも先に記述されているため、②の `catch` ブロックが到達不能となり、コンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "catch ブロックの順序（継承関係）"
    }
  },
  {
    "qid": {
      "en-US": "6-4"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる",
        "B. コンパイルエラーが発生する",
        "C. コンパイルは成功するが実行時にエラー",
        "D. 「FinalFormat Error」と表示される"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class BlockOrder {\n public static void main(String[] args) {\n  try {\n   Integer num = Integer.parseInt(\"abc\");\n   System.out.print(\"Parsed\");\n  } finally { // ① finally が先\n   System.out.print(\"Final\");\n  } catch (NumberFormatException e) { // ② catch が後\n   System.out.print(\"Format Error\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-catch-finally` 構文では、ブロックの記述順序が決まっています。`try` ブロックの後には、0個以上の `catch` ブロック、その後に0個または1個の `finally` ブロックを記述します。`finally` ブロックを記述する場合、それは必ず `catch` ブロック（もし存在すれば）の *後* になければなりません。このコードでは、`finally` ブロック (①) が `catch` ブロック (②) よりも前に記述されているため、構文エラーとなりコンパイルできません。"
    },
    "questionCategory": {
      "en-US": "try-catch-finally の構文順序"
    }
  },
  {
    "qid": {
      "en-US": "6-5"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Error\"",
        "B. \"Finally Error\"",
        "C. \"Finally \"",
        "D. コンパイルエラー",
        "E. 実行時エラー（NPE以外）"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class ReturnFinally {\n public static void main(String[] args) {\n  System.out.print(processValue(null)); // ③\n }\n private static String processValue(String data) {\n  try {\n   System.out.print(data.length()); // ④ NPE発生\n  } catch (NullPointerException e) { // ⑤ 捕捉\n   return \"Error\"; // ⑥ \"Error\"を返す準備\n  } finally { // ⑦ finally実行\n   System.out.print(\"Finally \"); // ⑧ 表示\n  }\n  return \"Success\"; // ⑨ 到達しない\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-catch-finally` と `return` の相互作用に関する問題です。④で `data` が `null` なので `NullPointerException` が発生します。⑤の `catch` ブロックでこの例外が捕捉されます。⑥で `return \"Error\";` が実行されますが、これはメソッドからの戻り値を \"Error\" に設定するだけで、即座にメソッドが終了するわけではありません。`return` の前に `finally` ブロックがあれば、それが実行されます。⑦の `finally` ブロックが実行され、⑧で「Finally 」が表示されます。`finally` ブロックの実行後、`catch` ブロックで設定された戻り値 \"Error\" が実際に返され、③の `println` によって「Error」が表示されます。したがって、最終的な出力は「Finally Error」となります。"
    },
    "questionCategory": {
      "en-US": "catch ブロック内の return と finally"
    }
  },
  {
    "qid": {
      "en-US": "6-6"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 1",
        "B. 0",
        "C. 10",
        "D. コンパイルエラー",
        "E. 実行時に例外がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class DoubleReturn {\n public static void main(String[] args) {\n  int status = getStatus(); // ①\n  System.out.println(status); // ③\n }\n private static int getStatus() {\n  try {\n   throw new IllegalStateException(); // ② 例外発生\n  } catch (IllegalStateException e) {\n   return 1; // ④ 戻り値 1 を準備\n  } finally {\n   return 0; // ⑤ 戻り値 0 で上書き\n  }\n  // ここには到達しない\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`catch` ブロックと `finally` ブロックの両方に `return` 文が存在する場合の動作です。②で例外が発生し、`catch` ブロックで捕捉されます。④の `return 1;` が実行され、メソッドの戻り値として `1` が準備されます。しかし、メソッドが実際にリターンする前に `finally` ブロックが実行されます。⑤の `finally` ブロック内の `return 0;` が実行されると、この `return` が優先され、メソッドは最終的に `0` を返します。`catch` ブロックで準備された戻り値 `1` は破棄されます。したがって、`main` メソッドの `status` は `0` となり、`0` が表示されます。"
    },
    "questionCategory": {
      "en-US": "catch と finally 両方の return"
    }
  },
  {
    "qid": {
      "en-US": "6-7"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 0",
        "B. -1",
        "C. 99",
        "D. コンパイルエラー",
        "E. 実行時エラー（AIOOBE以外）"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class FinallyModify {\n public static void main(String[] args) {\n  int code = getCode(); // ①\n  System.out.println(code); // ③\n }\n private static int getCode() {\n  int statusCode = 0;\n  try {\n   int[] data = {10, 20};\n   data[2] = 30; // ② AIOOBE 発生\n  } catch (ArrayIndexOutOfBoundsException e) {\n   statusCode = -1; // ④ statusCode を -1 に\n   return statusCode; // ⑤ -1 を返す準備\n  } finally {\n   statusCode = 99; // ⑥ ローカル変数を変更\n  }\n  // return statusCode; // ⑦ 到達不能\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`finally` ブロックでのローカル変数の変更が、`catch` ブロックの `return` 文で返される値に影響するかどうかを問う問題です。②で `ArrayIndexOutOfBoundsException` が発生し、`catch` ブロックで捕捉されます。④でローカル変数 `statusCode` は `-1` になります。⑤の `return statusCode;` で、戻り値として `-1` が準備されます。その後、`finally` ブロックが実行され、⑥でローカル変数 `statusCode` の値が `99` に変更されますが、これは *すでに準備された戻り値 `-1`* には影響を与えません。メソッドは準備されていた `-1` を返します。したがって、`main` メソッドの `code` は `-1` となり、`-1` が表示されます。（注意: 設問6-6のようにfinallyにreturnがあると結果が変わります）"
    },
    "questionCategory": {
      "en-US": "finally での変数変更と catch の return"
    }
  },
  {
    "qid": {
      "en-US": "6-8"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Try Block Finally Block After Try-Finally\"",
        "B. \"Try Block After Try-Finally Finally Block\"",
        "C. \"Try Block Finally Block\"",
        "D. \"Try Block After Try-Finally\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class TryFinallyBasic {\n public static void main(String[] args) {\n  try {\n   System.out.print(\"Try Block \");\n   // 例外は発生しない\n  } finally {\n   System.out.print(\"Finally Block \");\n  }\n  System.out.print(\"After Try-Finally\");\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-finally` 構造では、`catch` ブロックがなくても構いません。`try` ブロックの実行が正常に完了した場合でも、例外が発生した場合でも（捕捉されない場合）、`finally` ブロックは通常必ず実行されます。\n1. `try` ブロックが実行され、「Try Block 」が表示されます。\n2. `try` ブロックが正常に終了します。\n3. `finally` ブロックが実行され、「Finally Block 」が表示されます。\n4. `try-finally` 構造全体の実行が終わり、次の文 `System.out.print(\"After Try-Finally\");` が実行され、「After Try-Finally」が表示されます。\nしたがって、出力は「Try Block Finally Block After Try-Finally」となります。"
    },
    "questionCategory": {
      "en-US": "try-finally の基本動作"
    }
  },
  {
    "qid": {
      "en-US": "6-9"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"O1 I2 I3 O2 O4 \"",
        "B. \"O1 I2 I3 O4 \"",
        "C. \"O1 I3 O3 O4 \"",
        "D. \"O1 I2 O4 \"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class NestedTryCatch {\n public static void main(String[] args) {\n  try { // 外側 try\n   System.out.print(\"O1 \");\n   try { // 内側 try\n    int result = 10 / 0; // ① ArithmeticException\n    System.out.print(\"I1 \");\n   } catch (ArithmeticException e) { // ② 捕捉\n    System.out.print(\"I2 \");\n   } finally { // ③ 内側 finally\n    System.out.print(\"I3 \");\n   }\n   System.out.print(\"O2 \"); // ④ 内側で例外処理されたので実行\n  } catch (Exception e) { // ⑤ 外側 catch\n   System.out.print(\"O3 \");\n  } finally { // ⑥ 外側 finally\n   System.out.print(\"O4 \");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムをコンパイルし、実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "ネストされた `try-catch-finally` ブロックの実行順序を追います。\n1. 外側 `try` に入り、「O1 」が表示されます。\n2. 内側 `try` に入ります。\n3. ①で `ArithmeticException` が発生します。\n4. ②の内側 `catch` で例外が捕捉され、「I2 」が表示されます。\n5. ③の内側 `finally` が実行され、「I3 」が表示されます。\n6. 内側の例外は処理されたため、制御は内側 `try-catch-finally` の後に移り、④の「O2 」が表示されます。\n7. 外側 `try` ブロックが正常に（例外を外に投げずに）終了します。\n8. ⑤の外側 `catch` は実行されません。\n9. ⑥の外側 `finally` が実行され、「O4 」が表示されます。\nしたがって、最終的な出力は「O1 I2 I3 O2 O4 」となります。"
    },
    "questionCategory": {
      "en-US": "ネストされた try-catch-finally"
    }
  },
  {
    "qid": {
      "en-US": "6-10"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "カスタム例外の作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `java.lang.Object`",
        "B. `java.lang.Error`",
        "C. `java.lang.Throwable`",
        "D. `java.lang.RuntimeException` または `java.lang.Exception`"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "プログラマが独自の例外クラス（カスタム例外）を作成する際に、通常、直接または間接的に継承するべき基本クラスとして最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Javaの例外とエラーのクラス階層の頂点は `java.lang.Throwable` です。プログラマが定義するカスタム例外は、通常、アプリケーション固有のエラー状況を表すために作成されます。これらは一般的に回復可能な状況（`Exception` を継承するチェック例外）か、プログラムのバグや予期せぬ実行時状況（`RuntimeException` を継承する非チェック例外）を示します。`Exception` も `RuntimeException` も `Throwable` を（直接または間接的に）継承しています。したがって、カスタム例外は `Exception` または `RuntimeException` を継承するのが一般的であり、結果的に `Throwable` のサブクラスとなります。C は直接の親として適切でない場合がありますが、Dがより具体的で一般的な慣習を示しています。"
    },
    "questionCategory": {
      "en-US": "カスタム例外クラスの継承元"
    }
  },
  {
    "qid": {
      "en-US": "6-11"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `throws CheckedError`",
        "B. `throws UncheckedError`",
        "C. `throws CheckedError, UncheckedError`",
        "D. `throws Exception`",
        "E. 何も記述しない"
      ]
    },
    "answer": {
      "en-US": [
        0,
        2,
        3
      ]
    },
    "code": {
      "en-US": "// UncheckedError.java\nclass UncheckedError extends RuntimeException {}\n// CheckedError.java\nclass CheckedError extends Exception {}\n\npublic class ExceptionDeclarer {\n public void processData(String input) _______________ {\n  if (input == null) {\n   throw new CheckedError(); // チェック例外\n  }\n  if (input.isEmpty()) {\n   throw new UncheckedError(); // 非チェック例外\n  }\n  System.out.println(\"Processed: \" + input);\n }\n}"
    },
    "questionText": {
      "en-US": "このの `processData` メソッドがコンパイルエラーにならないようにするために、空欄 `_______________` に記述する必要がある `throws` 宣言として、適切なものを3つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッド内でチェック例外（`Exception` のサブクラスで `RuntimeException` のサブクラスではないもの、ここでは `CheckedError`）をスローする可能性があり、かつそのメソッド内で `try-catch` を使って処理しない場合、メソッド宣言に `throws` 句を使ってその例外をスローする可能性があることを明示しなければなりません。非チェック例外（`RuntimeException` または `Error` のサブクラス、ここでは `UncheckedError`）は、`throws` 句での宣言は任意であり、必須ではありません。\nこのメソッドは `CheckedError` をスローする可能性があるため、少なくとも `throws CheckedError` (A) を宣言する必要があります。`throws CheckedError, UncheckedError` (C) や `throws Exception` (D、`CheckedError` のスーパークラス) のように、非チェック例外やより上位の例外クラスを含めて宣言することも構文的には可能です。何も記述しない(E)や非チェック例外のみ(B)ではコンパイルエラーになります。したがって、適切な宣言は A, C, D です。"
    },
    "questionCategory": {
      "en-US": "throws 宣言の要否"
    }
  },
  {
    "qid": {
      "en-US": "6-12"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 通常、JVM 内部の深刻な問題やリソース不足など、アプリケーションが回復できないような状況を示す。",
        "B. `Error` およびそのサブクラスは、非チェック例外（unchecked exception）として扱われる。",
        "C. メソッドが `Error` をスローする可能性がある場合でも、`throws` 句での宣言は通常不要である。",
        "D. プログラムは `Error` を `catch` ブロックで捕捉し、回復処理を試みるべきである。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java の `Error` クラスおよびそのサブクラスに関する説明として、 *誤っている* ものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`Error` は、通常、JVM 自体の問題（例: `OutOfMemoryError`, `StackOverflowError`）など、プログラム側での回復が困難または不可能な深刻な状況を示します(A)。`Error` およびそのサブクラスは `RuntimeException` と同様に非チェック例外として扱われ、`throws` 句での宣言は強制されません(B, C)。これらのエラーは通常、アプリケーションが対処できる範囲を超えているため、プログラム内で `catch` して回復を試みることは推奨されません（処理を続行すると予期せぬ問題を引き起こす可能性があるため）。したがって、Dが誤った説明です。"
    },
    "questionCategory": {
      "en-US": "Error クラスとその扱い"
    }
  },
  {
    "qid": {
      "en-US": "6-13"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `NullPointerException` が発生する",
        "B. `ArrayIndexOutOfBoundsException` が発生する",
        "C. \"0\"",
        "D. \"null\""
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class ArgsLength {\n public static void main(String[] commandLineArgs) {\n  System.out.println(commandLineArgs.length);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを、コマンドラインから引数を何も指定せずに `java ArgsLength` コマンドで実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Java アプリケーションを実行する際、`main` メソッドにはコマンドライン引数が `String` の配列として渡されます。コマンドライン引数が何も指定されなかった場合でも、引数配列（ここでは `commandLineArgs`）は `null` にはならず、要素数が 0 の空の `String` 配列 (`new String[0]`) が渡されます。したがって、`commandLineArgs.length` は `0` と評価され、\"0\" がコンソールに出力されます。"
    },
    "questionCategory": {
      "en-US": "mainメソッドの引数配列 (args)"
    }
  },
  {
    "qid": {
      "en-US": "6-14"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `ArrayIndexOutOfBoundsException`",
        "B. `NullPointerException`",
        "C. `IndexOutOfBoundsException`",
        "D. `ListIndexOutOfBoundsException` (このクラス名は一般的ではない)"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListBounds {\n public static void main(String[] args) {\n  List<Integer> scores = new ArrayList<>();\n  // 空のリストのインデックス0にアクセス\n  scores.get(0);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行した場合にスローされる例外の型として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`java.util.List` インターフェース（およびその実装クラス `ArrayList` など）のメソッド（`get`, `set`, `add`, `remove` など）で、リストの有効な範囲外のインデックスを指定した場合、`IndexOutOfBoundsException` がスローされます。このコードでは、空のリスト `scores` に対して `get(0)` を呼び出しており、インデックス 0 は存在しないため、`IndexOutOfBoundsException` が発生します。`ArrayIndexOutOfBoundsException` は配列に対する範囲外アクセスで発生します。"
    },
    "questionCategory": {
      "en-US": "List の範囲外アクセス (IndexOutOfBoundsException)"
    }
  },
  {
    "qid": {
      "en-US": "6-15"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `true`",
        "B. `false`",
        "C. コンパイルエラー",
        "D. 実行時に `ClassCastException`",
        "E. 実行時に `NullPointerException`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// TypeX.java\npublic class TypeX {\n private int id;\n public TypeX(int id) { this.id = id; }\n // equals メソッドはオーバーライドされていない\n}\n// TypeY.java\npublic class TypeY {\n private int id;\n public TypeY(int id) { this.id = id; }\n @Override // equals をオーバーライド\n public boolean equals(Object obj) {\n  if (!(obj instanceof TypeY)) return false;\n  return this.id == ((TypeY)obj).id;\n }\n}\n\n// Comparison.java\npublic class Comparison {\n public static void main(String[] args) {\n  TypeX x = new TypeX(5);\n  TypeY y = new TypeY(5);\n  System.out.println(x.equals(y)); // ① TypeX の equals 呼び出し\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "①の `x.equals(y)` では、呼び出し元のオブジェクト `x` のクラス `TypeX` の `equals` メソッドが使用されます。`TypeX` クラスは `equals` メソッドをオーバーライドしていないため、`Object` クラスから継承したデフォルトの `equals` メソッドが実行されます。`Object` クラスの `equals` は、`==` と同じく参照の比較を行います。`x` と `y` は異なるクラスの異なるインスタンスなので、参照が等しいはずがなく、結果は `false` となります。`TypeY` で `equals` がオーバーライドされていても、`TypeX` から呼び出す際には使用されません。"
    },
    "questionCategory": {
      "en-US": "Object.equals() のデフォルト動作"
    }
  },
  {
    "qid": {
      "en-US": "6-16"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 0 が表示される",
        "B. コンパイルエラーが発生する",
        "C. `NullPointerException` がスローされる",
        "D. `ArrayIndexOutOfBoundsException` がスローされる",
        "E. `IllegalStateException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class NullAccess {\n public static void main(String[] args) {\n  String data = null;\n  int length = data.length(); // null参照に対してメソッド呼び出し\n  System.out.println(length);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行した場合に発生する主な事象として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "参照型の変数が `null` を指している状態で、その変数を通じてインスタンスメソッド（例: `length()`）やインスタンスフィールドにアクセスしようとすると、`NullPointerException` が実行時にスローされます。このコードでは、`data` が `null` のときに `data.length()` を呼び出そうとしているため、`NullPointerException` が発生します。"
    },
    "questionCategory": {
      "en-US": "NullPointerException の発生"
    }
  },
  {
    "qid": {
      "en-US": "6-17"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"100\" が表示される",
        "B. コンパイルエラーが発生する",
        "C. `NullPointerException` がスローされる",
        "D. `ClassCastException` がスローされる",
        "E. `NumberFormatException` がスローされる"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class BadCast {\n public static void main(String[] args) {\n  Object data = Integer.valueOf(100); // ① data は Integer\n  String text = (String) data; // ② Integer を String にキャスト試行\n  System.out.println(text);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行した場合に発生する主な事象として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "キャスト演算子 `(Type)` は、オブジェクト参照を別の型に変換しようと試みますが、そのキャストが実行時に有効である（オブジェクトが実際にキャスト先の型またはそのサブクラスである）必要があります。①で変数 `data` は `Integer` オブジェクトを参照しています。②で `Integer` オブジェクトを `String` 型にキャストしようとしています。`Integer` と `String` の間には継承関係がないため、このキャストは無効です。コンパイル時には `Object` から `String` へのキャストの可能性は否定できないためエラーにはなりませんが、実行時に実際の型がチェックされ、互換性がないため `ClassCastException` がスローされます。"
    },
    "questionCategory": {
      "en-US": "ClassCastException の発生"
    }
  },
  {
    "qid": {
      "en-US": "6-18"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "multi-catch 句の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `catch (IOException, SQLException ex)`",
        "B. `catch (IOException | SQLException ex)`",
        "C. `catch (IOException || SQLException ex)`",
        "D. `catch (IOException & SQLException ex)`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java 7 から導入された multi-catch 機能を使用して、複数の例外タイプを単一の `catch` ブロックで処理する際の正しい構文を、以下の選択肢から1つ選びなさい。"
    },
    "explanation": {
      "en-US": "multi-catch 構文では、単一の `catch` ブロックで処理したい複数の例外タイプを、縦棒（パイプ記号）`|` で区切って列挙します。その後ろに、捕捉した例外オブジェクトを受け取るための変数名を1つ記述します。したがって、`catch (IOException | SQLException ex)` が正しい構文です。"
    },
    "questionCategory": {
      "en-US": "multi-catch 構文"
    }
  },
  {
    "qid": {
      "en-US": "6-19"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "multi-catch 句の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルできる。",
        "B. `FileNotFoundException` を先に書けばコンパイルできる。",
        "C. 継承関係にある例外は `|` で同時に指定できないため、コンパイルエラーになる。",
        "D. `IOException` がチェック例外なので `throws` 宣言が必要になる。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// import java.io.*;\n// try { /* ... */ }\n// catch (IOException | FileNotFoundException e) { /* ... */ }\n// FileNotFoundException は IOException のサブクラス"
    },
    "questionText": {
      "en-US": "このの multi-catch のコード例（コメント部分）に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "multi-catch 構文 (`catch (Type1 | Type2 | ... e)`) で指定する例外タイプ間に、継承関係があってはなりません。もし一方の例外が他方のサブクラスである場合、サブクラスの例外はスーパークラスの型としても捕捉できてしまうため、`|` で両方を指定するのは冗長であり、コンパイルエラーとなります。`FileNotFoundException` は `IOException` のサブクラスなので、`catch (IOException | FileNotFoundException e)` という記述はコンパイルエラーになります。この場合は `catch (IOException e)` と書けば、`FileNotFoundException` も含めて捕捉できます。"
    },
    "questionCategory": {
      "en-US": "multi-catch における継承関係の制約"
    }
  },
  {
    "qid": {
      "en-US": "6-20"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `catch` ブロックの記述を不要にすること。",
        "B. `finally` ブロックの記述を不要にすること。",
        "C. ファイルI/Oやネットワーク接続などのリソースを、使用後に自動的にクローズ（解放）すること。",
        "D. すべての種類の例外を自動的に処理すること。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "`try-with-resources` 文（Java 7 で導入）の主な利点または目的として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文の主な目的は、`java.lang.AutoCloseable` または `java.io.Closeable` を実装するリソース（ファイルストリーム、データベース接続、ネットワークソケットなど）を、`try` ブロックの実行が終了した際に（正常終了でも例外発生でも）自動的に、かつ確実に `close()` メソッドを呼び出して解放することです。これにより、従来 `finally` ブロックで記述していた定型的なリソースクローズ処理を省略でき、コードが簡潔になり、リソースリークのリスクを低減できます。例外処理自体が不要になるわけではありません。"
    },
    "questionCategory": {
      "en-US": "try-with-resources の主な目的"
    }
  },
  {
    "qid": {
      "en-US": "6-21"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `java.io.Serializable` インターフェースを実装している必要がある。",
        "B. `java.lang.AutoCloseable` またはそのサブインターフェース（例: `java.io.Closeable`）を実装している必要がある。",
        "C. `java.util.ResourceBundle` のサブクラスである必要がある。",
        "D. `static final` な定数でなければならない。",
        "E. 特に型に関する制約はない。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "`try-with-resources` 文の `try` の直後の括弧 `()` 内で宣言または参照できるリソースオブジェクトの型に関する条件として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 構文で管理され、自動的に `close()` メソッドが呼び出される対象となるリソースは、`java.lang.AutoCloseable` インターフェース、またはそのサブインターフェースである `java.io.Closeable` を実装しているクラスのインスタンスでなければなりません。これらのインターフェースが `close()` メソッドの規約を定義しています。"
    },
    "questionCategory": {
      "en-US": "try-with-resources で扱える型"
    }
  },
  {
    "qid": {
      "en-US": "6-22"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `try (ResourceA r = new ResourceA()) { /*...*/ }`",
        "B. `ResourceA r; try (r = new ResourceA()) { /*...*/ }`",
        "C. `try (new ResourceA(); new ResourceB()) { /*...*/ }`",
        "D. `ResourceA rA = new ResourceA(); try (rA) { /*...*/ }`",
        "E. `try (ResourceA rA = new ResourceA(); ResourceB rB = new ResourceB()) { /*...*/ }`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "`try-with-resources` 文の記述方法として、構文的に正しいものを2つ選択してください。（`ResourceA`, `ResourceB` などは `AutoCloseable` を実装していると仮定）"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文の構文ルール:\n A: `try` の後の括弧内でリソースを宣言し初期化する基本的な形式。正しい。\n B: 括弧内で既存の変数に代入する形式は許可されていません。\n C: 括弧内で宣言または参照するリソースは変数に割り当てられている必要があります。\n D: Java 9 からは、`try` ブロックの前に宣言され、`final` または実質的に `final` (effectively final) な変数を括弧内に指定できます。古いバージョンではエラー。\n E: セミコロン `;` で区切って複数のリソースを宣言・初期化できます。正しい。\nしたがって、Java 8までの範囲では A と E が正しい構文です。（Java 9以降ならDも正しい）"
    },
    "questionCategory": {
      "en-US": "try-with-resources の構文バリエーション"
    }
  },
  {
    "qid": {
      "en-US": "6-23"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Closing R1\" の後に \"Closing R2\"",
        "B. \"Closing R2\" の後に \"Closing R1\"",
        "C. 順序は保証されない",
        "D. `close()` メソッドは呼び出されない"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// Resource1, Resource2 は AutoCloseable 実装\npublic class CloseOrder {\n public static void main(String[] args) throws Exception {\n  try (Resource1 r1 = new Resource1();\n       Resource2 r2 = new Resource2()) {\n   System.out.println(\"Using resources...\");\n  } // r1, r2 がここで close される\n }\n}\n// Resource1 の close() は \"Closing R1\" を出力\n// Resource2 の close() は \"Closing R2\" を出力 と仮定"
    },
    "questionText": {
      "en-US": "こののプログラムを実行した場合、リソース `r1` と `r2` の `close()` メソッドが呼び出される順序を示すコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文で複数のリソースが宣言された場合、それらのリソースは `try` ブロックの終了時に自動的にクローズされますが、そのクローズ処理はリソースが宣言された順序とは *逆* の順序で行われます。このコードでは `Resource1 r1` が先に、`Resource2 r2` が後に宣言されています。したがって、`close()` メソッドは `r2` が先に、`r1` が後に呼び出されます。出力は「Closing R2」の後に「Closing R1」となります。"
    },
    "questionCategory": {
      "en-US": "try-with-resources のリソース解放順序"
    }
  },
  {
    "qid": {
      "en-US": "6-24"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. catch → finally → close",
        "B. close → catch → finally",
        "C. finally → catch → close",
        "D. catch → close → finally"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// リソース、catch、finally がある場合\ntry (MyResource r = new MyResource()) { // 1. リソース初期化\n System.out.println(\"Try Start\"); // 2. try本文開始\n int x = 1 / 0; // 3. 例外発生！\n System.out.println(\"Try End\");\n} catch (ArithmeticException e) { // 5. catch実行\n System.out.println(\"Catch\");\n} finally { // 6. finally実行\n System.out.println(\"Finally\");\n}\n// MyResource の close() は 4. で実行される"
    },
    "questionText": {
      "en-US": "`try-with-resources` 文を使用し、`try` ブロック内で例外が発生した場合、リソースの `close()` メソッド、`catch` ブロック、`finally` ブロック（すべて存在する場合）は、どのような順序で実行されますか。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文において、`try` ブロックの実行中に例外が発生した場合、制御が `try` ブロックから離れる前に、まず `try` の括弧内で宣言されたリソースの `close()` メソッドが（宣言と逆順で）呼び出されます。その後、発生した例外にマッチする `catch` ブロックがあればそれが実行されます。最後に、`finally` ブロックがあればそれが必ず実行されます。したがって、実行順序は `close` → `catch` → `finally` となります。"
    },
    "questionCategory": {
      "en-US": "try-with-resources での例外発生時の処理順序"
    }
  },
  {
    "qid": {
      "en-US": "6-25"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Processing Error\"",
        "B. \"Closing Error\"",
        "C. \"Processing Error,Closing Error\"",
        "D. \"Closing Error,Processing Error\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// FaultyResource.java\nclass FaultyResource implements AutoCloseable {\n public void process() throws Exception {\n  throw new Exception(\"Processing Error\"); // ③ try で発生\n }\n @Override\n public void close() throws Exception {\n  throw new RuntimeException(\"Closing Error\"); // ④ close で発生\n }\n}\n// ExceptionHandling.java\npublic class ExceptionHandling {\n public static void main(String[] args) {\n  try (FaultyResource fr = new FaultyResource()) {\n   fr.process();\n  } catch (Exception e) { // ⑤ 主要例外をキャッチ\n   System.out.print(e.getMessage()); // ⑥ 主要例外メッセージ\n   for (Throwable suppressed : e.getSuppressed()) { // ⑦\n    System.out.print(\",\" + suppressed.getMessage()); // ⑧\n   }\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラム（FaultyResource.javaとExceptionHandling.java）をコンパイルし、実行した場合のコンソール出力として正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文において、`try` ブロック内とリソースの `close()` メソッドの両方で例外が発生した場合の動作です。③で `fr.process()` が `Exception(\"Processing Error\")` をスローします。`try` ブロックが異常終了するため、リソース `fr` の `close()` メソッドが呼び出されます。④で `close()` メソッドが `RuntimeException(\"Closing Error\")` をスローします。この場合、最初に発生した例外（③の `Processing Error`）が「主要な例外」として `catch` ブロックに渡されます。`close()` で発生した例外（④の `Closing Error`）は「抑制された例外 (suppressed exception)」として主要な例外に追加されます。⑤の `catch` ブロックで主要な例外が捕捉され、⑥でそのメッセージ \"Processing Error\" が表示されます。⑦の `getSuppressed()` で抑制された例外の配列を取得し、ループ内で⑧そのメッセージ \"Closing Error\" がカンマ区切りで表示されます。したがって、出力は「Processing Error,Closing Error」となります。"
    },
    "questionCategory": {
      "en-US": "抑制された例外 (Suppressed Exceptions)"
    }
  },
  {
    "qid": {
      "en-US": "6-26"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `java.io.IOException` は非チェック例外である。",
        "B. `java.lang.NullPointerException` はチェック例外である。",
        "C. `java.lang.RuntimeException` のサブクラスは通常、チェック例外として扱われる。",
        "D. チェック例外は、`try-catch` で処理するか、メソッドの `throws` 句で宣言する必要がある。",
        "E. `Error` クラスのサブクラスはチェック例外である。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java の例外クラスに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "A: IOException はチェック例外です。B: NullPointerException は RuntimeException のサブクラスであり、非チェック例外です。C: RuntimeException のサブクラスは非チェック例外です。D: チェック例外（Exception のサブクラスで RuntimeException のサブクラスでないもの）は、コンパイラによって処理（catch または throws 宣言）が強制されます。これが正しい説明です。E: Error のサブクラスは非チェックです。"
    },
    "questionCategory": {
      "en-US": "チェック例外と非チェック例外の区別"
    }
  },
  {
    "qid": {
      "en-US": "6-27"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Try Catch Finally\"",
        "B. \"Try Finally\"",
        "C. \"Catch Finally\"",
        "D. \"Finally\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class NoException {\n public static void main(String[] args) {\n  try {\n   int result = 10 * 2;\n   System.out.print(\"Try \");\n  } catch (ArithmeticException e) {\n   System.out.print(\"Catch \");\n  } finally {\n   System.out.print(\"Finally\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロック内の処理 `10 * 2` では例外は発生しません。「Try 」が表示されます。例外が発生しなかったため、`catch` ブロックは実行されません。`finally` ブロックは例外の有無に関わらず実行されるため、「Finally」が表示されます。したがって、出力は「Try Finally」となります。"
    },
    "questionCategory": {
      "en-US": "catch ブロックが実行されない場合"
    }
  },
  {
    "qid": {
      "en-US": "6-28"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "カスタム例外の作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Error`",
        "B. `RuntimeException`",
        "C. `Throwable`",
        "D. `Exception`"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "// 空欄に入るべきクラスは？\npublic class ValidationException extends ________ {\n public ValidationException(String message) {\n  super(message);\n }\n}"
    },
    "questionText": {
      "en-US": "アプリケーション固有の検証エラーを表す **チェック例外** として `ValidationException` クラスを定義したいと考えています。空欄 `________` に記述すべきスーパークラスとして、最も一般的なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "チェック例外を作成する場合、通常は `java.lang.Exception` クラスを直接または間接的に継承します。`RuntimeException` を継承すると非チェック例外になります。`Error` は通常プログラムで処理すべきでない深刻な問題を示します。`Throwable` は `Exception` と `Error` の共通スーパークラスですが、カスタム例外の直接の親としては `Exception` または `RuntimeException` を選択するのが一般的です。チェック例外が目的なので `Exception` を継承します。"
    },
    "questionCategory": {
      "en-US": "カスタムチェック例外の定義"
    }
  },
  {
    "qid": {
      "en-US": "6-29"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Closeable`",
        "B. `AutoCloseable`",
        "C. `Serializable`",
        "D. `Runnable`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class Resource implements ________ { // ← 空欄\n @Override\n public void close() throws Exception {\n  System.out.println(\"Resource closed\");\n }\n // ... other methods\n}"
    },
    "questionText": {
      "en-US": "このの `Resource` クラスを `try-with-resources` 文で使用できるようにするために、空欄 `________` に記述すべきインターフェース名を1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文で自動的にリソース管理されるためには、そのリソースのクラスが `java.lang.AutoCloseable` インターフェース（またはそのサブインターフェースである `java.io.Closeable`）を実装している必要があります。これらのインターフェースは `close()` メソッドを定義しており、`try-with-resources` はこのメソッドを自動的に呼び出します。したがって、空欄には `AutoCloseable` を記述するのが適切です（`Closeable` でも可）。"
    },
    "questionCategory": {
      "en-US": "AutoCloseable インターフェース"
    }
  },
  {
    "qid": {
      "en-US": "6-30"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "multi-catch 句の使用"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `catch` ブロック内で変数 `e` に別の例外オブジェクトを再代入できる。",
        "B. 変数 `e` は暗黙的に `final` として扱われ、再代入はできない。",
        "C. 変数 `e` の型は、指定された例外タイプの共通の親クラスになる。",
        "D. 変数 `e` は `catch` ブロックの外側でも参照できる。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import java.io.*;\nimport java.sql.*;\n\npublic class MultiCatchVariable {\n public void process() {\n  try {\n   // IOやSQL関連の処理\n   if (Math.random() > 0.5) throw new IOException();\n   else throw new SQLException();\n  } catch (IOException | SQLException e) {\n   // e = new Exception(); // 再代入できるか？\n   System.out.println(e.getMessage());\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "multi-catch 構文 (`catch (Type1 | Type2 e)`) で宣言された例外変数 `e` に関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "multi-catch で宣言された例外変数（例: `e`）は、その `catch` ブロック内でのみ有効です。重要な特徴として、この変数は暗黙的に `final` として扱われます。これは、`catch` ブロック内で捕捉した例外オブジェクトへの参照を誤って変更してしまうことを防ぐためです。したがって、`catch` ブロック内でこの変数に別の値を再代入しようとするとコンパイルエラーになります(A誤、B正)。変数の型は `|` で区切られた型の共通のスーパークラス（通常は最も近い共通スーパークラス）になりますが、`final` であるという点がより重要な制約です(Cはある程度正しいがBがより適切)。スコープは `catch` ブロック内に限られます(D誤)。"
    },
    "questionCategory": {
      "en-US": "multi-catch での変数修飾子"
    }
  },
  {
    "qid": {
      "en-US": "6-31"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Number: 123\"",
        "B. \"Error Type: Exception\"",
        "C. \"Error Type: IllegalArgumentException\"",
        "D. \"Error Type: NumberFormatException\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class StringToInt {\n public static void main(String[] args) {\n  String numStr = \"123a\";\n  try {\n   int number = Integer.parseInt(numStr);\n   System.out.println(\"Number: \" + number);\n  } catch (Exception e) {\n   System.out.println(\"Error Type: \" +\n                      e.getClass().getSimpleName());\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`Integer.parseInt(String s)` メソッドは、引数として与えられた文字列を `int` 型の数値に変換しようと試みます。しかし、文字列が有効な整数の形式でない場合（この例では \"123a\" に 'a' が含まれているため）、`NumberFormatException` がスローされます。この例外は `RuntimeException` のサブクラスです。`catch (Exception e)` ブロックで捕捉され、`e.getClass().getSimpleName()` によって例外クラスの名前 \"NumberFormatException\" が取得され、出力されます。"
    },
    "questionCategory": {
      "en-US": "NumberFormatException"
    }
  },
  {
    "qid": {
      "en-US": "6-32"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"NPE Finally\"",
        "B. \"AIOOBE Finally\"",
        "C. \"Exception Finally\"",
        "D. \"AIOOBE Exception Finally\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class CatchSelection {\n public static void main(String[] args) {\n  try {\n   int[] nums = {1};\n   System.out.println(nums[1]); // AIOOBE\n  } catch (NullPointerException e) {\n   System.out.print(\"NPE \");\n  } catch (ArrayIndexOutOfBoundsException e) {\n   System.out.print(\"AIOOBE \");\n  } catch (Exception e) {\n   System.out.print(\"Exception \");\n  } finally {\n   System.out.print(\"Finally\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "以下のJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロック内で `nums[1]` にアクセスしようとすると、配列 `nums` の有効なインデックス（0のみ）を超えているため `ArrayIndexOutOfBoundsException` が発生します。複数の `catch` ブロックがある場合、発生した例外の型に *最初に* マッチする `catch` ブロックが実行されます。ここでは `catch (ArrayIndexOutOfBoundsException e)` がマッチするため、そのブロック内の処理が実行され「AIOOBE 」が表示されます。他の `catch` ブロックは実行されません。その後、`finally` ブロックが実行され「Finally」が表示されます。したがって、出力は「AIOOBE Finally」となります。"
    },
    "questionCategory": {
      "en-US": "複数の catch ブロックでの例外捕捉"
    }
  },
  {
    "qid": {
      "en-US": "6-33"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 0",
        "B. \"Runtime Error\"",
        "C. \"General Error\"",
        "D. コンパイルエラー",
        "E. `ArithmeticException` がスローされ終了する"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class DivisionByZero {\n public static void main(String[] args) {\n  try {\n   int result = 10 / 0;\n   System.out.println(result);\n  } catch (RuntimeException e) {\n   System.out.println(\"Runtime Error\");\n  } catch (Exception e) {\n   System.out.println(\"General Error\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "整数演算においてゼロで除算しようとすると、`ArithmeticException` がスローされます。`ArithmeticException` は `RuntimeException` のサブクラスです。このコードでは `10 / 0` で `ArithmeticException` が発生し、最初の `catch (RuntimeException e)` ブロックで捕捉されます（`ArithmeticException` は `RuntimeException` の一種であるため）。そのため、「Runtime Error」が表示され、後続の `catch` ブロックは実行されません。（注意: 浮動小数点数のゼロ除算は例外をスローせず、Infinity または NaN になります。）"
    },
    "questionCategory": {
      "en-US": "ArithmeticException (ゼロ除算)"
    }
  },
  {
    "qid": {
      "en-US": "6-34"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `catch` ブロックと `finally` ブロックの両方が必須である。",
        "B. `catch` ブロックは必須だが `finally` ブロックは任意である。",
        "C. `finally` ブロックは必須だが `catch` ブロックは任意である。",
        "D. `catch` ブロックと `finally` ブロックは両方とも任意である。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "import java.io.*;\n\npublic class TryWithNoCatch {\n public static void main(String[] args) throws IOException {\n  try (BufferedReader br = new BufferedReader(new StringReader(\"abc\"))) {\n   System.out.println(br.readLine());\n  }\n  // catch ブロックも finally ブロックもない\n }\n}"
    },
    "questionText": {
      "en-US": "`try-with-resources` 文を使用する場合の `catch` ブロックと `finally` ブロックに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文は、リソースの自動クローズを保証する機能を提供します。この構文を使用する場合、`catch` ブロックや `finally` ブロックは必須ではありません。必要に応じて、例外を捕捉するための `catch` ブロックや、リソースクローズ以外の後処理を行うための `finally` ブロックを追加することは可能ですが、どちらも省略することができます。したがって、Dが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "try-with-resources と catch/finally の省略"
    }
  },
  {
    "qid": {
      "en-US": "6-35"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "カスタム例外の作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"150円引き出しました\"",
        "B. \"エラー: 残高不足\"",
        "C. \"エラー: null\"",
        "D. コンパイルエラー",
        "E. 実行時に `InsufficientFundsException` がスローされ終了"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "// InsufficientFundsException.java\nclass InsufficientFundsException extends Exception {\n public InsufficientFundsException(String msg) { super(msg); }\n}\n\n// BankAccount.java\nclass BankAccount {\n private int balance = 100;\n public void withdraw(int amount) throws InsufficientFundsException {\n  if (amount > balance) {\n   throw new InsufficientFundsException(\"残高不足\");\n  }\n  balance -= amount;\n  System.out.println(amount + \"円引き出しました\");\n }\n}\n\n// Atm.java\npublic class Atm {\n public static void main(String[] args) {\n  BankAccount account = new BankAccount();\n  try {\n   account.withdraw(150);\n  } catch (InsufficientFundsException e) {\n   System.out.println(\"エラー: \" + e.getMessage());\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`Atm` の `main` で `account.withdraw(150)` が呼び出されます。`BankAccount` の `withdraw` メソッドでは、引き出し額 `amount` (150) が残高 `balance` (100) より大きいため、`if (amount > balance)` の条件が `true` となり、`InsufficientFundsException` がスローされます。この例外はチェック例外であり、`withdraw` メソッドで `throws` 宣言されています。`main` メソッドの `try-catch` ブロックでこの例外が捕捉され、`catch` ブロック内の処理が実行されます。`e.getMessage()` は例外オブジェクト生成時に渡されたメッセージ「残高不足」を返すため、「エラー: 残高不足」が表示されます。"
    },
    "questionCategory": {
      "en-US": "カスタム例外のスローとキャッチ"
    }
  },
  {
    "qid": {
      "en-US": "6-36"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Object`",
        "B. `Exception`",
        "C. `RuntimeException`",
        "D. `Error`",
        "E. `Throwable`"
      ]
    },
    "answer": {
      "en-US": [
        4
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java の例外およびエラーのクラス階層の最上位に位置するクラスは何ですか。"
    },
    "explanation": {
      "en-US": "Java において、すべての例外クラス（`Exception` およびそのサブクラス）とエラークラス（`Error` およびそのサブクラス）が共通して継承する最上位のスーパークラスは `java.lang.Throwable` です。プログラムで `catch` できるのは、`Throwable` またはそのサブクラスのオブジェクトです。"
    },
    "questionCategory": {
      "en-US": "Throwable クラス"
    }
  },
  {
    "qid": {
      "en-US": "6-37"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Try 1\"",
        "B. \"Finally 1\"",
        "C. \"Try Finally 1\"",
        "D. \"Finally Try 1\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class FinallyGuarantee {\n public static void main(String[] args) {\n  System.out.println(getValue());\n }\n\n static int getValue() {\n  try {\n   System.out.print(\"Try \");\n   return 1; // 戻り値 1 を準備\n  } finally {\n   System.out.print(\"Finally \"); // return の前に実行\n  }\n  // ここには到達しない\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロック内に `return` 文がある場合でも、`finally` ブロックが存在すれば、メソッドが実際にリターンする前に `finally` ブロックが実行されます。\n1. `getValue()` メソッドが呼び出されます。\n2. `try` ブロックに入り、「Try 」が表示されます。\n3. `return 1;` が実行され、戻り値として `1` が準備されます。\n4. `finally` ブロックが実行され、「Finally 」が表示されます。\n5. `finally` ブロック終了後、準備されていた戻り値 `1` が `main` メソッドに返されます。\n6. `main` メソッドで `1` が表示されます。\nしたがって、最終的な出力は「Try Finally 1」となります。"
    },
    "questionCategory": {
      "en-US": "finally ブロックの実行保証（returnがある場合）"
    }
  },
  {
    "qid": {
      "en-US": "6-38"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. `SubClassA`",
        "B. `SubClassB`",
        "C. `SubClassC`",
        "D. `SubClassD`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import java.io.*;\n\nclass SuperClass {\n void process() throws IOException {}\n}\n\nclass SubClassA extends SuperClass {\n @Override\n void process() throws FileNotFoundException {}\n}\n\nclass SubClassB extends SuperClass {\n @Override\n void process() throws Exception {}\n}\n\nclass SubClassC extends SuperClass {\n @Override\n void process() {}\n}\n\nclass SubClassD extends SuperClass {\n @Override\n void process() throws RuntimeException {}\n}"
    },
    "questionText": {
      "en-US": "こののクラス定義について、スーパークラスの `process` メソッドを正しくオーバーライドできていない（コンパイルエラーとなる）サブクラスを1つ選択してください。"
    },
    "explanation": {
      "en-US": "メソッドをオーバーライドする際、サブクラスのメソッドがスロー宣言（`throws` 句）できる例外は、スーパークラスのメソッドがスロー宣言している例外、またはそのサブクラスの例外、あるいは非チェック例外（`RuntimeException`, `Error` およびそのサブクラス）に限られます。スーパークラスのメソッドが宣言していない新しいチェック例外をスロー宣言することはできません。\n- SubClassA: `FileNotFoundException` は `IOException` のサブクラスなので OK。\n- SubClassB: `Exception` は `IOException` のスーパークラスであり、より広範な新しいチェック例外を宣言しているため NG（コンパイルエラー）。\n- SubClassC: 例外をスロー宣言しないのは OK。\n- SubClassD: `RuntimeException` は非チェック例外なので、スーパークラスの宣言に関わらずスロー宣言可能。OK。\nしたがって、コンパイルエラーとなるのは `SubClassB` です。"
    },
    "questionCategory": {
      "en-US": "オーバーライドと throws 句のルール"
    }
  },
  {
    "qid": {
      "en-US": "6-39"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイル・実行され、'D' が表示される。",
        "B. ③の行でコンパイルエラーが発生する。",
        "C. コンパイルは成功するが、実行時に `NullPointerException` が発生する。",
        "D. コンパイルは成功するが、実行時に `IOException` が発生する。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import java.io.*;\n\npublic class TryWithExistingVar {\n public static void main(String[] args) {\n  StringReader reader = new StringReader(\"Data\"); // ①\n  // reader = null; // ② 再代入すると final でなくなる\n  try (reader) { // ③ Java 9以降の構文\n   System.out.println((char)reader.read());\n  } catch (IOException e) {\n   e.printStackTrace();\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラム（Java 9以降の環境を想定）について、②の行のコメントを外した場合に発生する事象として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "Java 9 から、`try-with-resources` 文の括弧内に、`try` ブロックの直前で宣言され、かつ `final` または実質的に `final` (effectively final) な変数を指定できるようになりました。実質的に `final` とは、宣言後に再代入されていない変数を指します。①で `reader` は初期化されます。もし②の行 `reader = null;` のコメントを外すと、`reader` は再代入されるため実質的に `final` ではなくなります。その結果、③の `try (reader)` という記述は無効となり、コンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "try-with-resources (Java 9以降の変数)"
    }
  },
  {
    "qid": {
      "en-US": "6-40"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `OutOfMemoryError`",
        "B. `StackOverflowError`",
        "C. `NoClassDefFoundError`",
        "D. `AssertionError`",
        "E. `InternalError`"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class RecursiveCall {\n public static void main(String[] args) {\n  try {\n   callMyself(1);\n  } catch (Error e) {\n   System.out.println(\"Error caught: \" + e.getClass().getSimpleName());\n  }\n }\n\n static void callMyself(int n) {\n  callMyself(n + 1); // 無限に再帰呼び出し\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合に発生する可能性が最も高い `Error` の種類として、適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`callMyself` メソッドは、終了条件なしに自身を再帰的に呼び出し続けています。メソッドが呼び出されるたびに、その呼び出しのための情報（ローカル変数、パラメータ、戻り先アドレスなど）がコールスタックに積まれます。無限に再帰呼び出しが行われると、コールスタックの領域が使い果たされてしまい、それ以上メソッド呼び出しをスタックに積めなくなります。この状況でスローされるのが `StackOverflowError` です。これは `Error` のサブクラスであり、通常はプログラム側での回復が困難な状況を示します。"
    },
    "questionCategory": {
      "en-US": "StackOverflowError"
    }
  },
  {
    "qid": {
      "en-US": "6-41"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `getMessage()`",
        "B. `printStackTrace()`",
        "C. `toString()`",
        "D. `getCause()`"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class ExceptionMethods {\n public static void main(String[] args) {\n  try {\n   int result = 1 / 0;\n  } catch (ArithmeticException e) {\n   // 例外情報を表示するメソッドは？\n   // System.out.println(e.getMessage());\n   // e.printStackTrace();\n   // System.out.println(e.toString());\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "例外オブジェクト（`Throwable` またはそのサブクラス）が持つメソッドのうち、例外に関する詳細なメッセージ文字列を返すメソッドは何ですか。"
    },
    "explanation": {
      "en-US": "例外オブジェクトは、発生したエラーに関する情報を提供するためのメソッドを持っています。\n- `getMessage()`: 例外に関する詳細なメッセージ文字列（例外生成時に設定されたもの）を返します。\n- `printStackTrace()`: 例外のスタックトレース（メソッド呼び出し履歴）を標準エラーストリームに出力します。\n- `toString()`: 例外クラス名と `getMessage()` の結果を組み合わせた短い説明文字列を返します。\n- `getCause()`: この例外を引き起こした元の例外（原因となった例外）を返します（存在しない場合は `null`）。\n質問は詳細メッセージを返すメソッドを問うているので `getMessage()` が正解です。"
    },
    "questionCategory": {
      "en-US": "例外オブジェクトのメソッド"
    }
  },
  {
    "qid": {
      "en-US": "6-42"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "カスタム例外の作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Exception`",
        "B. `Throwable`",
        "C. `RuntimeException`",
        "D. `Error`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "// 不正な引数を示す非チェック例外\nclass InvalidArgumentError extends ________ {\n InvalidArgumentError(String msg) { super(msg); }\n}"
    },
    "questionText": {
      "en-US": "こののコードで、メソッドの事前条件違反（例: 不正な引数）を示す **非チェック例外** として `InvalidArgumentError` を定義したい場合、空欄 `________` に記述すべきスーパークラスとして最も一般的なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "非チェック例外（コンパイル時の処理が強制されない例外）を作成する場合、通常は `java.lang.RuntimeException` クラスを直接または間接的に継承します。`IllegalArgumentException` など、標準ライブラリの多くの実行時エラーも `RuntimeException` のサブクラスです。`Exception` を継承するとチェック例外になります。`Error` は通常プログラム側で処理すべきでない問題に使われます。`Throwable` はすべての基底ですが、直接継承することは稀です。"
    },
    "questionCategory": {
      "en-US": "カスタム非チェック例外の定義"
    }
  },
  {
    "qid": {
      "en-US": "6-43"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Try \"",
        "B. \"Try Finally\"",
        "C. \"Try After Exit Finally\"",
        "D. \"Finally\"",
        "E. 何も表示されない"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "public class FinallyExit {\n public static void main(String[] args) {\n  try {\n   System.out.print(\"Try \");\n   System.exit(0); // JVMを終了させる\n   System.out.print(\"After Exit \"); // 到達不能\n  } finally {\n   System.out.print(\"Finally\"); // 実行されるか？\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`finally` ブロックは通常、`try` ブロックの実行がどのように終了しても（正常終了、例外発生、`return`）実行が保証されます。しかし、例外的な状況、特に `System.exit()` が呼び出されて JVM 自体が終了処理を開始した場合には、`finally` ブロックが実行される保証はありません。このコードでは `try` ブロック内で `System.exit(0)` が呼び出されるため、JVM はそこで終了処理に入り、後続の `System.out.print` や `finally` ブロックは実行されない可能性が高いです。実行環境によっては `finally` が実行されることも稀にありますが、保証されないため、最も可能性の高い結果は「Try 」のみが出力されることです。"
    },
    "questionCategory": {
      "en-US": "finally ブロックの実行保証（System.exit）"
    }
  },
  {
    "qid": {
      "en-US": "6-44"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"RunFail\"",
        "B. \"CloseFail\"",
        "C. \"RunFail:CloseFail\"",
        "D. \"CloseFail:RunFail\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "class ResourceX implements AutoCloseable {\n public void run() throws IOException { throw new IOException(\"RunFail\"); }\n public void close() throws SQLException { throw new SQLException(\"CloseFail\"); }\n}\n\npublic class SuppressedDemo {\n public static void main(String[] args) {\n  try (ResourceX rx = new ResourceX()) {\n   rx.run();\n  } catch (Exception e) {\n   System.out.print(e.getMessage()); // 主要例外\n   for (Throwable t : e.getSuppressed()) {\n    System.out.print(\":\" + t.getMessage()); // 抑制例外\n   }\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロック内の `rx.run()` で `IOException(\"RunFail\")` がスローされます。`try` ブロックが異常終了するため、リソース `rx` の `close()` メソッドが呼び出されます。その `close()` メソッド内で `SQLException(\"CloseFail\")` がスローされます。この場合、最初に `try` ブロックで発生した `IOException` が主要な例外となり、`close()` で発生した `SQLException` は抑制された例外として扱われます。`catch (Exception e)` で主要な例外 (`IOException`) が捕捉され、`e.getMessage()` で \"RunFail\" が表示されます。その後、`e.getSuppressed()` で抑制された例外 (`SQLException`) を取得し、そのメッセージ \"CloseFail\" がコロン区切りで表示されます。したがって、出力は「RunFail:CloseFail」となります。"
    },
    "questionCategory": {
      "en-US": "try-with-resources 内での例外と close() での例外"
    }
  },
  {
    "qid": {
      "en-US": "6-45"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `IllegalArgumentException`",
        "B. `IllegalStateException`",
        "C. `AssertionError`",
        "D. `RuntimeException`",
        "E. `Exception`"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class AssertDemo {\n public static void main(String[] args) {\n  int value = -5;\n  // アサーションを有効にして実行すると仮定\n  assert value >= 0 : \"Value must be non-negative\";\n  System.out.println(\"Value is \" + value);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをアサーションを有効 (`java -ea AssertDemo`) にして実行した場合に発生する可能性のある `Throwable` のサブクラスとして、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`assert` 文は、プログラムの前提条件（表明）を検証するために使用されます。`assert 条件式 : エラーメッセージ;` の形式で記述され、アサーションが有効な状態で実行されたときに `条件式` が `false` と評価されると、`java.lang.AssertionError`（`Error` のサブクラス）がスローされます。このコードでは `value` が -5 であり、条件 `value >= 0` は `false` なので、アサーションが有効であれば `AssertionError` が発生します。"
    },
    "questionCategory": {
      "en-US": "AssertionError"
    }
  },
  {
    "qid": {
      "en-US": "6-46"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Process OK\"",
        "B. \"Process Cleanup OK\"",
        "C. \"Cleanup Process OK\"",
        "D. \"Process Cleanup\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class FinallyNormal {\n public static void main(String[] args) {\n  String result = process();\n  System.out.println(result);\n }\n\n static String process() {\n  try {\n   System.out.print(\"Process \");\n   return \"OK\";\n  } finally {\n   System.out.print(\"Cleanup \");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロックが正常に実行され `return` 文に到達した場合でも、`finally` ブロックがあれば `return` の前に実行されます。\n1. `process()` メソッドが呼び出されます。\n2. `try` ブロックに入り、「Process 」が表示されます。\n3. `return \"OK\";` が実行され、戻り値 \"OK\" が準備されます。\n4. `finally` ブロックが実行され、「Cleanup 」が表示されます。\n5. `finally` ブロック終了後、準備された \"OK\" が `main` メソッドに返されます。\n6. `main` メソッドで \"OK\" が表示されます。\nしたがって、出力は「Process Cleanup OK」となります。"
    },
    "questionCategory": {
      "en-US": "例外が発生しない場合の finally"
    }
  },
  {
    "qid": {
      "en-US": "6-47"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `catch` ブロックで宣言された例外変数 `ex` は、`try-catch` 構文の外側でも参照できる。",
        "B. `catch` ブロックで宣言された例外変数 `ex` のスコープは、その `catch` ブロック内に限定される。",
        "C. `try` ブロック内で例外が発生しなければ、`message` の値は \"Default\" のまま変わらない。",
        "D. コンパイルエラーが発生する。",
        "E. 実行時に \"Default\" が表示される。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class CatchScope {\n public static void main(String[] args) {\n  String message = \"Default\";\n  try {\n   // 何らかの処理\n   throw new RuntimeException(\"Error occurred\");\n  } catch (RuntimeException ex) {\n   message = ex.getMessage(); // catchブロック内で代入\n  }\n  // System.out.println(ex); // コンパイルエラー\n  System.out.println(message);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`catch` ブロックの括弧内で宣言された例外変数（例: `ex`）のスコープは、その `catch` ブロック `{}` 内に限定されます。ブロックの外側から `ex` を参照しようとするとコンパイルエラーになります(A誤、コメントアウト部分が該当)。このコードでは例外が発生し、`catch` ブロック内で `message` に例外メッセージ \"Error occurred\" が代入されるため、最終的にそのメッセージが表示されます(C, E誤)。コンパイルエラーにはなりません(D誤)。したがって、Bが正しい説明です。"
    },
    "questionCategory": {
      "en-US": "catch ブロック内の変数スコープ"
    }
  },
  {
    "qid": {
      "en-US": "6-48"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"P C E F\"",
        "B. \"P C F\"",
        "C. \"P E F\"",
        "D. \"P F\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        0
      ]
    },
    "code": {
      "en-US": "import java.io.IOException;\n\nclass MyResource implements AutoCloseable {\n public void process() { System.out.print(\"P\"); }\n @Override\n public void close() throws IOException { // closeが例外をスロー可能\n  System.out.print(\"C\");\n  throw new IOException(\"Close Error\");\n }\n}\n\npublic class CloseException {\n public static void main(String[] args) {\n  try (MyResource r = new MyResource()) {\n   r.process();\n  } catch (IOException e) { // closeのIOExceptionを捕捉\n   System.out.print(\"E\");\n  } finally {\n   System.out.print(\"F\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` では、リソースの `close()` メソッドが例外をスローする可能性があります。`AutoCloseable` の `close()` は `throws Exception`、`Closeable` の `close()` は `throws IOException` を宣言しています。\n1. `try` ブロックに入り、`r.process()` が実行され「P」が表示されます。\n2. `try` ブロックが終了し、リソース `r` の `close()` メソッドが自動的に呼び出されます。\n3. `close()` メソッド内で「C」が表示され、その後 `IOException` がスローされます。\n4. スローされた `IOException` は `catch (IOException e)` ブロックで捕捉され、「E」が表示されます。\n5. 最後に `finally` ブロックが実行され、「F」が表示されます。\nしたがって、出力は「P C E F」となります。"
    },
    "questionCategory": {
      "en-US": "AutoCloseable の close() メソッドの例外"
    }
  },
  {
    "qid": {
      "en-US": "6-49"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"Caught in main: File not found: nonexistent.txt\"",
        "B. \"Caught in processFile\"",
        "C. \"Caught in processFile\" と \"Caught in main: File not found: nonexistent.txt\"",
        "D. コンパイルエラー",
        "E. 何も表示されない"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "import java.io.IOException;\n\npublic class RethrowException {\n public static void main(String[] args) {\n  try {\n   processFile(\"nonexistent.txt\");\n  } catch (IOException e) {\n   System.out.println(\"Caught in main: \" + e.getMessage());\n  }\n }\n\n static void processFile(String fileName) throws IOException {\n  try {\n   readFile(fileName);\n  } catch (IOException e) {\n   System.out.println(\"Caught in processFile\");\n   throw e; // 捕捉した例外を再スロー\n  }\n }\n\n static void readFile(String name) throws IOException {\n  // ファイル読み込み処理（ここでは IOException をスローすると仮定）\n  throw new IOException(\"File not found: \" + name);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`readFile` メソッドが `IOException` をスローします。`processFile` メソッドの `catch` ブロックでこの例外が捕捉され、「Caught in processFile」が表示されます。その後、`throw e;` によって捕捉した同じ `IOException` オブジェクトが再スローされます。`processFile` メソッドは `throws IOException` を宣言しているため、この再スローは有効です。再スローされた例外は `main` メソッドの `catch` ブロックで捕捉され、「Caught in main: File not found: nonexistent.txt」が表示されます。したがって、両方のメッセージが順に出力されます。"
    },
    "questionCategory": {
      "en-US": "例外の再スロー"
    }
  },
  {
    "qid": {
      "en-US": "6-50"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. コンパイルエラー（tryブロックが空のため）",
        "B. 実行時エラー",
        "C. 何も表示されない",
        "D. \"Finally executed\""
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class EmptyTry {\n public static void main(String[] args) {\n  try {\n   // 何もしない\n  } finally {\n   System.out.println(\"Finally executed\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルし、実行した場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロックの中身が空であっても、構文的には有効です。プログラムは `try` ブロックを実行しようとしますが、中身がないため何も起こりません。その後、`finally` ブロックが存在するため、それが実行され、「Finally executed」が表示されます。コンパイルエラーや実行時エラーは発生しません。"
    },
    "questionCategory": {
      "en-US": "空の try ブロック"
    }
  },
  {
    "qid": {
      "en-US": "6-51"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイルされる。",
        "B. `main` メソッド内で `readFileContent` を呼び出す行でコンパイルエラーが発生する。",
        "C. `readFileContent` メソッドの `throws` 宣言でコンパイルエラーが発生する。",
        "D. `FileInputStream` の行でコンパイルエラーが発生する。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import java.io.*;\n\npublic class CheckedExceptionHandling {\n public static void main(String[] args) {\n  readFileContent(\"dummy.txt\"); // 例外処理が必要\n }\n\n static void readFileContent(String path) throws FileNotFoundException {\n  // 実際にはファイルが存在しないと FileNotFoundException が発生しうる\n  FileInputStream fis = new FileInputStream(path);\n  // ... 読み込み処理 ...\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムをコンパイルしようとした場合の結果として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`FileInputStream` のコンストラクタは、指定されたファイルが存在しない場合に `FileNotFoundException`（`IOException` のサブクラス）をスローする可能性があります。`FileNotFoundException` はチェック例外です。`readFileContent` メソッドはこの例外を `throws` 句で宣言していますが、呼び出し元である `main` メソッドでは、このチェック例外に対する処理（`try-catch` または `main` メソッド自身の `throws` 宣言）が行われていません。チェック例外の処理が強制されるため、`main` メソッド内の `readFileContent` 呼び出し箇所でコンパイルエラーが発生します。"
    },
    "questionCategory": {
      "en-US": "FileNotFoundException (チェック例外)"
    }
  },
  {
    "qid": {
      "en-US": "6-52"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "multi-catch 句の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `IOException` 型として扱われる。",
        "B. `SQLException` 型として扱われる。",
        "C. `Object` 型として扱われる。",
        "D. `IOException` と `SQLException` の最も近い共通のスーパークラス（この場合は `Exception`）の型として扱われる。"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "import java.io.*;\nimport java.sql.*;\n\npublic class MultiCatchType {\n public void process() {\n  try {\n   // IO や SQL の処理\n   if (Math.random() > 0.5) throw new IOException();\n   else throw new SQLException();\n  } catch (IOException | SQLException e) {\n   // 変数 e の型は？\n   // e = new Exception(); // 再代入不可\n   handleException(e);\n  }\n }\n void handleException(Exception ex) { /*...*/ }\n}"
    },
    "questionText": {
      "en-US": "このの `process` メソッド内の multi-catch ブロックで宣言された変数 `e` の型について、最も適切な説明を1つ選択してください。"
    },
    "explanation": {
      "en-US": "multi-catch 構文 `catch (Type1 | Type2 | ... e)` で宣言された例外変数 `e` の型は、`|` で区切られたすべての例外タイプの最も近い共通のスーパークラスの型として扱われます。この例では `IOException` と `SQLException` の共通のスーパークラスは `Exception` です（どちらも `Exception` を直接継承しています）。したがって、`catch` ブロック内では変数 `e` は `Exception` 型として扱われます。また、`e` は暗黙的に `final` です。"
    },
    "questionCategory": {
      "en-US": "multi-catch で捕捉される例外の型"
    }
  },
  {
    "qid": {
      "en-US": "6-53"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"TCE\"",
        "B. \"TFE\"",
        "C. \"CFE\"",
        "D. \"FE\"",
        "E. \"TE\""
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class NoErrorFlow {\n public static void main(String[] args) {\n  String result = \"\";\n  try {\n   result += \"T\";\n  } catch (Exception e) {\n   result += \"C\";\n  } finally {\n   result += \"F\";\n  }\n  result += \"E\";\n  System.out.println(result);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try` ブロック内の処理では例外は発生しません。\n1. `try` ブロックが実行され、`result` に \"T\" が追加されます (`result` = \"T\")。\n2. 例外が発生しなかったので `catch` ブロックはスキップされます。\n3. `finally` ブロックが実行され、`result` に \"F\" が追加されます (`result` = \"TF\")。\n4. `try-catch-finally` 構文が終了し、次の文が実行され、`result` に \"E\" が追加されます (`result` = \"TFE\")。\n5. 最終的な `result` の値 \"TFE\" が表示されます。"
    },
    "questionCategory": {
      "en-US": "例外が発生しなかった場合の catch/finally"
    }
  },
  {
    "qid": {
      "en-US": "6-54"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "中級"
    },
    "choices": {
      "en-US": [
        "A. \"1245\"",
        "B. \"1345\"",
        "C. \"1435\"",
        "D. \"145\"",
        "E. \"134\""
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "public class CatchAndRethrow {\n public static void main(String[] args) {\n  String status = \"\";\n  try {\n   status += \"1\";\n   process();\n   status += \"2\"; // 実行されない\n  } catch (IllegalArgumentException e) {\n   status += \"3\";\n  } finally {\n   status += \"4\";\n  }\n  status += \"5\";\n  System.out.println(status);\n }\n\n static void process() {\n  try {\n   throw new NullPointerException();\n  } catch (NullPointerException e) {\n   throw new IllegalArgumentException(); // 再スロー\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "実行フローを追います。\n1. `main` の `try` に入り `status` は \"1\"。\n2. `process()` 呼び出し。\n3. `process` の `try` で `NullPointerException` スロー。\n4. `process` の `catch` で捕捉。\n5. `process` の `catch` で `IllegalArgumentException` を再スロー。\n6. `process` メソッドが `IllegalArgumentException` をスローして終了。\n7. `main` の `catch (IllegalArgumentException e)` で捕捉され、`status` は \"13\"。\n8. `main` の `finally` が実行され、`status` は \"134\"。\n9. `try-catch-finally` が終了し、次の文で `status` は \"1345\"。\n10. \"1345\" が表示される。"
    },
    "questionCategory": {
      "en-US": "catch ブロックでの例外再スロー"
    }
  },
  {
    "qid": {
      "en-US": "6-55"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "カスタム例外の作成"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `extends RuntimeException` に変更する。",
        "B. `public ConfigError(String msg) { super(msg); }` コンストラクタを追加する。",
        "C. 引数なしのコンストラクタ `public ConfigError() {}` を追加する。",
        "D. `getMessage()` メソッドをオーバーライドする。",
        "E. 修正は不要である。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "class ConfigError extends Exception {\n // コンストラクタが定義されていない\n}\n\npublic class CustomExceptionUsage {\n public void loadConfig() throws ConfigError {\n  boolean error = true; // 仮のエラー条件\n  if (error) {\n   throw new ConfigError(); // 引数なしコンストラクタが必要\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "このの `ConfigError` カスタム例外クラスを使用する `loadConfig` メソッドがあります。このコードをコンパイル可能にするために `ConfigError` クラスに必要な修正として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`loadConfig` メソッド内で `throw new ConfigError();` のように引数なしで例外オブジェクトを生成しようとしています。`ConfigError` クラスにコンストラクタが一つも定義されていない場合、コンパイラは引数なしのデフォルトコンストラクタを自動生成します。しかし、もし親クラス（ここでは `Exception`）が引数なしのコンストラクタを持たない場合や、何らかの理由でプログラマが明示的にコンストラクタを定義する必要がある場合（ここでは特に後者の理由は見当たらないが、選択肢から判断する）、引数なしのコンストラクタの呼び出しに対応できるコンストラクタが必要です。選択肢Cのように引数なしコンストラクタを明示的に追加すれば、`new ConfigError()` の呼び出しが可能になります。"
    },
    "questionCategory": {
      "en-US": "カスタム例外のコンストラクタ"
    }
  },
  {
    "qid": {
      "en-US": "6-56"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "例外処理の仕組みとチェック例外、非チェック例外、エラーの違い"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. `Exception`",
        "B. `RuntimeException`",
        "C. `Error`",
        "D. `IOException`",
        "E. `NullPointerException`"
      ]
    },
    "answer": {
      "en-US": [
        0,
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "以下の Java のクラスについて、`java.lang.Throwable` の直接のサブクラス（子クラス）であるものを2つ選択してください。"
    },
    "explanation": {
      "en-US": "Java の例外とエラーのクラス階層では、すべての例外とエラーの基底クラスが `Throwable` です。`Throwable` の直接のサブクラスは `Exception` と `Error` の2つです。`RuntimeException` は `Exception` のサブクラスです。`IOException` は `Exception` のサブクラスです。`NullPointerException` は `RuntimeException` のサブクラスです。したがって、`Throwable` の直接の子は `Exception` と `Error` です。"
    },
    "questionCategory": {
      "en-US": "例外クラスの階層"
    }
  },
  {
    "qid": {
      "en-US": "6-57"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"Valid\"",
        "B. \"Invalid\"",
        "C. \"Caught: Valid\"",
        "D. \"Caught: Invalid\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        3
      ]
    },
    "code": {
      "en-US": "public class CatchReturn {\n public static void main(String[] args) {\n  String result = checkInput(\"\");\n  System.out.println(result);\n }\n\n static String checkInput(String input) {\n  try {\n   if (input.isEmpty()) {\n    throw new IllegalArgumentException(\"Input empty\");\n   }\n   return \"Valid\";\n  } catch (IllegalArgumentException e) {\n   System.out.print(\"Caught: \");\n   return \"Invalid\"; // catch ブロックから return\n  }\n  // System.out.println(\"End of method\"); // 到達不能\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムを実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`checkInput(\"\")` が呼び出され、`input.isEmpty()` が `true` なので `IllegalArgumentException` がスローされます。`catch` ブロックで捕捉され、「Caught: 」が表示されます。その後、`catch` ブロック内の `return \"Invalid\";` が実行され、メソッドは \"Invalid\" という値を返します。メソッドの末尾（コメントアウト部分）には到達しません。`main` メソッドでは返された \"Invalid\" が `println` によって表示されます。したがって、最終的な出力は「Caught: Invalid」となります。"
    },
    "questionCategory": {
      "en-US": "catch ブロックでの早期リターン"
    }
  },
  {
    "qid": {
      "en-US": "6-58"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-with-resources 文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. 正常にコンパイル・実行され、「First Line」が表示される。",
        "B. `try` ブロックの外側で `sr` を参照しようとするとコンパイルエラーになる。",
        "C. `try` ブロックの外側で `line` を参照しようとするとコンパイルエラーになる。",
        "D. コンパイルは成功するが、実行時に `IOException` が発生する。",
        "E. コンパイルは成功するが、実行時に `NullPointerException` が発生する。"
      ]
    },
    "answer": {
      "en-US": [
        1
      ]
    },
    "code": {
      "en-US": "import java.io.*;\n\npublic class ResourceScope {\n public static void main(String[] args) {\n  String line = null;\n  try (StringReader sr = new StringReader(\"First Line\")) {\n   line = sr.readLine();\n  }\n  // try ブロックの外側\n  // System.out.println(sr); // コンパイルエラー\n  System.out.println(line);\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムに関する説明として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`try-with-resources` 文の括弧 `()` 内で宣言されたリソース変数（例: `sr`）のスコープは、その `try` ブロック（および関連する `catch`, `finally` ブロック）内に限定されます。`try` ブロックの外側からリソース変数 `sr` を参照しようとすると、スコープ外となるためコンパイルエラーが発生します（コメントアウト部分が該当）。一方、変数 `line` は `try` ブロックの外側で宣言されているため、`try` ブロック内で値が代入された後、外側の `System.out.println(line)` でその値を参照することは可能です。このコードは正常にコンパイル・実行され、「First Line」が表示されます。したがって、Bがスコープに関する正しい説明です。（Aも結果としては正しいが、Bはスコープのルールを説明しているためより適切）"
    },
    "questionCategory": {
      "en-US": "try-with-resources リソース変数のスコープ"
    }
  },
  {
    "qid": {
      "en-US": "6-59"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "multi-catch 句の使用"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. \"OK\"",
        "B. \"Error: ArithmeticException\"",
        "C. \"Error: NullPointerException\"",
        "D. \"Other Error\"",
        "E. コンパイルエラー"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": "public class CommonHandling {\n public static void main(String[] args) {\n  try {\n   int choice = Integer.parseInt(args[0]);\n   if (choice == 0) throw new ArithmeticException();\n   else if (choice == 1) throw new NullPointerException();\n   else System.out.println(\"OK\");\n  } catch (ArithmeticException | NullPointerException e) {\n   // 複数の異なる非チェック例外をまとめて処理\n   System.out.println(\"Error: \" + e.getClass().getSimpleName());\n  } catch (Exception e) {\n   System.out.println(\"Other Error\");\n  }\n }\n}"
    },
    "questionText": {
      "en-US": "こののJavaプログラムで `java CommonHandling 1` を実行した場合のコンソール出力として、正しいものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "`args[0]` は \"1\" なので `choice` は 1 になります。`else if (choice == 1)` が `true` となり、`NullPointerException` がスローされます。`catch (ArithmeticException | NullPointerException e)` ブロックがこの例外を捕捉します（`ArithmeticException` と `NullPointerException` は継承関係にないため `|` で結合可能）。ブロック内の処理が実行され、`e.getClass().getSimpleName()` は \"NullPointerException\" を返すため、「Error: NullPointerException」が表示されます。"
    },
    "questionCategory": {
      "en-US": "multi-catch と共通の処理"
    }
  },
  {
    "qid": {
      "en-US": "6-60"
    },
    "chapter": {
      "en-US": "6章"
    },
    "category": {
      "en-US": "try-catch文による例外処理"
    },
    "difficulty": {
      "en-US": "初級"
    },
    "choices": {
      "en-US": [
        "A. プログラムの実行速度を向上させること。",
        "B. プログラムのコンパイルエラーをなくすこと。",
        "C. プログラム実行中に発生する可能性のあるエラー（例外）に対処し、プログラムの異常終了を防いだり、適切な回復処理を行ったりすること。",
        "D. すべてのメソッドに `throws Exception` を強制すること。",
        "E. デバッグ情報を常に出力すること。"
      ]
    },
    "answer": {
      "en-US": [
        2
      ]
    },
    "code": {
      "en-US": ""
    },
    "questionText": {
      "en-US": "Java における例外処理（`try-catch` など）の主な目的として、最も適切なものを1つ選択してください。"
    },
    "explanation": {
      "en-US": "例外処理は、プログラムの実行中に予期せぬエラー状況（例: ファイルが見つからない、不正な入力、ネットワーク接続エラーなど）が発生した場合に、プログラムがクラッシュ（異常終了）するのを防ぎ、エラー状況から回復したり、ユーザーに問題を通知したり、リソースを適切に解放したりするための仕組みです。これにより、プログラムの堅牢性（ロバストネス）を高めることができます。速度向上(A)、コンパイルエラー防止(B)、throws強制(D)、デバッグ情報出力(E)は主な目的ではありません。"
    },
    "questionCategory": {
      "en-US": "例外処理の基本的な目的"
    }
  }
]